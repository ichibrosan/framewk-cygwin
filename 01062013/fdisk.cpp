// fdisk.cpp 4/28/2011 dwg - 
// Copyright (c) 2011 Douglas W. Goodall. All Right Reserved.
// For hobby use by N8VEM community
// 4/29/2011 dwg - add leading 0 for fields in parttabl.asm
// 4/28/2011 dwg - version for Mac OS X 10.6.7 Snow Leopard

//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>
//#include <time.h>
//#include <unistd.h>

#include "asdefs.hpp"
#include "includes.hpp"

#define NUM_OF_PARTS 4
#define MAX_PARTS    4

// Don't change these
#define ONE_MEGABYTE 1048576
#define ONE_GIGABYTE (ONE_MEGABYTE * 1024)
#define MAX_BYTES_PER_LOGICAL_DRIVE (ONE_MEGABYTE * 8)
#define BYTES_PER_SECTOR 512
#define SECTORS_PER_TRACK 256
#define BYTES_PER_TRACK (SECTORS_PER_TRACK * BYTES_PER_SECTOR)
#define SAFESTRING 255
#define MAX_LOGICAL_DRIVE 8
#define TRKS_PER_LOG_DRV (MAX_BYTES_PER_LOGICAL_DRIVE/BYTES_PER_TRACK)
#define SECS_PER_LOG_DRV (TRKS_PER_LOG_DRV * SECTORS_PER_TRACK)

// <<THIS IS WHERE YOU SET THE SIZE OF THE PHYSICAL DRIVE>>>
#define BYTES_PER_PHY_DRV (30*ONE_MEGABYTE)

// Don't change these...
#define TRKS_PER_PHY_DRV ((BYTES_PER_PHY_DRV/BYTES_PER_TRACK)-1)
#define SECS_PER_PHY_DRV (TRKS_PER_PHY_DRV * SECTORS_PER_TRACK)

struct PART_TABLE {
	long start;
	long end;
} pt[MAX_PARTS];

long lNumParts;
long lLastEnd;
long lNewEnd;
long lNewMax;
long lNewStart;
long lPartTableSize;
long lAvail;

void display_menu(void)
{
	if(lNumParts < MAX_PARTS) {
		if(0l < lAvail) {
			printf("a - add partition #%ld\n",lNumParts+1);
		}
	}
	if(0 < lNumParts) {
		printf("d - delete partition #%ld\n",lNumParts);
	}
	if(0 == lNumParts) {
		printf("A - create all 8MB partitions\n");
	}
	printf("q - quit n8fdisk\n\n");
}

void pdelete(void)
{
	if(0 < lNumParts) {
		pt[lNumParts-1].start = 0;
		pt[lNumParts-1].end   = 0;
	}
}

int request(char *szPrompt)
{
	int iParm;
	printf("%s",szPrompt);
	scanf("%d",&iParm);
	return iParm;
}

long request2(char *szPrompt,long lDefault)
{
	int iParm;
	char szTemp[255];

	printf("%s",szPrompt);
	fgets(szTemp,sizeof(szTemp),stdin);
	if(1 == strlen(szTemp)) return(lDefault);

	return(atoi(szTemp));
}

void all(void)
{
	lAvail = SECS_PER_PHY_DRV;

	  lNumParts = 0l;
	  pt[lNumParts].start = 1;
	  pt[lNumParts].end   = pt[lNumParts++].start + SECS_PER_LOG_DRV-1;
	lAvail -= SECS_PER_LOG_DRV;

	for(int d=0;d<(lPartTableSize-1);d++) {
	  if(0 < lAvail) {
	    if(SECS_PER_LOG_DRV  <= lAvail) {
              pt[lNumParts].start = pt[lNumParts-1].end + 1;
              pt[lNumParts].end   = pt[lNumParts++].start + SECS_PER_LOG_DRV - 1;
	      lAvail -= SECS_PER_LOG_DRV;
	    } else {
              pt[lNumParts].start = pt[lNumParts-1].end + 1;
              pt[lNumParts].end   = pt[lNumParts++].start + lAvail - 1;
              lAvail = 0;
	    }
	  }
	}
}

long smaller(long a,long b)
{
	if(a<b) return a;
	else    return b;
}

void add(void)
{
	char szTemp[128];

//printf("DEBUG: avail is %d\n",avail);

//	iNewMax  = smaller(avail,TRKS_PER_LOG_DRV);;
//printf("DEBUG: iNewMax is %d\n",iNewMax);

	lNewMax = SECS_PER_LOG_DRV;

//	if(0 < iNewMax) { 

//printf("DEBUG: iLastEnd = %d\n",iLastEnd);
		
		lNewStart = lLastEnd + 1;

//printf("DEBUG: iNewStart is %d\n",iNewStart);

		sprintf(szTemp,"Number of Tracks (Max %ld)? ",lNewMax);

//		long lNewSize = smaller(lNewMax,request2(szTemp,lNewMax));

//printf("DEBUG: iNewSize is %d\n",iNewSize);

		lNewMax = smaller(TRKS_PER_LOG_DRV * SECTORS_PER_TRACK,lAvail);
                sprintf(szTemp,"Number of Sectors (Max %ld)? ",lNewMax);
		long lNewSize = request2(szTemp,lNewMax);

		pt[lNumParts].start = lNewStart;
		pt[lNumParts].end   = lNewStart + lNewSize - 1;
//	}
}

void view(void)
{
//	for(int l=0;l<52;l++) printf("\n");

	lNumParts = 0;
	lLastEnd = 0;

        for(int i=0;i<(int)lPartTableSize;i++) {
                if(0l < (pt[i].end-pt[i].start) ) {
                        lNumParts++;
                        lLastEnd = pt[i].end;
                }	
        }
	lAvail = SECS_PER_PHY_DRV - lLastEnd;
	
	printf("\nN8VEM Partition Editor by Douglas Goodall\n\n");
	printf("  Size    of  Physical Drive in MegaBytes is %ld\n",
		BYTES_PER_PHY_DRV / ONE_MEGABYTE);

	printf("  Sectors per Physical Drive are             %ld\n\n",
		(long)SECS_PER_PHY_DRV);
	for(int index=0;index<(int)lPartTableSize;index++) {

		if(0 != pt[index].start) {
		printf("Part# %d  ",index+1);
		printf("Start %6ld (0x%05lX), ",pt[index].start,pt[index].start);
		printf("End   %6ld (0X%05lX)  ",pt[index].end,  pt[index].end);
		printf("Size %6ld (0x%05lX) ",
			pt[index].end-pt[index].start+1,
                        pt[index].end-pt[index].start+1);
		printf("\n");
		}

	}
	printf("\n");
}


void gen_asm_part(char * argv0)
{
       FILE * fd3 = fopen("parttabl.asm","w");
	fprintf(fd3,"; parttabl.asm generated by %s, do not edit\n\n",argv0);
        fprintf(fd3,"p$table:\n");
        for(int i=0;i<(int)lPartTableSize;i++) {
        	fprintf(fd3,"P%d:\tdw %05lXH,%05lXH,%05lXH,%05lXH\t",i+1, 
			pt[i].start& 0xffffl,pt[i].start>>16,
			pt[i].end  & 0xFFFFl,pt[i].end  >>16);
		fprintf(fd3,"; %c: of %7ld MegaBytes\n",'C'+i,
		  (pt[i].end - pt[i].start + 1) * BYTES_PER_SECTOR / ONE_MEGABYTE);
	}
}


int main(int argc,char **argv)
{
	Version(argv[0]);

	char szTemp[SAFESTRING];
	char szChoice[SAFESTRING];
	char * psz;

//        iPartTableSize = request((char *)"Max number of partitions? ");
//	if(14 < iPartTableSize) iPartTableSize = 8;

	lPartTableSize = NUM_OF_PARTS;

	memset(&pt,0,sizeof(pt));

	FILE * fd = fopen("parttabl.bin","r");
	if(NULL != fd) {
		fread(&pt,1,sizeof(pt),fd);
		fclose(fd);
	} else {
		memset(&pt,0,(int)sizeof(pt));
	}

	int bRunning = 1;
	while(1 == bRunning) {
                view();
                display_menu();
		fgets(szChoice,sizeof(szChoice),stdin);
		switch(szChoice[0]) {
			case 'a': 	add();		break;
			case 'd':	pdelete();	break;
			case 'q':	bRunning = 0;	break;
			case 'A':	all();		break;
		}
	}

	FILE * fd2 = fopen("parttabl.bin","w");
	fwrite(&pt,1,sizeof(pt),fd2);
	fclose(fd2);

	FILE * fd3 = fopen("parttabl.xml","w");
	fprintf(fd3,"<OBJECT>\n");
	fprintf(fd3,"  <TYPE>N8VEM_PARTITION_TABLE</TYPE>\n");
	fprintf(fd3,"  <VERSION>2011-04-28</VERSION>\n");
	for(int i=0;i<(int)lPartTableSize;i++) {
		fprintf(fd3,"  <ENTRY>\n");
		fprintf(fd3,"    <NUMBER>%d</NUMBER>\n",i+1);
		fprintf(fd3,"    <BEGSEC>%ld</BEGSEC>\n",pt[i].start);
		fprintf(fd3,"    <ENDSEC>%ld</ENDSEC>\n",pt[i].end);
		fprintf(fd3,"  </ENTRY>\n");
	}
	fprintf(fd3,"</OBJECT>\n");
	fclose(fd3);

	gen_asm_part(argv[0]);

	return (EXIT_SUCCESS);
}
