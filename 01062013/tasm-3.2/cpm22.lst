0001   0000             
0002   0000             ;**************************************************************
0003   0000             ;*
0004   0000             ;*             C P / M   VERSION   2 . 2
0005   0000             ;*
0006   0000             ;*   RECONSTRUCTED FROM MEMORY IMAGE ON FEBRUARY 27, 1981
0007   0000             ;*
0008   0000             ;*                BY CLARK A. CALKINS
0009   0000             ;*
0010   0000             ;**************************************************************
0011   0000             ; Changes J Moxham 2008 - search for 'N8VEM' to find changes
0012   0000             ; swapped drive A and B in the data tables
0013   0000             ; swapped drive A and B in WRITE: subroutine 
0014   0000             ; swapped drive A and B in  READ: subroutine
0015   0000             ; deleted ide_soft_reset as taking a long time to do a soft reset when IDE driv
0016   0000             ; added txt_cold signon message to distinguish warm and cold boots
0017   0000             ; reset autoexec text on a warm boot see WBOOT
0018   0000             ; added a delay after CONOUT1 to test 2400 and 4800 baud, delay after send a by
0019   0000             ; all the changes above only just fit, if the signon message is truncated, chan
0020   0000             ; programs so more CPM space is reserved (the block move I think is the issue)
0021   0000             ; see extensive notes on the CONOUT subroutine re all the timing values that work
0022   0000             
0023   0000             ; converted to Z80 opcodes - copy the .asm file over to the N8VEM board and run XIZ on the file
0024   0000             ; returns a .z80 file. Then run tasm and look at the .lst file to find errors
0025   0000             ; manually look for all instances of .EQU that have been split to two lines. Put them back to 
0026   0000             ; one line. There were 10 in this program. 
0027   0000             
0028   0000             
0029   0000             ;
0030   0000             ;   SET MEMORY LIMIT HERE. THIS IS THE AMOUNT OF CONTIGEOUS
0031   0000             ; RAM STARTING FROM 0000. CP/M WILL RESIDE AT THE END OF THIS SPACE.
0032   0000             ;
0033   0000             MEM:	.EQU 60			; FOR A 62K SYSTEM (TS802 TEST - WORKS OK).
0034   0000             ;
0035   0000             IOBYTE:	.EQU 3			; I/O DEFINITION BYTE.
0036   0000             TDRIVE:	.EQU 4			; CURRENT DRIVE NAME AND USER NUMBER.
0037   0000             ENTRY:	.EQU 5			; ENTRY POINT FOR THE CP/M BDOS.
0038   0000             TFCB:	.EQU 5CH		; DEFAULT FILE CONTROL BLOCK.
0039   0000             TBUFF:	.EQU 80H		; I/O BUFFER AND COMMAND LINE STORAGE.
0040   0000             TBASE:	.EQU 100H		; TRANSIANT PROGRAM STORAGE AREA.
0041   0000             ;
0042   0000             ;   SET CONTROL CHARACTER EQUATES.
0043   0000             ;
0044   0000             CNTRLC:	.EQU 3			; CONTROL-C
0045   0000             CNTRLE:	.EQU 05H		; CONTROL-E
0046   0000             BS:	.EQU 08H		; BACKSPACE
0047   0000             TAB:	.EQU 09H		; TAB
0048   0000             LF:	.EQU 0AH		; LINE FEED
0049   0000             FF:	.EQU 0CH		; FORM FEED
0050   0000             CR:	.EQU 0DH		; CARRIAGE RETURN
0051   0000             CNTRLP:	.EQU 10H		; CONTROL-P
0052   0000             CNTRLR:	.EQU 12H		; CONTROL-R
0053   0000             CNTRLS:	.EQU 13H		; CONTROL-S
0054   0000             CNTRLU:	.EQU 15H		; CONTROL-U
0055   0000             CNTRLX:	.EQU 18H		; CONTROL-X
0056   0000             CNTRLZ:	.EQU 1AH		; CONTROL-Z (END-OF-FILE MARK)
0057   0000             DEL:	.EQU 7FH		; RUBOUT
0058   0000             ;
0059   0000             ;   SET ORIGIN FOR CP/M
0060   0000             ;
0061   D400             	.ORG (MEM-7)*1024
0062   D400             ;
0063   D400 C3 5C D7    CBASE:	JP	COMMAND		; EXECUTE COMMAND PROCESSOR (CCP).
0064   D403 C3 58 D7    	JP	CLEARBUF	; ENTRY TO EMPTY INPUT BUFFER BEFORE STARTING CCP.
0065   D406             
0066   D406             ;
0067   D406             ;   STANDARD CP/M CCP INPUT BUFFER. FORMAT IS (MAX LENGTH),
0068   D406             ; (ACTUAL LENGTH), (CHAR #1), (CHAR #2), (CHAR #3), ETC.
0069   D406             ;
0070   D406 7F          INBUFF:	.DB 127			; LENGTH OF INPUT BUFFER.
0071   D407             ; N8VEM - if add any text after this point, change db 0 below to length
0072   D407             ; and put a 0 after the text, and delete the same number of zeros after the dig
0073   D407             ; so that inpoint ends up at the same spot
0074   D407             ; INBUFF+1 is cleared on the next warm boot, so only runs once.
0075   D407             ;	.DB	0	;CURRENT LENGTH OF CONTENTS.
0076   D407             
0077   D407             
0078   D407 11          	.DB 17			; Autoboot length of string
0079   D408 53 55 50 45 	.DB    "SUPERSUB AUTOEXEC"
0079   D40C 52 53 55 42 
0079   D410 20 41 55 54 
0079   D414 4F 45 58 45 
0079   D418 43 
0080   D419 00          	.DB 0			; zero at end
0081   D41A             
0082   D41A             
0083   D41A 43 4F 50 59 	.DB "COPYRIGHT"
0083   D41E 52 49 47 48 
0083   D422 54 
0084   D423 20 31 39 37 	.DB " 1979 (C) BY "
0084   D427 39 20 28 43 
0084   D42B 29 20 42 59 
0084   D42F 20 
0085   D430 44 49 47 49 	.DB "DIGITAL RESEARCH      "
0085   D434 54 41 4C 20 
0085   D438 52 45 53 45 
0085   D43C 41 52 43 48 
0085   D440 20 20 20 20 
0085   D444 20 20 
0086   D446 00 00 00 00 	.DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0086   D44A 00 00 00 00 
0086   D44E 00 00 00 00 
0086   D452 00 00 00 00 
0086   D456 00 00 00 00 
0086   D45A 00 00 00 
0087   D45D 00 00 00 00 	.DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0087   D461 00 00 00 00 
0087   D465 00 00 00 00 
0087   D469 00 00 00 00 
0087   D46D 00 00 00 00 
0087   D471 00 00 00 
0088   D474             ;	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0089   D474 00 00 00 00 	.DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ; delete 6 zeros N8VEM
0089   D478 00 00 00 00 
0089   D47C 00 00 00 00 
0089   D480 00 00 00 00 
0089   D484 00 
0090   D485             ;	.DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0091   D485             
0092   D485 00 00 00    	.DB 0,0,0		; N8VEM now 3 zeros instead of 15 - comment out line above
0093   D488             
0094   D488             
0095   D488             
0096   D488 08 D4       INPOINT:.DW INBUFF+2		; INPUT LINE POINTER
0097   D48A 00 00       NAMEPNT:.DW 0			; INPUT LINE POINTER USED FOR ERROR MESSAGE. POINTS TO
0098   D48C             ;			;START OF NAME IN ERROR.
0099   D48C             ;
0100   D48C             ;   ROUTINE TO PRINT (A) ON THE CONSOLE. ALL REGISTERS USED.
0101   D48C             ;
0102   D48C 5F          PRINT:	LD	E,A		; SETUP BDOS CALL.
0103   D48D 0E 02       	LD	C,2
0104   D48F C3 05 00    	JP	ENTRY
0105   D492             ;
0106   D492             ;   ROUTINE TO PRINT (A) ON THE CONSOLE AND TO SAVE (BC).
0107   D492             ;
0108   D492 C5          PRINTB:	PUSH	BC
0109   D493 CD 8C D4    	CALL	PRINT
0110   D496 C1          	POP	BC
0111   D497 C9          	RET
0112   D498             ;
0113   D498             ;   ROUTINE TO SEND A CARRIAGE RETURN, LINE FEED COMBINATION
0114   D498             ; TO THE CONSOLE.
0115   D498             ;
0116   D498 3E 0D       CRLF:	LD	A,CR
0117   D49A CD 92 D4    	CALL	PRINTB
0118   D49D 3E 0A       	LD	A,LF
0119   D49F C3 92 D4    	JP	PRINTB
0120   D4A2             ;
0121   D4A2             ;   ROUTINE TO SEND ONE SPACE TO THE CONSOLE AND SAVE (BC).
0122   D4A2             ;
0123   D4A2 3E 20       SPACE:	LD	A,' '
0124   D4A4 C3 92 D4    	JP	PRINTB
0125   D4A7             ;
0126   D4A7             ;   ROUTINE TO PRINT CHARACTER STRING POINTED TO BE (BC) ON THE
0127   D4A7             ; CONSOLE. IT MUST TERMINATE WITH A NULL BYTE.
0128   D4A7             ;
0129   D4A7 C5          PLINE:	PUSH	BC
0130   D4A8 CD 98 D4    	CALL	CRLF
0131   D4AB E1          	POP	HL
0132   D4AC 7E          PLINE2:	LD	A,(HL)
0133   D4AD B7          	OR	A
0134   D4AE C8          	RET	Z
0135   D4AF 23          	INC	HL
0136   D4B0 E5          	PUSH	HL
0137   D4B1 CD 8C D4    	CALL	PRINT
0138   D4B4 E1          	POP	HL
0139   D4B5 C3 AC D4    	JP	PLINE2
0140   D4B8             ;
0141   D4B8             ;   ROUTINE TO RESET THE DISK SYSTEM.
0142   D4B8             ;
0143   D4B8 0E 0D       RESDSK:	LD	C,13
0144   D4BA C3 05 00    	JP	ENTRY
0145   D4BD             ;
0146   D4BD             ;   ROUTINE TO SELECT DISK (A).
0147   D4BD             ;
0148   D4BD 5F          DSKSEL:	LD	E,A
0149   D4BE 0E 0E       	LD	C,14
0150   D4C0 C3 05 00    	JP	ENTRY
0151   D4C3             ;
0152   D4C3             ;   ROUTINE TO CALL BDOS AND SAVE THE RETURN CODE. THE ZERO
0153   D4C3             ; FLAG IS SET ON A RETURN OF 0FFH.
0154   D4C3             ;
0155   D4C3 CD 05 00    ENTRY1:	CALL	ENTRY
0156   D4C6 32 EE DB    	LD	(RTNCODE),A	; SAVE RETURN CODE.
0157   D4C9 3C          	INC	A		; SET ZERO IF 0FFH RETURNED.
0158   D4CA C9          	RET
0159   D4CB             ;
0160   D4CB             ;   ROUTINE TO OPEN A FILE. (DE) MUST POINT TO THE FCB.
0161   D4CB             ;
0162   D4CB 0E 0F       OPEN:	LD	C,15
0163   D4CD C3 C3 D4    	JP	ENTRY1
0164   D4D0             ;
0165   D4D0             ;   ROUTINE TO OPEN FILE AT (FCB).
0166   D4D0             ;
0167   D4D0 AF          OPENFCB:XOR	A		; CLEAR THE RECORD NUMBER BYTE AT FCB+32
0168   D4D1 32 ED DB    	LD	(FCB+32),A
0169   D4D4 11 CD DB    	LD	DE,FCB
0170   D4D7 C3 CB D4    	JP	OPEN
0171   D4DA             ;
0172   D4DA             ;   ROUTINE TO CLOSE A FILE. (DE) POINTS TO FCB.
0173   D4DA             ;
0174   D4DA 0E 10       CLOSE:	LD	C,16
0175   D4DC C3 C3 D4    	JP	ENTRY1
0176   D4DF             ;
0177   D4DF             ;   ROUTINE TO SEARCH FOR THE FIRST FILE WITH AMBIGUEOUS NAME
0178   D4DF             ; (DE).
0179   D4DF             ;
0180   D4DF 0E 11       SRCHFST:LD	C,17
0181   D4E1 C3 C3 D4    	JP	ENTRY1
0182   D4E4             ;
0183   D4E4             ;   SEARCH FOR THE NEXT AMBIGEOUS FILE NAME.
0184   D4E4             ;
0185   D4E4 0E 12       SRCHNXT:LD	C,18
0186   D4E6 C3 C3 D4    	JP	ENTRY1
0187   D4E9             ;
0188   D4E9             ;   SEARCH FOR FILE AT (FCB).
0189   D4E9             ;
0190   D4E9 11 CD DB    SRCHFCB:LD	DE,FCB
0191   D4EC C3 DF D4    	JP	SRCHFST
0192   D4EF             ;
0193   D4EF             ;   ROUTINE TO DELETE A FILE POINTED TO BY (DE).
0194   D4EF             ;
0195   D4EF 0E 13       DELETE:	LD	C,19
0196   D4F1 C3 05 00    	JP	ENTRY
0197   D4F4             ;
0198   D4F4             ;   ROUTINE TO CALL THE BDOS AND SET THE ZERO FLAG IF A ZERO
0199   D4F4             ; STATUS IS RETURNED.
0200   D4F4             ;
0201   D4F4 CD 05 00    ENTRY2:	CALL	ENTRY
0202   D4F7 B7          	OR	A		; SET ZERO FLAG IF APPROPRIATE.
0203   D4F8 C9          	RET
0204   D4F9             ;
0205   D4F9             ;   ROUTINE TO READ THE NEXT RECORD FROM A SEQUENTIAL FILE.
0206   D4F9             ; (DE) POINTS TO THE FCB.
0207   D4F9             ;
0208   D4F9 0E 14       RDREC:	LD	C,20
0209   D4FB C3 F4 D4    	JP	ENTRY2
0210   D4FE             ;
0211   D4FE             ;   ROUTINE TO READ FILE AT (FCB).
0212   D4FE             ;
0213   D4FE 11 CD DB    READFCB:LD	DE,FCB
0214   D501 C3 F9 D4    	JP	RDREC
0215   D504             ;
0216   D504             ;   ROUTINE TO WRITE THE NEXT RECORD OF A SEQUENTIAL FILE.
0217   D504             ; (DE) POINTS TO THE FCB.
0218   D504             ;
0219   D504 0E 15       WRTREC:	LD	C,21
0220   D506 C3 F4 D4    	JP	ENTRY2
0221   D509             ;
0222   D509             ;   ROUTINE TO CREATE THE FILE POINTED TO BY (DE).
0223   D509             ;
0224   D509 0E 16       CREATE:	LD	C,22
0225   D50B C3 C3 D4    	JP	ENTRY1
0226   D50E             ;
0227   D50E             ;   ROUTINE TO RENAME THE FILE POINTED TO BY (DE). NOTE THAT
0228   D50E             ; THE NEW NAME STARTS AT (DE+16).
0229   D50E             ;
0230   D50E 0E 17       RENAM:	LD	C,23
0231   D510 C3 05 00    	JP	ENTRY
0232   D513             ;
0233   D513             ;   GET THE CURRENT USER CODE.
0234   D513             ;
0235   D513 1E FF       GETUSR:	LD	E,0FFH
0236   D515             ;
0237   D515             ;   ROUTNE TO GET OR SET THE CURRENT USER CODE.
0238   D515             ; IF (E) IS FF THEN THIS IS A GET, ELSE IT IS A SET.
0239   D515             ;
0240   D515             GETSETUC:
0241   D515 0E 20       	LD	C,32
0242   D517 C3 05 00    	JP	ENTRY
0243   D51A             ;
0244   D51A             ;   ROUTINE TO SET THE CURRENT DRIVE BYTE AT (TDRIVE).
0245   D51A             ;
0246   D51A CD 13 D5    SETCDRV:CALL	GETUSR		; GET USER NUMBER
0247   D51D 87          	ADD	A,A		; AND SHIFT INTO THE UPPER 4 BITS.
0248   D51E 87          	ADD	A,A
0249   D51F 87          	ADD	A,A
0250   D520 87          	ADD	A,A
0251   D521 21 EF DB    	LD	HL,CDRIVE	; NOW ADD IN THE CURRENT DRIVE NUMBER.
0252   D524 B6          	OR	(HL)
0253   D525 32 04 00    	LD	(TDRIVE),A	; AND SAVE.
0254   D528 C9          	RET
0255   D529             ;
0256   D529             ;   MOVE CURRENTLY ACTIVE DRIVE DOWN TO (TDRIVE).
0257   D529             ;
0258   D529 3A EF DB    MOVECD:	LD	A,(CDRIVE)
0259   D52C 32 04 00    	LD	(TDRIVE),A
0260   D52F C9          	RET
0261   D530             ;
0262   D530             ;   ROUTINE TO CONVERT (A) INTO UPPER CASE ASCII. ONLY LETTERS
0263   D530             ; ARE AFFECTED.
0264   D530             ;
0265   D530 FE 41       UPPER:	CP	'A'		; CHECK FOR LETTERS IN THE RANGE OF 'A' TO 'Z'.
0266   D532 D8          	RET	C
0267   D533 FE 7B       	CP	'{'
0268   D535 D0          	RET	NC
0269   D536 E6 5F       	AND	5FH		; CONVERT IT IF FOUND.
0270   D538 C9          	RET
0271   D539             ;
0272   D539             ;   ROUTINE TO GET A LINE OF INPUT. WE MUST CHECK TO SEE IF THE
0273   D539             ; USER IS IN (BATCH) MODE. IF SO, THEN READ THE INPUT FROM FILE
0274   D539             ; ($$$.SUB). AT THE END, RESET TO CONSOLE INPUT.
0275   D539             ;
0276   D539 3A AB DB    GETINP:	LD	A,(BATCH)	; IF =0, THEN USE CONSOLE INPUT.
0277   D53C B7          	OR	A
0278   D53D CA 96 D5    	JP	Z,GETINP1
0279   D540             ;
0280   D540             ;   USE THE SUBMIT FILE ($$$.SUB) WHICH IS PREPARED BY A
0281   D540             ; SUBMIT RUN. IT MUST BE ON DRIVE (A) AND IT WILL BE DELETED
0282   D540             ; IF AND ERROR OCCURES (LIKE EOF).
0283   D540             ;
0284   D540 3A EF DB    	LD	A,(CDRIVE)	; SELECT DRIVE 0 IF NEED BE.
0285   D543 B7          	OR	A
0286   D544 3E 00       	LD	A,0		; ALWAYS USE DRIVE A FOR SUBMIT.
0287   D546 C4 BD D4    	CALL	NZ,DSKSEL	; SELECT IT IF REQUIRED.
0288   D549 11 AC DB    	LD	DE,BATCHFCB
0289   D54C CD CB D4    	CALL	OPEN		; LOOK FOR IT.
0290   D54F CA 96 D5    	JP	Z,GETINP1	; IF NOT THERE, USE NORMAL INPUT.
0291   D552 3A BB DB    	LD	A,(BATCHFCB+15)	; GET LAST RECORD NUMBER+1.
0292   D555 3D          	DEC	A
0293   D556 32 CC DB    	LD	(BATCHFCB+32),A
0294   D559 11 AC DB    	LD	DE,BATCHFCB
0295   D55C CD F9 D4    	CALL	RDREC		; READ LAST RECORD.
0296   D55F C2 96 D5    	JP	NZ,GETINP1	; QUIT ON END OF FILE.
0297   D562             ;
0298   D562             ;   MOVE THIS RECORD INTO INPUT BUFFER.
0299   D562             ;
0300   D562 11 07 D4    	LD	DE,INBUFF+1
0301   D565 21 80 00    	LD	HL,TBUFF	; DATA WAS READ INTO BUFFER HERE.
0302   D568 06 80       	LD	B,128		; ALL 128 CHARACTERS MAY BE USED.
0303   D56A CD 42 D8    	CALL	HL2DE		; (HL) TO (DE), (B) BYTES.
0304   D56D 21 BA DB    	LD	HL,BATCHFCB+14
0305   D570 36 00       	LD	(HL),0		; ZERO OUT THE 'S2' BYTE.
0306   D572 23          	INC	HL		; AND DECREMENT THE RECORD COUNT.
0307   D573 35          	DEC	(HL)
0308   D574 11 AC DB    	LD	DE,BATCHFCB	; CLOSE THE BATCH FILE NOW.
0309   D577 CD DA D4    	CALL	CLOSE
0310   D57A CA 96 D5    	JP	Z,GETINP1	; QUIT ON AN ERROR.
0311   D57D 3A EF DB    	LD	A,(CDRIVE)	; RE-SELECT PREVIOUS DRIVE IF NEED BE.
0312   D580 B7          	OR	A
0313   D581 C4 BD D4    	CALL	NZ,DSKSEL	; DON'T DO NEEDLESS SELECTS.
0314   D584             ;
0315   D584             ;   PRINT LINE JUST READ ON CONSOLE.
0316   D584             ;
0317   D584 21 08 D4    	LD	HL,INBUFF+2
0318   D587 CD AC D4    	CALL	PLINE2
0319   D58A CD C2 D5    	CALL	CHKCON		; CHECK CONSOLE, QUIT ON A KEY.
0320   D58D CA A7 D5    	JP	Z,GETINP2	; JUMP IF NO KEY IS PRESSED.
0321   D590             ;
0322   D590             ;   TERMINATE THE SUBMIT JOB ON ANY KEYBOARD INPUT. DELETE THIS
0323   D590             ; FILE SUCH THAT IT IS NOT RE-STARTED AND JUMP TO NORMAL KEYBOARD
0324   D590             ; INPUT SECTION.
0325   D590             ;
0326   D590 CD DD D5    	CALL	DELBATCH	; DELETE THE BATCH FILE.
0327   D593 C3 82 D7    	JP	CMMND1		; AND RESTART COMMAND INPUT.
0328   D596             ;
0329   D596             ;   GET HERE FOR NORMAL KEYBOARD INPUT. DELETE THE SUBMIT FILE
0330   D596             ; INCASE THERE WAS ONE.
0331   D596             ;
0332   D596 CD DD D5    GETINP1:CALL	DELBATCH	; DELETE FILE ($$$.SUB).
0333   D599 CD 1A D5    	CALL	SETCDRV		; RESET ACTIVE DISK.
0334   D59C 0E 0A       	LD	C,10		; GET LINE FROM CONSOLE DEVICE.
0335   D59E 11 06 D4    	LD	DE,INBUFF
0336   D5A1 CD 05 00    	CALL	ENTRY
0337   D5A4 CD 29 D5    	CALL	MOVECD		; RESET CURRENT DRIVE (AGAIN).
0338   D5A7             ;
0339   D5A7             ;   CONVERT INPUT LINE TO UPPER CASE.
0340   D5A7             ;
0341   D5A7 21 07 D4    GETINP2:LD	HL,INBUFF+1
0342   D5AA 46          	LD	B,(HL)		; (B)=CHARACTER COUNTER.
0343   D5AB 23          GETINP3:INC	HL
0344   D5AC 78          	LD	A,B		; END OF THE LINE?
0345   D5AD B7          	OR	A
0346   D5AE CA BA D5    	JP	Z,GETINP4
0347   D5B1 7E          	LD	A,(HL)		; CONVERT TO UPPER CASE.
0348   D5B2 CD 30 D5    	CALL	UPPER
0349   D5B5 77          	LD	(HL),A
0350   D5B6 05          	DEC	B		; ADJUST CHARACTER COUNT.
0351   D5B7 C3 AB D5    	JP	GETINP3
0352   D5BA 77          GETINP4:LD	(HL),A		; ADD TRAILING NULL.
0353   D5BB 21 08 D4    	LD	HL,INBUFF+2
0354   D5BE 22 88 D4    	LD	(INPOINT),HL	; RESET INPUT LINE POINTER.
0355   D5C1 C9          	RET
0356   D5C2             ;
0357   D5C2             ;   ROUTINE TO CHECK THE CONSOLE FOR A KEY PRESSED. THE ZERO
0358   D5C2             ; FLAG IS SET IS NONE, ELSE THE CHARACTER IS RETURNED IN (A).
0359   D5C2             ;
0360   D5C2 0E 0B       CHKCON:	LD	C,11		; CHECK CONSOLE.
0361   D5C4 CD 05 00    	CALL	ENTRY
0362   D5C7 B7          	OR	A
0363   D5C8 C8          	RET	Z		; RETURN IF NOTHING.
0364   D5C9 0E 01       	LD	C,1		; ELSE GET CHARACTER.
0365   D5CB CD 05 00    	CALL	ENTRY
0366   D5CE B7          	OR	A		; CLEAR ZERO FLAG AND RETURN.
0367   D5CF C9          	RET
0368   D5D0             ;
0369   D5D0             ;   ROUTINE TO GET THE CURRENTLY ACTIVE DRIVE NUMBER.
0370   D5D0             ;
0371   D5D0 0E 19       GETDSK:	LD	C,25
0372   D5D2 C3 05 00    	JP	ENTRY
0373   D5D5             ;
0374   D5D5             ;   SET THE STABDARD DMA ADDRESS.
0375   D5D5             ;
0376   D5D5 11 80 00    STDDMA:	LD	DE,TBUFF
0377   D5D8             ;
0378   D5D8             ;   ROUTINE TO SET THE DMA ADDRESS TO (DE).
0379   D5D8             ;
0380   D5D8 0E 1A       DMASET:	LD	C,26
0381   D5DA C3 05 00    	JP	ENTRY
0382   D5DD             ;
0383   D5DD             ;  DELETE THE BATCH FILE CREATED BY SUBMIT.
0384   D5DD             ;
0385   D5DD             DELBATCH:
0386   D5DD 21 AB DB    	LD	HL,BATCH	; IS BATCH ACTIVE?
0387   D5E0 7E          	LD	A,(HL)
0388   D5E1 B7          	OR	A
0389   D5E2 C8          	RET	Z
0390   D5E3 36 00       	LD	(HL),0		; YES, DE-ACTIVATE IT.
0391   D5E5 AF          	XOR	A
0392   D5E6 CD BD D4    	CALL	DSKSEL		; SELECT DRIVE 0 FOR SURE.
0393   D5E9 11 AC DB    	LD	DE,BATCHFCB	; AND DELETE THIS FILE.
0394   D5EC CD EF D4    	CALL	DELETE
0395   D5EF 3A EF DB    	LD	A,(CDRIVE)	; RESET CURRENT DRIVE.
0396   D5F2 C3 BD D4    	JP	DSKSEL
0397   D5F5             
0398   D5F5             
0399   D5F5             ;
0400   D5F5             ;   CHECK TO TWO STRINGS AT (PATTRN1) AND (PATTRN2). THEY MUST BE
0401   D5F5             ; THE SAME OR WE HALT....
0402   D5F5             ;
0403   D5F5 11 28 D7    VERIFY:	LD	DE,PATTRN1	; THESE ARE THE SERIAL NUMBER BYTES.
0404   D5F8 21 00 DC    	LD	HL,PATTRN2	; DITTO, BUT HOW COULD THEY BE DIFFERENT?
0405   D5FB 06 06       	LD	B,6		; 6 BYTES EACH.
0406   D5FD 1A          VERIFY1:LD	A,(DE)
0407   D5FE BE          	CP	(HL)
0408   D5FF C2 CF D7    	JP	NZ,HALT		; JUMP TO HALT ROUTINE.
0409   D602 13          	INC	DE
0410   D603 23          	INC	HL
0411   D604 05          	DEC	B
0412   D605 C2 FD D5    	JP	NZ,VERIFY1
0413   D608 C9          	RET
0414   D609             ;
0415   D609             ;   PRINT BACK FILE NAME WITH A '?' TO INDICATE A SYNTAX ERROR.
0416   D609             ;
0417   D609 CD 98 D4    SYNERR:	CALL	CRLF		; END CURRENT LINE.
0418   D60C 2A 8A D4    	LD	HL,(NAMEPNT)	; THIS POINTS TO NAME IN ERROR.
0419   D60F 7E          SYNERR1:LD	A,(HL)		; PRINT IT UNTIL A SPACE OR NULL IS FOUND.
0420   D610 FE 20       	CP	' '
0421   D612 CA 22 D6    	JP	Z,SYNERR2
0422   D615 B7          	OR	A
0423   D616 CA 22 D6    	JP	Z,SYNERR2
0424   D619 E5          	PUSH	HL
0425   D61A CD 8C D4    	CALL	PRINT
0426   D61D E1          	POP	HL
0427   D61E 23          	INC	HL
0428   D61F C3 0F D6    	JP	SYNERR1
0429   D622 3E 3F       SYNERR2:LD	A,'?'		; ADD TRAILING '?'.
0430   D624 CD 8C D4    	CALL	PRINT
0431   D627 CD 98 D4    	CALL	CRLF
0432   D62A CD DD D5    	CALL	DELBATCH	; DELETE ANY BATCH FILE.
0433   D62D C3 82 D7    	JP	CMMND1		; AND RESTART FROM CONSOLE INPUT.
0434   D630             ;
0435   D630             ;   CHECK CHARACTER AT (DE) FOR LEGAL COMMAND INPUT. NOTE THAT THE
0436   D630             ; ZERO FLAG IS SET IF THE CHARACTER IS A DELIMITER.
0437   D630             ;
0438   D630 1A          CHECK:	LD	A,(DE)
0439   D631 B7          	OR	A
0440   D632 C8          	RET	Z
0441   D633 FE 20       	CP	' '		; CONTROL CHARACTERS ARE NOT LEGAL HERE.
0442   D635 DA 09 D6    	JP	C,SYNERR
0443   D638 C8          	RET	Z		; CHECK FOR VALID DELIMITER.
0444   D639 FE 3D       	CP	'='
0445   D63B C8          	RET	Z
0446   D63C FE 5F       	CP	'_'
0447   D63E C8          	RET	Z
0448   D63F FE 2E       	CP	'.'
0449   D641 C8          	RET	Z
0450   D642 FE 3A       	CP	':'
0451   D644 C8          	RET	Z
0452   D645 FE 3B       	CP	$03B		; SEMICOLON ';'
0453   D647 C8          	RET	Z
0454   D648 FE 3C       	CP	'<'
0455   D64A C8          	RET	Z
0456   D64B FE 3E       	CP	'>'
0457   D64D C8          	RET	Z
0458   D64E C9          	RET
0459   D64F             ;
0460   D64F             ;   GET THE NEXT NON-BLANK CHARACTER FROM (DE).
0461   D64F             ;
0462   D64F             NONBLANK:
0463   D64F 1A          	LD	A,(DE)
0464   D650 B7          	OR	A		; STRING ENDS WITH A NULL.
0465   D651 C8          	RET	Z
0466   D652 FE 20       	CP	' '
0467   D654 C0          	RET	NZ
0468   D655 13          	INC	DE
0469   D656 C3 4F D6    	JP	NONBLANK
0470   D659             ;
0471   D659             ;   ADD (HL)=(HL)+(A)
0472   D659             ;
0473   D659 85          ADDHL:	ADD	A,L
0474   D65A 6F          	LD	L,A
0475   D65B D0          	RET	NC		; TAKE CARE OF ANY CARRY.
0476   D65C 24          	INC	H
0477   D65D C9          	RET
0478   D65E             ;
0479   D65E             ;   CONVERT THE FIRST NAME IN (FCB).
0480   D65E             ;
0481   D65E 3E 00       CONVFST:LD	A,0
0482   D660             ;
0483   D660             ;   FORMAT A FILE NAME (CONVERT * TO '?', ETC.). ON RETURN,
0484   D660             ; (A)=0 IS AN UNAMBIGEOUS NAME WAS SPECIFIED. ENTER WITH (A) EQUAL TO
0485   D660             ; THE POSITION WITHIN THE FCB FOR THE NAME (EITHER 0 OR 16).
0486   D660             ;
0487   D660 21 CD DB    CONVERT:LD	HL,FCB
0488   D663 CD 59 D6    	CALL	ADDHL
0489   D666 E5          	PUSH	HL
0490   D667 E5          	PUSH	HL
0491   D668 AF          	XOR	A
0492   D669 32 F0 DB    	LD	(CHGDRV),A	; INITIALIZE DRIVE CHANGE FLAG.
0493   D66C 2A 88 D4    	LD	HL,(INPOINT)	; SET (HL) AS POINTER INTO INPUT LINE.
0494   D66F EB          	EX	DE,HL
0495   D670 CD 4F D6    	CALL	NONBLANK	; GET NEXT NON-BLANK CHARACTER.
0496   D673 EB          	EX	DE,HL
0497   D674 22 8A D4    	LD	(NAMEPNT),HL	; SAVE POINTER HERE FOR ANY ERROR MESSAGE.
0498   D677 EB          	EX	DE,HL
0499   D678 E1          	POP	HL
0500   D679 1A          	LD	A,(DE)		; GET FIRST CHARACTER.
0501   D67A B7          	OR	A
0502   D67B CA 89 D6    	JP	Z,CONVRT1
0503   D67E DE 40       	SBC	A,'A'-1		; MIGHT BE A DRIVE NAME, CONVERT TO BINARY.
0504   D680 47          	LD	B,A		; AND SAVE.
0505   D681 13          	INC	DE		; CHECK NEXT CHARACTER FOR A ':'.
0506   D682 1A          	LD	A,(DE)
0507   D683 FE 3A       	CP	':'
0508   D685 CA 90 D6    	JP	Z,CONVRT2
0509   D688 1B          	DEC	DE		; NOPE, MOVE POINTER BACK TO THE START OF THE LINE.
0510   D689 3A EF DB    CONVRT1:LD	A,(CDRIVE)
0511   D68C 77          	LD	(HL),A
0512   D68D C3 96 D6    	JP	CONVRT3
0513   D690 78          CONVRT2:LD	A,B
0514   D691 32 F0 DB    	LD	(CHGDRV),A	; SET CHANGE IN DRIVES FLAG.
0515   D694 70          	LD	(HL),B
0516   D695 13          	INC	DE
0517   D696             ;
0518   D696             ;   CONVERT THE BASIC FILE NAME.
0519   D696             ;
0520   D696 06 08       CONVRT3:LD	B,08H
0521   D698 CD 30 D6    CONVRT4:CALL	CHECK
0522   D69B CA B9 D6    	JP	Z,CONVRT8
0523   D69E 23          	INC	HL
0524   D69F FE 2A       	CP	'*'		; NOTE THAT AN '*' WILL FILL THE REMAINING
0525   D6A1 C2 A9 D6    	JP	NZ,CONVRT5	; FIELD WITH '?'.
0526   D6A4 36 3F       	LD	(HL),'?'
0527   D6A6 C3 AB D6    	JP	CONVRT6
0528   D6A9 77          CONVRT5:LD	(HL),A
0529   D6AA 13          	INC	DE
0530   D6AB 05          CONVRT6:DEC	B
0531   D6AC C2 98 D6    	JP	NZ,CONVRT4
0532   D6AF CD 30 D6    CONVRT7:CALL	CHECK		; GET NEXT DELIMITER.
0533   D6B2 CA C0 D6    	JP	Z,GETEXT
0534   D6B5 13          	INC	DE
0535   D6B6 C3 AF D6    	JP	CONVRT7
0536   D6B9 23          CONVRT8:INC	HL		; BLANK FILL THE FILE NAME.
0537   D6BA 36 20       	LD	(HL),' '
0538   D6BC 05          	DEC	B
0539   D6BD C2 B9 D6    	JP	NZ,CONVRT8
0540   D6C0             ;
0541   D6C0             ;   GET THE EXTENSION AND CONVERT IT.
0542   D6C0             ;
0543   D6C0 06 03       GETEXT:	LD	B,03H
0544   D6C2 FE 2E       	CP	'.'
0545   D6C4 C2 E9 D6    	JP	NZ,GETEXT5
0546   D6C7 13          	INC	DE
0547   D6C8 CD 30 D6    GETEXT1:CALL	CHECK
0548   D6CB CA E9 D6    	JP	Z,GETEXT5
0549   D6CE 23          	INC	HL
0550   D6CF FE 2A       	CP	'*'
0551   D6D1 C2 D9 D6    	JP	NZ,GETEXT2
0552   D6D4 36 3F       	LD	(HL),'?'
0553   D6D6 C3 DB D6    	JP	GETEXT3
0554   D6D9 77          GETEXT2:LD	(HL),A
0555   D6DA 13          	INC	DE
0556   D6DB 05          GETEXT3:DEC	B
0557   D6DC C2 C8 D6    	JP	NZ,GETEXT1
0558   D6DF CD 30 D6    GETEXT4:CALL	CHECK
0559   D6E2 CA F0 D6    	JP	Z,GETEXT6
0560   D6E5 13          	INC	DE
0561   D6E6 C3 DF D6    	JP	GETEXT4
0562   D6E9 23          GETEXT5:INC	HL
0563   D6EA 36 20       	LD	(HL),' '
0564   D6EC 05          	DEC	B
0565   D6ED C2 E9 D6    	JP	NZ,GETEXT5
0566   D6F0 06 03       GETEXT6:LD	B,3
0567   D6F2 23          GETEXT7:INC	HL
0568   D6F3 36 00       	LD	(HL),0
0569   D6F5 05          	DEC	B
0570   D6F6 C2 F2 D6    	JP	NZ,GETEXT7
0571   D6F9 EB          	EX	DE,HL
0572   D6FA 22 88 D4    	LD	(INPOINT),HL	; SAVE INPUT LINE POINTER.
0573   D6FD E1          	POP	HL
0574   D6FE             ;
0575   D6FE             ;   CHECK TO SEE IF THIS IS AN AMBIGEOUS FILE NAME SPECIFICATION.
0576   D6FE             ; SET THE (A) REGISTER TO NON ZERO IF IT IS.
0577   D6FE             ;
0578   D6FE 01 0B 00    	LD	BC,11		; SET NAME LENGTH.
0579   D701 23          GETEXT8:INC	HL
0580   D702 7E          	LD	A,(HL)
0581   D703 FE 3F       	CP	'?'		; ANY QUESTION MARKS?
0582   D705 C2 09 D7    	JP	NZ,GETEXT9
0583   D708 04          	INC	B		; COUNT THEM.
0584   D709 0D          GETEXT9:DEC	C
0585   D70A C2 01 D7    	JP	NZ,GETEXT8
0586   D70D 78          	LD	A,B
0587   D70E B7          	OR	A
0588   D70F C9          	RET
0589   D710             ;
0590   D710             ;   CP/M COMMAND TABLE. NOTE COMMANDS CAN BE EITHER 3 OR 4 CHARACTERS LONG.
0591   D710             ;
0592   D710             NUMCMDS:.EQU 6			; NUMBER OF COMMANDS
0593   D710 44 49 52 20 CMDTBL:	.DB "DIR "
0594   D714 45 52 41 20 	.DB "ERA "
0595   D718 54 59 50 45 	.DB "TYPE"
0596   D71C 53 41 56 45 	.DB "SAVE"
0597   D720 52 45 4E 20 	.DB "REN "
0598   D724 55 53 45 52 	.DB "USER"
0599   D728             ;
0600   D728             ;   THE FOLLOWING SIX BYTES MUST AGREE WITH THOSE AT (PATTRN2)
0601   D728             ; OR CP/M WILL HALT. WHY?
0602   D728             ;
0603   D728 00 16 00 00 PATTRN1:.DB 0,22,0,0,0,0	; (* SERIAL NUMBER BYTES *).
0603   D72C 00 00 
0604   D72E             ;
0605   D72E             ;   SEARCH THE COMMAND TABLE FOR A MATCH WITH WHAT HAS JUST
0606   D72E             ; BEEN ENTERED. IF A MATCH IS FOUND, THEN WE JUMP TO THE
0607   D72E             ; PROPER SECTION. ELSE JUMP TO (UNKNOWN).
0608   D72E             ; ON RETURN, THE (C) REGISTER IS SET TO THE COMMAND NUMBER
0609   D72E             ; THAT MATCHED (OR NUMCMDS+1 IF NO MATCH).
0610   D72E             ;
0611   D72E 21 10 D7    SEARCH:	LD	HL,CMDTBL
0612   D731 0E 00       	LD	C,0
0613   D733 79          SEARCH1:LD	A,C
0614   D734 FE 06       	CP	NUMCMDS		; THIS COMMANDS EXISTS.
0615   D736 D0          	RET	NC
0616   D737 11 CE DB    	LD	DE,FCB+1	; CHECK THIS ONE.
0617   D73A 06 04       	LD	B,4		; MAX COMMAND LENGTH.
0618   D73C 1A          SEARCH2:LD	A,(DE)
0619   D73D BE          	CP	(HL)
0620   D73E C2 4F D7    	JP	NZ,SEARCH3	; NOT A MATCH.
0621   D741 13          	INC	DE
0622   D742 23          	INC	HL
0623   D743 05          	DEC	B
0624   D744 C2 3C D7    	JP	NZ,SEARCH2
0625   D747 1A          	LD	A,(DE)		; ALLOW A 3 CHARACTER COMMAND TO MATCH.
0626   D748 FE 20       	CP	' '
0627   D74A C2 54 D7    	JP	NZ,SEARCH4
0628   D74D 79          	LD	A,C		; SET RETURN REGISTER FOR THIS COMMAND.
0629   D74E C9          	RET
0630   D74F 23          SEARCH3:INC	HL
0631   D750 05          	DEC	B
0632   D751 C2 4F D7    	JP	NZ,SEARCH3
0633   D754 0C          SEARCH4:INC	C
0634   D755 C3 33 D7    	JP	SEARCH1
0635   D758             ;
0636   D758             ;   SET THE INPUT BUFFER TO EMPTY AND THEN START THE COMMAND
0637   D758             ; PROCESSOR (CCP).
0638   D758             ;
0639   D758             CLEARBUF:
0640   D758 AF          	XOR	A
0641   D759 32 07 D4    	LD	(INBUFF+1),A	; SECOND BYTE IS ACTUAL LENGTH.
0642   D75C             ;
0643   D75C             ;**************************************************************
0644   D75C             ;*
0645   D75C             ;*
0646   D75C             ;* C C P  -   C O N S O L E   C O M M A N D   P R O C E S S O R
0647   D75C             ;*
0648   D75C             ;**************************************************************
0649   D75C             ;*
0650   D75C 31 AB DB    COMMAND:LD	SP,CCPSTACK	; SETUP STACK AREA.
0651   D75F C5          	PUSH	BC		; NOTE THAT (C) SHOULD BE EQUAL TO:
0652   D760 79          	LD	A,C		; (UUUUDDDD) WHERE 'UUUU' IS THE USER NUMBER
0653   D761 1F          	RRA			; AND 'DDDD' IS THE DRIVE NUMBER.
0654   D762 1F          	RRA
0655   D763 1F          	RRA
0656   D764 1F          	RRA
0657   D765 E6 0F       	AND	0FH		; ISOLATE THE USER NUMBER.
0658   D767 5F          	LD	E,A
0659   D768 CD 15 D5    	CALL	GETSETUC	; AND SET IT.
0660   D76B CD B8 D4    	CALL	RESDSK		; RESET THE DISK SYSTEM.
0661   D76E 32 AB DB    	LD	(BATCH),A	; CLEAR BATCH MODE FLAG.
0662   D771 C1          	POP	BC
0663   D772 79          	LD	A,C
0664   D773 E6 0F       	AND	0FH		; ISOLATE THE DRIVE NUMBER.
0665   D775 32 EF DB    	LD	(CDRIVE),A	; AND SAVE.
0666   D778 CD BD D4    	CALL	DSKSEL		; ...AND SELECT.
0667   D77B 3A 07 D4    	LD	A,(INBUFF+1)
0668   D77E B7          	OR	A		; ANYTHING IN INPUT BUFFER ALREADY?
0669   D77F C2 98 D7    	JP	NZ,CMMND2	; YES, WE JUST PROCESS IT.
0670   D782             ;
0671   D782             ;   ENTRY POINT TO GET A COMMAND LINE FROM THE CONSOLE.
0672   D782             ;
0673   D782 31 AB DB    CMMND1:	LD	SP,CCPSTACK	; SET STACK STRAIGHT.
0674   D785 CD 98 D4    	CALL	CRLF		; START A NEW LINE ON THE SCREEN.
0675   D788 CD D0 D5    	CALL	GETDSK		; GET CURRENT DRIVE.
0676   D78B C6 41       	ADD	A,'A'
0677   D78D CD 8C D4    	CALL	PRINT		; PRINT CURRENT DRIVE.
0678   D790 3E 3E       	LD	A,'>'
0679   D792 CD 8C D4    	CALL	PRINT		; AND ADD PROMPT.
0680   D795 CD 39 D5    	CALL	GETINP		; GET LINE FROM USER.
0681   D798             ;
0682   D798             ;   PROCESS COMMAND LINE HERE.
0683   D798             ;
0684   D798 11 80 00    CMMND2:	LD	DE,TBUFF
0685   D79B CD D8 D5    	CALL	DMASET		; SET STANDARD DMA ADDRESS.
0686   D79E CD D0 D5    	CALL	GETDSK
0687   D7A1 32 EF DB    	LD	(CDRIVE),A	; SET CURRENT DRIVE.
0688   D7A4 CD 5E D6    	CALL	CONVFST		; CONVERT NAME TYPED IN.
0689   D7A7 C4 09 D6    	CALL	NZ,SYNERR	; WILD CARDS ARE NOT ALLOWED.
0690   D7AA 3A F0 DB    	LD	A,(CHGDRV)	; IF A CHANGE IN DRIVES WAS INDICATED,
0691   D7AD B7          	OR	A		; THEN TREAT THIS AS AN UNKNOWN COMMAND
0692   D7AE C2 A5 DA    	JP	NZ,UNKNOWN	; WHICH GETS EXECUTED.
0693   D7B1 CD 2E D7    	CALL	SEARCH		; ELSE SEARCH COMMAND TABLE FOR A MATCH.
0694   D7B4             ;
0695   D7B4             ;   NOTE THAT AN UNKNOWN COMMAND RETURNS
0696   D7B4             ; WITH (A) POINTING TO THE LAST ADDRESS
0697   D7B4             ; IN OUR TABLE WHICH IS (UNKNOWN).
0698   D7B4             ;
0699   D7B4 21 C1 D7    	LD	HL,CMDADR	; NOW, LOOK THRU OUR ADDRESS TABLE FOR COMMAND (A).
0700   D7B7 5F          	LD	E,A		; SET (DE) TO COMMAND NUMBER.
0701   D7B8 16 00       	LD	D,0
0702   D7BA 19          	ADD	HL,DE
0703   D7BB 19          	ADD	HL,DE		; (HL)=(CMDADR)+2*(COMMAND NUMBER).
0704   D7BC 7E          	LD	A,(HL)		; NOW PICK OUT THIS ADDRESS.
0705   D7BD 23          	INC	HL
0706   D7BE 66          	LD	H,(HL)
0707   D7BF 6F          	LD	L,A
0708   D7C0 E9          	JP	(HL)		; NOW EXECUTE IT.
0709   D7C1             ;
0710   D7C1             ;   CP/M COMMAND ADDRESS TABLE.
0711   D7C1             ;
0712   D7C1 77 D8 1F D9 CMDADR:	.DW DIRECT,ERASE,TYPE,SAVE
0712   D7C5 5D D9 AD D9 
0713   D7C9 10 DA 8E DA 	.DW RENAME,USER,UNKNOWN
0713   D7CD A5 DA 
0714   D7CF             ;
0715   D7CF             ;   HALT THE SYSTEM. REASON FOR THIS IS UNKNOWN AT PRESENT.
0716   D7CF             ;
0717   D7CF 21 F3 76    HALT:	LD	HL,76F3H	; 'DI HLT' INSTRUCTIONS.
0718   D7D2 22 00 D4    	LD	(CBASE),HL
0719   D7D5 21 00 D4    	LD	HL,CBASE
0720   D7D8 E9          	JP	(HL)
0721   D7D9             ;
0722   D7D9             ;   READ ERROR WHILE TYPEING A FILE.
0723   D7D9             ;
0724   D7D9 01 DF D7    RDERROR:LD	BC,RDERR
0725   D7DC C3 A7 D4    	JP	PLINE
0726   D7DF 52 45 41 44 RDERR:	.DB "READ ERROR",0
0726   D7E3 20 45 52 52 
0726   D7E7 4F 52 00 
0727   D7EA             ;
0728   D7EA             ;   REQUIRED FILE WAS NOT LOCATED.
0729   D7EA             ;
0730   D7EA 01 F0 D7    NONE:	LD	BC,NOFILE
0731   D7ED C3 A7 D4    	JP	PLINE
0732   D7F0 4E 4F 20 46 NOFILE:	.DB "NO FILE",0
0732   D7F4 49 4C 45 00 
0733   D7F8             ;
0734   D7F8             ;   DECODE A COMMAND OF THE FORM 'A>FILENAME NUMBER{ FILENAME}.
0735   D7F8             ; NOTE THAT A DRIVE SPECIFIER IS NOT ALLOWED ON THE FIRST FILE
0736   D7F8             ; NAME. ON RETURN, THE NUMBER IS IN REGISTER (A). ANY ERROR
0737   D7F8             ; CAUSES 'FILENAME?' TO BE PRINTED AND THE COMMAND IS ABORTED.
0738   D7F8             ;
0739   D7F8 CD 5E D6    DECODE:	CALL	CONVFST		; CONVERT FILENAME.
0740   D7FB 3A F0 DB    	LD	A,(CHGDRV)	; DO NOT ALLOW A DRIVE TO BE SPECIFIED.
0741   D7FE B7          	OR	A
0742   D7FF C2 09 D6    	JP	NZ,SYNERR
0743   D802 21 CE DB    	LD	HL,FCB+1	; CONVERT NUMBER NOW.
0744   D805 01 0B 00    	LD	BC,11		; (B)=SUM REGISTER, (C)=MAX DIGIT COUNT.
0745   D808 7E          DECODE1:LD	A,(HL)
0746   D809 FE 20       	CP	' '		; A SPACE TERMINATES THE NUMERAL.
0747   D80B CA 33 D8    	JP	Z,DECODE3
0748   D80E 23          	INC	HL
0749   D80F D6 30       	SUB	'0'		; MAKE BINARY FROM ASCII.
0750   D811 FE 0A       	CP	10		; LEGAL DIGIT?
0751   D813 D2 09 D6    	JP	NC,SYNERR
0752   D816 57          	LD	D,A		; YES, SAVE IT IN (D).
0753   D817 78          	LD	A,B		; COMPUTE (B)=(B)*10 AND CHECK FOR OVERFLOW.
0754   D818 E6 E0       	AND	0E0H
0755   D81A C2 09 D6    	JP	NZ,SYNERR
0756   D81D 78          	LD	A,B
0757   D81E 07          	RLCA
0758   D81F 07          	RLCA
0759   D820 07          	RLCA			; (A)=(B)*8
0760   D821 80          	ADD	A,B		; .......*9
0761   D822 DA 09 D6    	JP	C,SYNERR
0762   D825 80          	ADD	A,B		; .......*10
0763   D826 DA 09 D6    	JP	C,SYNERR
0764   D829 82          	ADD	A,D		; ADD IN NEW DIGIT NOW.
0765   D82A DA 09 D6    DECODE2:JP	C,SYNERR
0766   D82D 47          	LD	B,A		; AND SAVE RESULT.
0767   D82E 0D          	DEC	C		; ONLY LOOK AT 11 DIGITS.
0768   D82F C2 08 D8    	JP	NZ,DECODE1
0769   D832 C9          	RET
0770   D833 7E          DECODE3:LD	A,(HL)		; SPACES MUST FOLLOW (WHY?).
0771   D834 FE 20       	CP	' '
0772   D836 C2 09 D6    	JP	NZ,SYNERR
0773   D839 23          	INC	HL
0774   D83A 0D          DECODE4:DEC	C
0775   D83B C2 33 D8    	JP	NZ,DECODE3
0776   D83E 78          	LD	A,B		; SET (A)=THE NUMERIC VALUE ENTERED.
0777   D83F C9          	RET
0778   D840             ;
0779   D840             ;   MOVE 3 BYTES FROM (HL) TO (DE). NOTE THAT THERE IS ONLY
0780   D840             ; ONE REFERENCE TO THIS AT (A2D5H).
0781   D840             ;
0782   D840 06 03       MOVE3:	LD	B,3
0783   D842             ;
0784   D842             ;   MOVE (B) BYTES FROM (HL) TO (DE).
0785   D842             ;
0786   D842 7E          HL2DE:	LD	A,(HL)
0787   D843 12          	LD	(DE),A
0788   D844 23          	INC	HL
0789   D845 13          	INC	DE
0790   D846 05          	DEC	B
0791   D847 C2 42 D8    	JP	NZ,HL2DE
0792   D84A C9          	RET
0793   D84B             ;
0794   D84B             ;   COMPUTE (HL)=(TBUFF)+(A)+(C) AND GET THE BYTE THAT'S HERE.
0795   D84B             ;
0796   D84B 21 80 00    EXTRACT:LD	HL,TBUFF
0797   D84E 81          	ADD	A,C
0798   D84F CD 59 D6    	CALL	ADDHL
0799   D852 7E          	LD	A,(HL)
0800   D853 C9          	RET
0801   D854             ;
0802   D854             ;  CHECK DRIVE SPECIFIED. IF IT MEANS A CHANGE, THEN THE NEW
0803   D854             ; DRIVE WILL BE SELECTED. IN ANY CASE, THE DRIVE BYTE OF THE
0804   D854             ; FCB WILL BE SET TO NULL (MEANS USE CURRENT DRIVE).
0805   D854             ;
0806   D854 AF          DSELECT:XOR	A		; NULL OUT FIRST BYTE OF FCB.
0807   D855 32 CD DB    	LD	(FCB),A
0808   D858 3A F0 DB    	LD	A,(CHGDRV)	; A DRIVE CHANGE INDICATED?
0809   D85B B7          	OR	A
0810   D85C C8          	RET	Z
0811   D85D 3D          	DEC	A		; YES, IS IT THE SAME AS THE CURRENT DRIVE?
0812   D85E 21 EF DB    	LD	HL,CDRIVE
0813   D861 BE          	CP	(HL)
0814   D862 C8          	RET	Z
0815   D863 C3 BD D4    	JP	DSKSEL		; NO. SELECT IT THEN.
0816   D866             ;
0817   D866             ;   CHECK THE DRIVE SELECTION AND RESET IT TO THE PREVIOUS
0818   D866             ; DRIVE IF IT WAS CHANGED FOR THE PRECEEDING COMMAND.
0819   D866             ;
0820   D866 3A F0 DB    RESETDR:LD	A,(CHGDRV)	; DRIVE CHANGE INDICATED?
0821   D869 B7          	OR	A
0822   D86A C8          	RET	Z
0823   D86B 3D          	DEC	A		; YES, WAS IT A DIFFERENT DRIVE?
0824   D86C 21 EF DB    	LD	HL,CDRIVE
0825   D86F BE          	CP	(HL)
0826   D870 C8          	RET	Z
0827   D871 3A EF DB    	LD	A,(CDRIVE)	; YES, RE-SELECT OUR OLD DRIVE.
0828   D874 C3 BD D4    	JP	DSKSEL
0829   D877             ;
0830   D877             ;**************************************************************
0831   D877             ;*
0832   D877             ;*           D I R E C T O R Y   C O M M A N D
0833   D877             ;*
0834   D877             ;**************************************************************
0835   D877             ;
0836   D877 CD 5E D6    DIRECT:	CALL	CONVFST		; CONVERT FILE NAME.
0837   D87A CD 54 D8    	CALL	DSELECT		; SELECT INDICATED DRIVE.
0838   D87D 21 CE DB    	LD	HL,FCB+1	; WAS ANY FILE INDICATED?
0839   D880 7E          	LD	A,(HL)
0840   D881 FE 20       	CP	' '
0841   D883 C2 8F D8    	JP	NZ,DIRECT2
0842   D886 06 0B       	LD	B,11		; NO. FILL FIELD WITH '?' - SAME AS *.*.
0843   D888 36 3F       DIRECT1:LD	(HL),'?'
0844   D88A 23          	INC	HL
0845   D88B 05          	DEC	B
0846   D88C C2 88 D8    	JP	NZ,DIRECT1
0847   D88F 1E 00       DIRECT2:LD	E,0		; SET INITIAL CURSOR POSITION.
0848   D891 D5          	PUSH	DE
0849   D892 CD E9 D4    	CALL	SRCHFCB		; GET FIRST FILE NAME.
0850   D895 CC EA D7    	CALL	Z,NONE		; NONE FOUND AT ALL?
0851   D898 CA 1B D9    DIRECT3:JP	Z,DIRECT9	; TERMINATE IF NO MORE NAMES.
0852   D89B 3A EE DB    	LD	A,(RTNCODE)	; GET FILE'S POSITION IN SEGMENT (0-3).
0853   D89E 0F          	RRCA
0854   D89F 0F          	RRCA
0855   D8A0 0F          	RRCA
0856   D8A1 E6 60       	AND	60H		; (A)=POSITION*32
0857   D8A3 4F          	LD	C,A
0858   D8A4 3E 0A       	LD	A,10
0859   D8A6 CD 4B D8    	CALL	EXTRACT		; EXTRACT THE TENTH ENTRY IN FCB.
0860   D8A9 17          	RLA			; CHECK SYSTEM FILE STATUS BIT.
0861   D8AA DA 0F D9    	JP	C,DIRECT8	; WE DON'T LIST THEM.
0862   D8AD D1          	POP	DE
0863   D8AE 7B          	LD	A,E		; BUMP NAME COUNT.
0864   D8AF 1C          	INC	E
0865   D8B0 D5          	PUSH	DE
0866   D8B1 E6 03       	AND	03H		; AT END OF LINE?
0867   D8B3 F5          	PUSH	AF
0868   D8B4 C2 CC D8    	JP	NZ,DIRECT4
0869   D8B7 CD 98 D4    	CALL	CRLF		; YES, END THIS LINE AND START ANOTHER.
0870   D8BA C5          	PUSH	BC
0871   D8BB CD D0 D5    	CALL	GETDSK		; START LINE WITH ('A:').
0872   D8BE C1          	POP	BC
0873   D8BF C6 41       	ADD	A,'A'
0874   D8C1 CD 92 D4    	CALL	PRINTB
0875   D8C4 3E 3A       	LD	A,':'
0876   D8C6 CD 92 D4    	CALL	PRINTB
0877   D8C9 C3 D4 D8    	JP	DIRECT5
0878   D8CC CD A2 D4    DIRECT4:CALL	SPACE		; ADD SEPERATOR BETWEEN FILE NAMES.
0879   D8CF 3E 3A       	LD	A,':'
0880   D8D1 CD 92 D4    	CALL	PRINTB
0881   D8D4 CD A2 D4    DIRECT5:CALL	SPACE
0882   D8D7 06 01       	LD	B,1		; 'EXTRACT' EACH FILE NAME CHARACTER AT A TIME.
0883   D8D9 78          DIRECT6:LD	A,B
0884   D8DA CD 4B D8    	CALL	EXTRACT
0885   D8DD E6 7F       	AND	7FH		; STRIP BIT 7 (STATUS BIT).
0886   D8DF FE 20       	CP	' '		; ARE WE AT THE END OF THE NAME?
0887   D8E1 C2 F9 D8    	JP	NZ,DRECT65
0888   D8E4 F1          	POP	AF		; YES, DON'T PRINT SPACES AT THE END OF A LINE.
0889   D8E5 F5          	PUSH	AF
0890   D8E6 FE 03       	CP	3
0891   D8E8 C2 F7 D8    	JP	NZ,DRECT63
0892   D8EB 3E 09       	LD	A,9		; FIRST CHECK FOR NO EXTENSION.
0893   D8ED CD 4B D8    	CALL	EXTRACT
0894   D8F0 E6 7F       	AND	7FH
0895   D8F2 FE 20       	CP	' '
0896   D8F4 CA 0E D9    	JP	Z,DIRECT7	; DON'T PRINT SPACES.
0897   D8F7 3E 20       DRECT63:LD	A,' '		; ELSE PRINT THEM.
0898   D8F9 CD 92 D4    DRECT65:CALL	PRINTB
0899   D8FC 04          	INC	B		; BUMP TO NEXT CHARACTER PSOITION.
0900   D8FD 78          	LD	A,B
0901   D8FE FE 0C       	CP	12		; END OF THE NAME?
0902   D900 D2 0E D9    	JP	NC,DIRECT7
0903   D903 FE 09       	CP	9		; NOPE, STARTING EXTENSION?
0904   D905 C2 D9 D8    	JP	NZ,DIRECT6
0905   D908 CD A2 D4    	CALL	SPACE		; YES, ADD SEPERATING SPACE.
0906   D90B C3 D9 D8    	JP	DIRECT6
0907   D90E F1          DIRECT7:POP	AF		; GET THE NEXT FILE NAME.
0908   D90F CD C2 D5    DIRECT8:CALL	CHKCON		; FIRST CHECK CONSOLE, QUIT ON ANYTHING.
0909   D912 C2 1B D9    	JP	NZ,DIRECT9
0910   D915 CD E4 D4    	CALL	SRCHNXT		; GET NEXT NAME.
0911   D918 C3 98 D8    	JP	DIRECT3		; AND CONTINUE WITH OUR LIST.
0912   D91B D1          DIRECT9:POP	DE		; RESTORE THE STACK AND RETURN TO COMMAND LEVEL.
0913   D91C C3 86 DB    	JP	GETBACK
0914   D91F             ;
0915   D91F             ;**************************************************************
0916   D91F             ;*
0917   D91F             ;*                E R A S E   C O M M A N D
0918   D91F             ;*
0919   D91F             ;**************************************************************
0920   D91F             ;
0921   D91F CD 5E D6    ERASE:	CALL	CONVFST		; CONVERT FILE NAME.
0922   D922 FE 0B       	CP	11		; WAS '*.*' ENTERED?
0923   D924 C2 42 D9    	JP	NZ,ERASE1
0924   D927 01 52 D9    	LD	BC,YESNO	; YES, ASK FOR CONFIRMATION.
0925   D92A CD A7 D4    	CALL	PLINE
0926   D92D CD 39 D5    	CALL	GETINP
0927   D930 21 07 D4    	LD	HL,INBUFF+1
0928   D933 35          	DEC	(HL)		; MUST BE EXACTLY 'Y'.
0929   D934 C2 82 D7    	JP	NZ,CMMND1
0930   D937 23          	INC	HL
0931   D938 7E          	LD	A,(HL)
0932   D939 FE 59       	CP	'Y'
0933   D93B C2 82 D7    	JP	NZ,CMMND1
0934   D93E 23          	INC	HL
0935   D93F 22 88 D4    	LD	(INPOINT),HL	; SAVE INPUT LINE POINTER.
0936   D942 CD 54 D8    ERASE1:	CALL	DSELECT		; SELECT DESIRED DISK.
0937   D945 11 CD DB    	LD	DE,FCB
0938   D948 CD EF D4    	CALL	DELETE		; DELETE THE FILE.
0939   D94B 3C          	INC	A
0940   D94C CC EA D7    	CALL	Z,NONE		; NOT THERE?
0941   D94F C3 86 DB    	JP	GETBACK		; RETURN TO COMMAND LEVEL NOW.
0942   D952 41 4C 4C 20 YESNO:	.DB "ALL (Y/N)?",0
0942   D956 28 59 2F 4E 
0942   D95A 29 3F 00 
0943   D95D             ;
0944   D95D             ;**************************************************************
0945   D95D             ;*
0946   D95D             ;*            T Y P E   C O M M A N D
0947   D95D             ;*
0948   D95D             ;**************************************************************
0949   D95D             ;
0950   D95D CD 5E D6    TYPE:	CALL	CONVFST		; CONVERT FILE NAME.
0951   D960 C2 09 D6    	JP	NZ,SYNERR	; WILD CARDS NOT ALLOWED.
0952   D963 CD 54 D8    	CALL	DSELECT		; SELECT INDICATED DRIVE.
0953   D966 CD D0 D4    	CALL	OPENFCB		; OPEN THE FILE.
0954   D969 CA A7 D9    	JP	Z,TYPE5		; NOT THERE?
0955   D96C CD 98 D4    	CALL	CRLF		; OK, START A NEW LINE ON THE SCREEN.
0956   D96F 21 F1 DB    	LD	HL,NBYTES	; INITIALIZE BYTE COUNTER.
0957   D972 36 FF       	LD	(HL),0FFH	; SET TO READ FIRST SECTOR.
0958   D974 21 F1 DB    TYPE1:	LD	HL,NBYTES
0959   D977 7E          TYPE2:	LD	A,(HL)		; HAVE WE WRITTEN THE ENTIRE SECTOR?
0960   D978 FE 80       	CP	128
0961   D97A DA 87 D9    	JP	C,TYPE3
0962   D97D E5          	PUSH	HL		; YES, READ IN THE NEXT ONE.
0963   D97E CD FE D4    	CALL	READFCB
0964   D981 E1          	POP	HL
0965   D982 C2 A0 D9    	JP	NZ,TYPE4	; END OR ERROR?
0966   D985 AF          	XOR	A		; OK, CLEAR BYTE COUNTER.
0967   D986 77          	LD	(HL),A
0968   D987 34          TYPE3:	INC	(HL)		; COUNT THIS BYTE.
0969   D988 21 80 00    	LD	HL,TBUFF	; AND GET THE (A)TH ONE FROM THE BUFFER (TBUFF).
0970   D98B CD 59 D6    	CALL	ADDHL
0971   D98E 7E          	LD	A,(HL)
0972   D98F FE 1A       	CP	CNTRLZ		; END OF FILE MARK?
0973   D991 CA 86 DB    	JP	Z,GETBACK
0974   D994 CD 8C D4    	CALL	PRINT		; NO, PRINT IT.
0975   D997 CD C2 D5    	CALL	CHKCON		; CHECK CONSOLE, QUIT IF ANYTHING READY.
0976   D99A C2 86 DB    	JP	NZ,GETBACK
0977   D99D C3 74 D9    	JP	TYPE1
0978   D9A0             ;
0979   D9A0             ;   GET HERE ON AN END OF FILE OR READ ERROR.
0980   D9A0             ;
0981   D9A0 3D          TYPE4:	DEC	A		; READ ERROR?
0982   D9A1 CA 86 DB    	JP	Z,GETBACK
0983   D9A4 CD D9 D7    	CALL	RDERROR		; YES, PRINT MESSAGE.
0984   D9A7 CD 66 D8    TYPE5:	CALL	RESETDR		; AND RESET PROPER DRIVE
0985   D9AA C3 09 D6    	JP	SYNERR		; NOW PRINT FILE NAME WITH PROBLEM.
0986   D9AD             ;
0987   D9AD             ;**************************************************************
0988   D9AD             ;*
0989   D9AD             ;*            S A V E   C O M M A N D
0990   D9AD             ;*
0991   D9AD             ;**************************************************************
0992   D9AD             ;
0993   D9AD CD F8 D7    SAVE:	CALL	DECODE		; GET NUMERIC NUMBER THAT FOLLOWS SAVE.
0994   D9B0 F5          	PUSH	AF		; SAVE NUMBER OF PAGES TO WRITE.
0995   D9B1 CD 5E D6    	CALL	CONVFST		; CONVERT FILE NAME.
0996   D9B4 C2 09 D6    	JP	NZ,SYNERR	; WILD CARDS NOT ALLOWED.
0997   D9B7 CD 54 D8    	CALL	DSELECT		; SELECT SPECIFIED DRIVE.
0998   D9BA 11 CD DB    	LD	DE,FCB		; NOW DELETE THIS FILE.
0999   D9BD D5          	PUSH	DE
1000   D9BE CD EF D4    	CALL	DELETE
1001   D9C1 D1          	POP	DE
1002   D9C2 CD 09 D5    	CALL	CREATE		; AND CREATE IT AGAIN.
1003   D9C5 CA FB D9    	JP	Z,SAVE3		; CAN'T CREATE?
1004   D9C8 AF          	XOR	A		; CLEAR RECORD NUMBER BYTE.
1005   D9C9 32 ED DB    	LD	(FCB+32),A
1006   D9CC F1          	POP	AF		; CONVERT PAGES TO SECTORS.
1007   D9CD 6F          	LD	L,A
1008   D9CE 26 00       	LD	H,0
1009   D9D0 29          	ADD	HL,HL		; (HL)=NUMBER OF SECTORS TO WRITE.
1010   D9D1 11 00 01    	LD	DE,TBASE	; AND WE START FROM HERE.
1011   D9D4 7C          SAVE1:	LD	A,H		; DONE YET?
1012   D9D5 B5          	OR	L
1013   D9D6 CA F1 D9    	JP	Z,SAVE2
1014   D9D9 2B          	DEC	HL		; NOPE, COUNT THIS AND COMPUTE THE START
1015   D9DA E5          	PUSH	HL		; OF THE NEXT 128 BYTE SECTOR.
1016   D9DB 21 80 00    	LD	HL,128
1017   D9DE 19          	ADD	HL,DE
1018   D9DF E5          	PUSH	HL		; SAVE IT AND SET THE TRANSFER ADDRESS.
1019   D9E0 CD D8 D5    	CALL	DMASET
1020   D9E3 11 CD DB    	LD	DE,FCB		; WRITE OUT THIS SECTOR NOW.
1021   D9E6 CD 04 D5    	CALL	WRTREC
1022   D9E9 D1          	POP	DE		; RESET (DE) TO THE START OF THE LAST SECTOR.
1023   D9EA E1          	POP	HL		; RESTORE SECTOR COUNT.
1024   D9EB C2 FB D9    	JP	NZ,SAVE3	; WRITE ERROR?
1025   D9EE C3 D4 D9    	JP	SAVE1
1026   D9F1             ;
1027   D9F1             ;   GET HERE AFTER WRITING ALL OF THE FILE.
1028   D9F1             ;
1029   D9F1 11 CD DB    SAVE2:	LD	DE,FCB		; NOW CLOSE THE FILE.
1030   D9F4 CD DA D4    	CALL	CLOSE
1031   D9F7 3C          	INC	A		; DID IT CLOSE OK?
1032   D9F8 C2 01 DA    	JP	NZ,SAVE4
1033   D9FB             ;
1034   D9FB             ;   PRINT OUT ERROR MESSAGE (NO SPACE).
1035   D9FB             ;
1036   D9FB 01 07 DA    SAVE3:	LD	BC,NOSPACE
1037   D9FE CD A7 D4    	CALL	PLINE
1038   DA01 CD D5 D5    SAVE4:	CALL	STDDMA		; RESET THE STANDARD DMA ADDRESS.
1039   DA04 C3 86 DB    	JP	GETBACK
1040   DA07 4E 4F 20 53 NOSPACE:.DB "NO SPACE",0
1040   DA0B 50 41 43 45 
1040   DA0F 00 
1041   DA10             ;
1042   DA10             ;**************************************************************
1043   DA10             ;*
1044   DA10             ;*           R E N A M E   C O M M A N D
1045   DA10             ;*
1046   DA10             ;**************************************************************
1047   DA10             ;
1048   DA10 CD 5E D6    RENAME:	CALL	CONVFST		; CONVERT FIRST FILE NAME.
1049   DA13 C2 09 D6    	JP	NZ,SYNERR	; WILD CARDS NOT ALLOWED.
1050   DA16 3A F0 DB    	LD	A,(CHGDRV)	; REMEMBER ANY CHANGE IN DRIVES SPECIFIED.
1051   DA19 F5          	PUSH	AF
1052   DA1A CD 54 D8    	CALL	DSELECT		; AND SELECT THIS DRIVE.
1053   DA1D CD E9 D4    	CALL	SRCHFCB		; IS THIS FILE PRESENT?
1054   DA20 C2 79 DA    	JP	NZ,RENAME6	; YES, PRINT ERROR MESSAGE.
1055   DA23 21 CD DB    	LD	HL,FCB		; YES, MOVE THIS NAME INTO SECOND SLOT.
1056   DA26 11 DD DB    	LD	DE,FCB+16
1057   DA29 06 10       	LD	B,16
1058   DA2B CD 42 D8    	CALL	HL2DE
1059   DA2E 2A 88 D4    	LD	HL,(INPOINT)	; GET INPUT POINTER.
1060   DA31 EB          	EX	DE,HL
1061   DA32 CD 4F D6    	CALL	NONBLANK	; GET NEXT NON BLANK CHARACTER.
1062   DA35 FE 3D       	CP	'='		; ONLY ALLOW AN '=' OR '_' SEPERATOR.
1063   DA37 CA 3F DA    	JP	Z,RENAME1
1064   DA3A FE 5F       	CP	'_'
1065   DA3C C2 73 DA    	JP	NZ,RENAME5
1066   DA3F EB          RENAME1:EX	DE,HL
1067   DA40 23          	INC	HL		; OK, SKIP SEPERATOR.
1068   DA41 22 88 D4    	LD	(INPOINT),HL	; SAVE INPUT LINE POINTER.
1069   DA44 CD 5E D6    	CALL	CONVFST		; CONVERT THIS SECOND FILE NAME NOW.
1070   DA47 C2 73 DA    	JP	NZ,RENAME5	; AGAIN, NO WILD CARDS.
1071   DA4A F1          	POP	AF		; IF A DRIVE WAS SPECIFIED, THEN IT
1072   DA4B 47          	LD	B,A		; MUST BE THE SAME AS BEFORE.
1073   DA4C 21 F0 DB    	LD	HL,CHGDRV
1074   DA4F 7E          	LD	A,(HL)
1075   DA50 B7          	OR	A
1076   DA51 CA 59 DA    	JP	Z,RENAME2
1077   DA54 B8          	CP	B
1078   DA55 70          	LD	(HL),B
1079   DA56 C2 73 DA    	JP	NZ,RENAME5	; THEY WERE DIFFERENT, ERROR.
1080   DA59 70          RENAME2:LD	(HL),B		; 	RESET AS PER THE FIRST FILE SPECIFICATION.
1081   DA5A AF          	XOR	A
1082   DA5B 32 CD DB    	LD	(FCB),A		; CLEAR THE DRIVE BYTE OF THE FCB.
1083   DA5E CD E9 D4    RENAME3:CALL	SRCHFCB		; AND GO LOOK FOR SECOND FILE.
1084   DA61 CA 6D DA    	JP	Z,RENAME4	; DOESN'T EXIST?
1085   DA64 11 CD DB    	LD	DE,FCB
1086   DA67 CD 0E D5    	CALL	RENAM		; OK, RENAME THE FILE.
1087   DA6A C3 86 DB    	JP	GETBACK
1088   DA6D             ;
1089   DA6D             ;   PROCESS RENAME ERRORS HERE.
1090   DA6D             ;
1091   DA6D CD EA D7    RENAME4:CALL	NONE		; FILE NOT THERE.
1092   DA70 C3 86 DB    	JP	GETBACK
1093   DA73 CD 66 D8    RENAME5:CALL	RESETDR		; BAD COMMAND FORMAT.
1094   DA76 C3 09 D6    	JP	SYNERR
1095   DA79 01 82 DA    RENAME6:LD	BC,EXISTS	; DESTINATION FILE ALREADY EXISTS.
1096   DA7C CD A7 D4    	CALL	PLINE
1097   DA7F C3 86 DB    	JP	GETBACK
1098   DA82 46 49 4C 45 EXISTS:	.DB "FILE EXISTS",0
1098   DA86 20 45 58 49 
1098   DA8A 53 54 53 00 
1099   DA8E             ;
1100   DA8E             ;**************************************************************
1101   DA8E             ;*
1102   DA8E             ;*             U S E R   C O M M A N D
1103   DA8E             ;*
1104   DA8E             ;**************************************************************
1105   DA8E             ;
1106   DA8E CD F8 D7    USER:	CALL	DECODE		; GET NUMERIC VALUE FOLLOWING COMMAND.
1107   DA91 FE 10       	CP	16		; LEGAL USER NUMBER?
1108   DA93 D2 09 D6    	JP	NC,SYNERR
1109   DA96 5F          	LD	E,A		; YES BUT IS THERE ANYTHING ELSE?
1110   DA97 3A CE DB    	LD	A,(FCB+1)
1111   DA9A FE 20       	CP	' '
1112   DA9C CA 09 D6    	JP	Z,SYNERR	; YES, THAT IS NOT ALLOWED.
1113   DA9F CD 15 D5    	CALL	GETSETUC	; OK, SET USER CODE.
1114   DAA2 C3 89 DB    	JP	GETBACK1
1115   DAA5             ;
1116   DAA5             ;**************************************************************
1117   DAA5             ;*
1118   DAA5             ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1119   DAA5             ;*
1120   DAA5             ;**************************************************************
1121   DAA5             ;
1122   DAA5 CD F5 D5    UNKNOWN:CALL	VERIFY		; CHECK FOR VALID SYSTEM (WHY?).
1123   DAA8 3A CE DB    	LD	A,(FCB+1)	; ANYTHING TO EXECUTE?
1124   DAAB FE 20       	CP	' '
1125   DAAD C2 C4 DA    	JP	NZ,UNKWN1
1126   DAB0 3A F0 DB    	LD	A,(CHGDRV)	; NOPE, ONLY A DRIVE CHANGE?
1127   DAB3 B7          	OR	A
1128   DAB4 CA 89 DB    	JP	Z,GETBACK1	; NEITHER???
1129   DAB7 3D          	DEC	A
1130   DAB8 32 EF DB    	LD	(CDRIVE),A	; OK, STORE NEW DRIVE.
1131   DABB CD 29 D5    	CALL	MOVECD		; SET (TDRIVE) ALSO.
1132   DABE CD BD D4    	CALL	DSKSEL		; AND SELECT THIS DRIVE.
1133   DAC1 C3 89 DB    	JP	GETBACK1	; THEN RETURN.
1134   DAC4             ;
1135   DAC4             ;   HERE A FILE NAME WAS TYPED. PREPARE TO EXECUTE IT.
1136   DAC4             ;
1137   DAC4 11 D6 DB    UNKWN1:	LD	DE,FCB+9	; AN EXTENSION SPECIFIED?  
1138   DAC7 1A          	LD	A,(DE)
1139   DAC8 FE 20       	CP	' '
1140   DACA C2 09 D6    	JP	NZ,SYNERR	; YES, NOT ALLOWED.
1141   DACD D5          UNKWN2:	PUSH	DE
1142   DACE CD 54 D8    	CALL	DSELECT		; SELECT SPECIFIED DRIVE.
1143   DAD1 D1          	POP	DE
1144   DAD2 21 83 DB    	LD	HL,COMFILE	; SET THE EXTENSION TO 'COM'.  LD HL,COMFILE
1145   DAD5 CD 40 D8    	CALL	MOVE3		; move 3 bytes from (HL) to (DE) to add .COM
1146   DAD8 CD D0 D4    	CALL	OPENFCB		; AND OPEN THIS FILE.
1147   DADB CA 6B DB    	JP	Z,UNKWN9	; NOT PRESENT?
1148   DADE             ;
1149   DADE             ;   LOAD IN THE PROGRAM.
1150   DADE             ;
1151   DADE 21 00 01    	LD	HL,TBASE	; STORE THE PROGRAM STARTING HERE.
1152   DAE1 E5          UNKWN3:	PUSH	HL
1153   DAE2 EB          	EX	DE,HL
1154   DAE3 CD D8 D5    	CALL	DMASET		; SET TRANSFER ADDRESS.
1155   DAE6 11 CD DB    	LD	DE,FCB		; AND READ THE NEXT RECORD.
1156   DAE9 CD F9 D4    	CALL	RDREC
1157   DAEC C2 01 DB    	JP	NZ,UNKWN4	; END OF FILE OR READ ERROR?
1158   DAEF E1          	POP	HL		; NOPE, BUMP POINTER FOR NEXT SECTOR.
1159   DAF0 11 80 00    	LD	DE,128
1160   DAF3 19          	ADD	HL,DE
1161   DAF4 11 00 D4    	LD	DE,CBASE	; ENOUGH ROOM FOR THE WHOLE FILE?
1162   DAF7 7D          	LD	A,L
1163   DAF8 93          	SUB	E
1164   DAF9 7C          	LD	A,H
1165   DAFA 9A          	SBC	A,D
1166   DAFB D2 71 DB    	JP	NC,UNKWN0	; NO, IT CAN'T FIT.
1167   DAFE C3 E1 DA    	JP	UNKWN3
1168   DB01             ;
1169   DB01             ;   GET HERE AFTER FINISHED READING.
1170   DB01             ;
1171   DB01 E1          UNKWN4:	POP	HL
1172   DB02 3D          	DEC	A		; NORMAL END OF FILE?
1173   DB03 C2 71 DB    	JP	NZ,UNKWN0
1174   DB06 CD 66 D8    	CALL	RESETDR		; YES, RESET PREVIOUS DRIVE.
1175   DB09 CD 5E D6    	CALL	CONVFST		; CONVERT THE FIRST FILE NAME THAT FOLLOWS
1176   DB0C 21 F0 DB    	LD	HL,CHGDRV	; COMMAND NAME.
1177   DB0F E5          	PUSH	HL
1178   DB10 7E          	LD	A,(HL)		; SET DRIVE CODE IN DEFAULT FCB.
1179   DB11 32 CD DB    	LD	(FCB),A
1180   DB14 3E 10       	LD	A,16		; PUT SECOND NAME 16 BYTES LATER.
1181   DB16 CD 60 D6    	CALL	CONVERT		; CONVERT SECOND FILE NAME.
1182   DB19 E1          	POP	HL
1183   DB1A 7E          	LD	A,(HL)		; AND SET THE DRIVE FOR THIS SECOND FILE.
1184   DB1B 32 DD DB    	LD	(FCB+16),A
1185   DB1E AF          	XOR	A		; CLEAR RECORD BYTE IN FCB.
1186   DB1F 32 ED DB    	LD	(FCB+32),A
1187   DB22 11 5C 00    	LD	DE,TFCB		; MOVE IT INTO PLACE AT(005CH).
1188   DB25 21 CD DB    	LD	HL,FCB
1189   DB28 06 21       	LD	B,33
1190   DB2A CD 42 D8    	CALL	HL2DE
1191   DB2D 21 08 D4    	LD	HL,INBUFF+2	; NOW MOVE THE REMAINDER OF THE INPUT
1192   DB30 7E          UNKWN5:	LD	A,(HL)		; LINE DOWN TO (0080H). LOOK FOR A NON BLANK.
1193   DB31 B7          	OR	A		; OR A NULL.
1194   DB32 CA 3E DB    	JP	Z,UNKWN6
1195   DB35 FE 20       	CP	' '
1196   DB37 CA 3E DB    	JP	Z,UNKWN6
1197   DB3A 23          	INC	HL
1198   DB3B C3 30 DB    	JP	UNKWN5
1199   DB3E             ;
1200   DB3E             ;   DO THE LINE MOVE NOW. IT ENDS IN A NULL BYTE.
1201   DB3E             ;
1202   DB3E 06 00       UNKWN6:	LD	B,0		; KEEP A CHARACTER COUNT.
1203   DB40 11 81 00    	LD	DE,TBUFF+1	; DATA GETS PUT HERE.
1204   DB43 7E          UNKWN7:	LD	A,(HL)		; MOVE IT NOW.
1205   DB44 12          	LD	(DE),A
1206   DB45 B7          	OR	A
1207   DB46 CA 4F DB    	JP	Z,UNKWN8
1208   DB49 04          	INC	B
1209   DB4A 23          	INC	HL
1210   DB4B 13          	INC	DE
1211   DB4C C3 43 DB    	JP	UNKWN7
1212   DB4F 78          UNKWN8:	LD	A,B		; NOW STORE THE CHARACTER COUNT.
1213   DB50 32 80 00    	LD	(TBUFF),A
1214   DB53 CD 98 D4    	CALL	CRLF		; CLEAN UP THE SCREEN.
1215   DB56 CD D5 D5    	CALL	STDDMA		; SET STANDARD TRANSFER ADDRESS.
1216   DB59 CD 1A D5    	CALL	SETCDRV		; RESET CURRENT DRIVE.
1217   DB5C CD 00 01    	CALL	TBASE		; AND EXECUTE THE PROGRAM.
1218   DB5F             ;
1219   DB5F             ;   TRANSIANT PROGRAMS RETURN HERE (OR REBOOT).
1220   DB5F             ;
1221   DB5F 31 AB DB    	LD	SP,BATCH	; SET STACK FIRST OFF.
1222   DB62 CD 29 D5    	CALL	MOVECD		; MOVE CURRENT DRIVE INTO PLACE (TDRIVE).
1223   DB65 CD BD D4    	CALL	DSKSEL		; AND RESELECT IT.
1224   DB68 C3 82 D7    	JP	CMMND1		; BACK TO COMAND MODE.
1225   DB6B             ;
1226   DB6B             ;   GET HERE IF SOME ERROR OCCURED.
1227   DB6B             ;
1228   DB6B CD 66 D8    UNKWN9:	CALL	RESETDR		; INPROPER FORMAT.
1229   DB6E C3 09 D6    	JP	SYNERR
1230   DB71 01 7A DB    UNKWN0:	LD	BC,BADLOAD	; READ ERROR OR WON'T FIT.
1231   DB74 CD A7 D4    	CALL	PLINE
1232   DB77 C3 86 DB    	JP	GETBACK
1233   DB7A 42 41 44 20 BADLOAD:.DB "BAD LOAD",0
1233   DB7E 4C 4F 41 44 
1233   DB82 00 
1234   DB83 43 4F 4D    COMFILE:.DB "COM"		; COMMAND FILE EXTENSION.
1235   DB86             ;
1236   DB86             ;   GET HERE TO RETURN TO COMMAND LEVEL. WE WILL RESET THE
1237   DB86             ; PREVIOUS ACTIVE DRIVE AND THEN EITHER RETURN TO COMMAND
1238   DB86             ; LEVEL DIRECTLY OR PRINT ERROR MESSAGE AND THEN RETURN.
1239   DB86             ;
1240   DB86 CD 66 D8    GETBACK:CALL	RESETDR		; RESET PREVIOUS DRIVE.
1241   DB89             GETBACK1:
1242   DB89 CD 5E D6    	CALL	CONVFST		; CONVERT FIRST NAME IN (FCB).
1243   DB8C 3A CE DB    	LD	A,(FCB+1)	; IF THIS WAS JUST A DRIVE CHANGE REQUEST,
1244   DB8F D6 20       	SUB	' '		; MAKE SURE IT WAS VALID.
1245   DB91 21 F0 DB    	LD	HL,CHGDRV
1246   DB94 B6          	OR	(HL)
1247   DB95 C2 09 D6    	JP	NZ,SYNERR
1248   DB98 C3 82 D7    	JP	CMMND1		; OK, RETURN TO COMMAND LEVEL.
1249   DB9B             ;
1250   DB9B             ;   CCP STACK AREA.
1251   DB9B             ;
1252   DB9B 00 00 00 00 	.DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1252   DB9F 00 00 00 00 
1252   DBA3 00 00 00 00 
1252   DBA7 00 00 00 00 
1253   DBAB             CCPSTACK:	.EQU	$	;END OF CCP STACK AREA.
1254   DBAB             
1255   DBAB             ;
1256   DBAB             ;   BATCH (OR SUBMIT) PROCESSING INFORMATION STORAGE.
1257   DBAB             ;
1258   DBAB 00          BATCH:	.DB 0			; BATCH MODE FLAG (0=NOT ACTIVE).
1259   DBAC             ; BATCHFCB:DB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1260   DBAC             BATCHFCB:
1261   DBAC 00 24 24 24 	.DB 0,"$$$     SUB"
1261   DBB0 20 20 20 20 
1261   DBB4 20 53 55 42 
1262   DBB8 00 00 00 00 	.DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1262   DBBC 00 00 00 00 
1262   DBC0 00 00 00 00 
1262   DBC4 00 00 00 00 
1262   DBC8 00 00 00 00 
1262   DBCC 00 
1263   DBCD             ;
1264   DBCD             ;   FILE CONTROL BLOCK SETUP BY THE CCP.
1265   DBCD             ;
1266   DBCD             ;FCB	DB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
1267   DBCD 00 20 20 20 FCB:	.DB 0,"           ",0,0,0,0,0
1267   DBD1 20 20 20 20 
1267   DBD5 20 20 20 20 
1267   DBD9 00 00 00 00 
1267   DBDD 00 
1268   DBDE 20 20 20 20 	.DB "           ",0,0,0,0,0
1268   DBE2 20 20 20 20 
1268   DBE6 20 20 20 00 
1268   DBEA 00 00 00 00 
1269   DBEE 00          RTNCODE:.DB 0			; STATUS RETURNED FROM BDOS CALL.
1270   DBEF 00          CDRIVE:	.DB 0			; CURRENTLY ACTIVE DRIVE.
1271   DBF0 00          CHGDRV:	.DB 0			; CHANGE IN DRIVES FLAG (0=NO CHANGE).
1272   DBF1 00 00       NBYTES:	.DW 0			; BYTE COUNTER USED BY TYPE.
1273   DBF3             ;
1274   DBF3             ;   ROOM FOR EXPANSION?
1275   DBF3             ;
1276   DBF3 00 00 00 00 	.DB 0,0,0,0,0,0,0,0,0,0,0,0,0
1276   DBF7 00 00 00 00 
1276   DBFB 00 00 00 00 
1276   DBFF 00 
1277   DC00             ;
1278   DC00             ;   NOTE THAT THE FOLLOWING SIX BYTES MUST MATCH THOSE AT
1279   DC00             ; (PATTRN1) OR CP/M WILL HALT. WHY?
1280   DC00             ;
1281   DC00 00 16 00 00 PATTRN2:.DB 0,22,0,0,0,0	; (* SERIAL NUMBER BYTES *).
1281   DC04 00 00 
1282   DC06             ;
1283   DC06             ;**************************************************************
1284   DC06             ;*
1285   DC06             ;*                    B D O S   E N T R Y
1286   DC06             ;*
1287   DC06             ;**************************************************************
1288   DC06             ;
1289   DC06 C3 11 DC    FBASE:	JP	FBASE1
1290   DC09             ;
1291   DC09             ;   BDOS ERROR TABLE.
1292   DC09             ;
1293   DC09 99 DC       BADSCTR:.DW ERROR1		; BAD SECTOR ON READ OR WRITE.
1294   DC0B A5 DC       BADSLCT:.DW ERROR2		; BAD DISK SELECT.
1295   DC0D AB DC       RODISK:	.DW ERROR3		; DISK IS READ ONLY.
1296   DC0F B1 DC       ROFILE:	.DW ERROR4		; FILE IS READ ONLY.
1297   DC11             ;
1298   DC11             ;   ENTRY INTO BDOS. (DE) OR (E) ARE THE PARAMETERS PASSED. THE
1299   DC11             ; FUNCTION NUMBER DESIRED IS IN REGISTER (C).
1300   DC11             ; E contains drive number if passing this
1301   DC11 EB          FBASE1:	EX	DE,HL		; SAVE THE (DE) PARAMETERS.
1302   DC12 22 43 DF    	LD	(PARAMS),HL
1303   DC15 EB          	EX	DE,HL
1304   DC16 7B          	LD	A,E		; AND SAVE REGISTER (E) IN PARTICULAR.
1305   DC17 32 D6 E9    	LD	(EPARAM),A
1306   DC1A 21 00 00    	LD	HL,0
1307   DC1D 22 45 DF    	LD	(STATUS),HL	; CLEAR RETURN STATUS.
1308   DC20 39          	ADD	HL,SP
1309   DC21 22 0F DF    	LD	(USRSTACK),HL	; SAVE USERS STACK POINTER.
1310   DC24 31 41 DF    	LD	SP,STKAREA	; AND SET OUR OWN.
1311   DC27 AF          	XOR	A		; CLEAR AUTO SELECT STORAGE SPACE.
1312   DC28 32 E0 E9    	LD	(AUTOFLAG),A
1313   DC2B 32 DE E9    	LD	(AUTO),A
1314   DC2E 21 74 E9    	LD	HL,GOBACK	; SET RETURN ADDRESS.
1315   DC31 E5          	PUSH	HL
1316   DC32 79          	LD	A,C		; GET FUNCTION NUMBER.
1317   DC33 FE 29       	CP	NFUNCTS		; VALID FUNCTION NUMBER?
1318   DC35 D0          	RET	NC
1319   DC36 4B          	LD	C,E		; KEEP SINGLE REGISTER FUNCTION HERE.
1320   DC37 21 47 DC    	LD	HL,FUNCTNS	; NOW LOOK THRU THE FUNCTION TABLE.
1321   DC3A 5F          	LD	E,A
1322   DC3B 16 00       	LD	D,0		; (DE)=FUNCTION NUMBER.
1323   DC3D 19          	ADD	HL,DE
1324   DC3E 19          	ADD	HL,DE		; (HL)=(START OF TABLE)+2*(FUNCTION NUMBER).
1325   DC3F 5E          	LD	E,(HL)
1326   DC40 23          	INC	HL
1327   DC41 56          	LD	D,(HL)		; NOW (DE)=ADDRESS FOR THIS FUNCTION.
1328   DC42 2A 43 DF    	LD	HL,(PARAMS)	; RETRIEVE PARAMETERS.
1329   DC45 EB          	EX	DE,HL		; NOW (DE) HAS THE ORIGINAL PARAMETERS.
1330   DC46 E9          	JP	(HL)		; EXECUTE DESIRED FUNCTION.
1331   DC47             ;
1332   DC47             ;   BDOS FUNCTION JUMP TABLE.
1333   DC47             ;
1334   DC47             NFUNCTS:.EQU 41			; NUMBER OF FUNCTIONS IN FOLLOWIN TABLE.
1335   DC47             ;
1336   DC47 E9 EA C8 DE FUNCTNS:.DW WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
1336   DC4B 90 DD CE DE 
1336   DC4F 12 EA 0F EA 
1336   DC53 D4 DE ED DE 
1337   DC57 F3 DE F8 DE 	.DW SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
1337   DC5B E1 DD FE DE 
1337   DC5F 7E E8 83 E8 
1337   DC63 45 E8 9C E8 
1338   DC67 A5 E8 AB E8 	.DW CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
1338   DC6B C8 E8 D7 E8 
1338   DC6F E0 E8 E6 E8 
1338   DC73 EC E8 
1339   DC75 F5 E8 FE E8 	.DW RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
1339   DC79 04 E9 0A E9 
1339   DC7D 11 E9 2C E1 
1339   DC81 17 E9 1D E9 
1340   DC85 26 E9 2D E9 	.DW GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
1340   DC89 41 E9 47 E9 
1340   DC8D 4D E9 0E E8 
1340   DC91 53 E9 04 DF 
1341   DC95 04 DF 9B E9 	.DW RTN,WTSPECL
1342   DC99             ;
1343   DC99             ;   BDOS ERROR MESSAGE SECTION.
1344   DC99             ;
1345   DC99 21 CA DC    ERROR1:	LD	HL,BADSEC	; BAD SECTOR MESSAGE.
1346   DC9C CD E5 DC    	CALL	PRTERR		; PRINT IT AND GET A 1 CHAR RESPONCE.
1347   DC9F FE 03       	CP	CNTRLC		; RE-BOOT REQUEST (CONTROL-C)?
1348   DCA1 CA 00 00    	JP	Z,0		; YES.
1349   DCA4 C9          	RET			; NO, RETURN TO RETRY I/O FUNCTION.
1350   DCA5             ;
1351   DCA5 21 D5 DC    ERROR2:	LD	HL,BADSEL	; BAD DRIVE SELECTED.
1352   DCA8 C3 B4 DC    	JP	ERROR5
1353   DCAB             ;
1354   DCAB 21 E1 DC    ERROR3:	LD	HL,DISKRO	; DISK IS READ ONLY.
1355   DCAE C3 B4 DC    	JP	ERROR5
1356   DCB1             ;
1357   DCB1 21 DC DC    ERROR4:	LD	HL,FILERO	; FILE IS READ ONLY.
1358   DCB4             ;
1359   DCB4 CD E5 DC    ERROR5:	CALL	PRTERR
1360   DCB7 C3 00 00    	JP	0		; ALWAYS REBOOT ON THESE ERRORS.
1361   DCBA             ;
1362   DCBA 42 44 4F 53 BDOSERR:.DB "BDOS ERR ON "
1362   DCBE 20 45 52 52 
1362   DCC2 20 4F 4E 20 
1363   DCC6 20 3A 20 24 BDOSDRV:.DB " : $"
1364   DCCA 42 41 44 20 BADSEC:	.DB "BAD SECTOR$"
1364   DCCE 53 45 43 54 
1364   DCD2 4F 52 24 
1365   DCD5 53 45 4C 45 BADSEL:	.DB "SELECT$"
1365   DCD9 43 54 24 
1366   DCDC 46 49 4C 45 FILERO:	.DB "FILE "
1366   DCE0 20 
1367   DCE1 52 2F 4F 24 DISKRO:	.DB "R/O$"
1368   DCE5             ;
1369   DCE5             ;   PRINT BDOS ERROR MESSAGE.
1370   DCE5             ;
1371   DCE5 E5          PRTERR:	PUSH	HL		; SAVE SECOND MESSAGE POINTER.
1372   DCE6 CD C9 DD    	CALL	OUTCRLF		; SEND (CR)(LF).
1373   DCE9 3A 42 DF    	LD	A,(ACTIVE)	; GET ACTIVE DRIVE.
1374   DCEC C6 41       	ADD	A,'A'		; MAKE ASCII.
1375   DCEE 32 C6 DC    	LD	(BDOSDRV),A	; AND PUT IN MESSAGE.
1376   DCF1 01 BA DC    	LD	BC,BDOSERR	; AND PRINT IT.
1377   DCF4 CD D3 DD    	CALL	PRTMESG
1378   DCF7 C1          	POP	BC		; PRINT SECOND MESSAGE LINE NOW.
1379   DCF8 CD D3 DD    	CALL	PRTMESG
1380   DCFB             ;
1381   DCFB             ;   GET AN INPUT CHARACTER. WE WILL CHECK OUR 1 CHARACTER
1382   DCFB             ; BUFFER FIRST. THIS MAY BE SET BY THE CONSOLE STATUS ROUTINE.
1383   DCFB             ;
1384   DCFB 21 0E DF    GETCHAR:LD	HL,CHARBUF	; CHECK CHARACTER BUFFER.
1385   DCFE 7E          	LD	A,(HL)		; ANYTHING PRESENT ALREADY?
1386   DCFF 36 00       	LD	(HL),0		; ...EITHER CASE CLEAR IT.
1387   DD01 B7          	OR	A
1388   DD02 C0          	RET	NZ		; YES, USE IT.
1389   DD03 C3 55 EB    	JP	CONIN		; NOPE, GO GET A CHARACTER RESPONCE.
1390   DD06             ;
1391   DD06             ;   INPUT AND ECHO A CHARACTER.
1392   DD06             ;
1393   DD06 CD FB DC    GETECHO:CALL	GETCHAR		; INPUT A CHARACTER.
1394   DD09 CD 14 DD    	CALL	CHKCHAR		; CARRIAGE CONTROL?
1395   DD0C D8          	RET	C		; NO, A REGULAR CONTROL CHAR SO DON'T ECHO.
1396   DD0D F5          	PUSH	AF		; OK, SAVE CHARACTER NOW.
1397   DD0E 4F          	LD	C,A
1398   DD0F CD 90 DD    	CALL	OUTCON		; AND ECHO IT.
1399   DD12 F1          	POP	AF		; GET CHARACTER AND RETURN.
1400   DD13 C9          	RET
1401   DD14             ;
1402   DD14             ;   CHECK CHARACTER IN (A). SET THE ZERO FLAG ON A CARRIAGE
1403   DD14             ; CONTROL CHARACTER AND THE CARRY FLAG ON ANY OTHER CONTROL
1404   DD14             ; CHARACTER.
1405   DD14             ;
1406   DD14 FE 0D       CHKCHAR:CP	CR		; CHECK FOR CARRIAGE RETURN, LINE FEED, BACKSPACE,
1407   DD16 C8          	RET	Z		; OR A TAB.
1408   DD17 FE 0A       	CP	LF
1409   DD19 C8          	RET	Z
1410   DD1A FE 09       	CP	TAB
1411   DD1C C8          	RET	Z
1412   DD1D FE 08       	CP	BS
1413   DD1F C8          	RET	Z
1414   DD20 FE 20       	CP	' '		; OTHER CONTROL CHAR? SET CARRY FLAG.
1415   DD22 C9          	RET
1416   DD23             ;
1417   DD23             ;   CHECK THE CONSOLE DURING OUTPUT. HALT ON A CONTROL-S, THEN
1418   DD23             ; REBOOT ON A CONTROL-C. IF ANYTHING ELSE IS READY, CLEAR THE
1419   DD23             ; ZERO FLAG AND RETURN (THE CALLING ROUTINE MAY WANT TO DO
1420   DD23             ; SOMETHING).
1421   DD23             ;
1422   DD23             CKCONSOL:
1423   DD23 3A 0E DF    	LD	A,(CHARBUF)	; CHECK BUFFER.
1424   DD26 B7          	OR	A		; IF ANYTHING, JUST RETURN WITHOUT CHECKING.
1425   DD27 C2 45 DD    	JP	NZ,CKCON2
1426   DD2A CD 4B EB    	CALL	CONST		; NOTHING IN BUFFER. CHECK CONSOLE.
1427   DD2D E6 01       	AND	01H		; LOOK AT BIT 0.
1428   DD2F C8          	RET	Z		; RETURN IF NOTHING.
1429   DD30 CD 55 EB    	CALL	CONIN		; OK, GET IT.
1430   DD33 FE 13       	CP	CNTRLS		; IF NOT CONTROL-S, RETURN WITH ZERO CLEARED.
1431   DD35 C2 42 DD    	JP	NZ,CKCON1
1432   DD38 CD 55 EB    	CALL	CONIN		; HALT PROCESSING UNTIL ANOTHER CHAR
1433   DD3B FE 03       	CP	CNTRLC		; IS TYPED. CONTROL-C?
1434   DD3D CA 00 00    	JP	Z,0		; YES, REBOOT NOW.
1435   DD40 AF          	XOR	A		; NO, JUST PRETEND NOTHING WAS EVER READY.
1436   DD41 C9          	RET
1437   DD42 32 0E DF    CKCON1:	LD	(CHARBUF),A	; SAVE CHARACTER IN BUFFER FOR LATER PROCESSING.
1438   DD45 3E 01       CKCON2:	LD	A,1		; SET (A) TO NON ZERO TO MEAN SOMETHING IS READY.
1439   DD47 C9          	RET
1440   DD48             ;
1441   DD48             ;   OUTPUT (C) TO THE SCREEN. IF THE PRINTER FLIP-FLOP FLAG
1442   DD48             ; IS SET, WE WILL SEND CHARACTER TO PRINTER ALSO. THE CONSOLE
1443   DD48             ; WILL BE CHECKED IN THE PROCESS.
1444   DD48             ;
1445   DD48 3A 0A DF    OUTCHAR:LD	A,(OUTFLAG)	; CHECK OUTPUT FLAG.
1446   DD4B B7          	OR	A		; ANYTHING AND WE WON'T GENERATE OUTPUT.
1447   DD4C C2 62 DD    	JP	NZ,OUTCHR1
1448   DD4F C5          	PUSH	BC
1449   DD50 CD 23 DD    	CALL	CKCONSOL	; CHECK CONSOLE (WE DON'T CARE WHATS THERE).
1450   DD53 C1          	POP	BC
1451   DD54 C5          	PUSH	BC
1452   DD55 CD 60 EB    	CALL	CONOUT		; OUTPUT (C) TO THE SCREEN.
1453   DD58 C1          	POP	BC
1454   DD59 C5          	PUSH	BC
1455   DD5A 3A 0D DF    	LD	A,(PRTFLAG)	; CHECK PRINTER FLIP-FLOP FLAG.
1456   DD5D B7          	OR	A
1457   DD5E C4 0F EA    	CALL	NZ,LIST		; PRINT IT ALSO IF NON-ZERO.
1458   DD61 C1          	POP	BC
1459   DD62 79          OUTCHR1:LD	A,C		; UPDATE CURSORS POSITION.
1460   DD63 21 0C DF    	LD	HL,CURPOS
1461   DD66 FE 7F       	CP	DEL		; RUBOUTS DON'T DO ANYTHING HERE.
1462   DD68 C8          	RET	Z
1463   DD69 34          	INC	(HL)		; BUMP LINE POINTER.
1464   DD6A FE 20       	CP	' '		; AND RETURN IF A NORMAL CHARACTER.
1465   DD6C D0          	RET	NC
1466   DD6D 35          	DEC	(HL)		; RESTORE AND CHECK FOR THE START OF THE LINE.
1467   DD6E 7E          	LD	A,(HL)
1468   DD6F B7          	OR	A
1469   DD70 C8          	RET	Z		; INGNORE CONTROL CHARACTERS AT THE START OF THE LINE.
1470   DD71 79          	LD	A,C
1471   DD72 FE 08       	CP	BS		; IS IT A BACKSPACE?
1472   DD74 C2 79 DD    	JP	NZ,OUTCHR2
1473   DD77 35          	DEC	(HL)		; YES, BACKUP POINTER.
1474   DD78 C9          	RET
1475   DD79 FE 0A       OUTCHR2:CP	LF		; IS IT A LINE FEED?
1476   DD7B C0          	RET	NZ		; IGNORE ANYTHING ELSE.
1477   DD7C 36 00       	LD	(HL),0		; RESET POINTER TO START OF LINE.
1478   DD7E C9          	RET
1479   DD7F             ;
1480   DD7F             ;   OUTPUT (A) TO THE SCREEN. IF IT IS A CONTROL CHARACTER
1481   DD7F             ; (OTHER THAN CARRIAGE CONTROL), USE ^X FORMAT.
1482   DD7F             ;
1483   DD7F 79          SHOWIT:	LD	A,C
1484   DD80 CD 14 DD    	CALL	CHKCHAR		; CHECK CHARACTER.
1485   DD83 D2 90 DD    	JP	NC,OUTCON	; NOT A CONTROL, USE NORMAL OUTPUT.
1486   DD86 F5          	PUSH	AF
1487   DD87 0E 5E       	LD	C,'^'		; FOR A CONTROL CHARACTER, PRECEED IT WITH '^'.
1488   DD89 CD 48 DD    	CALL	OUTCHAR
1489   DD8C F1          	POP	AF
1490   DD8D F6 40       	OR	'@'		; AND THEN USE THE LETTER EQUIVELANT.
1491   DD8F 4F          	LD	C,A
1492   DD90             ;
1493   DD90             ;   FUNCTION TO OUTPUT (C) TO THE CONSOLE DEVICE AND EXPAND TABS
1494   DD90             ; IF NECESSARY.
1495   DD90             ;
1496   DD90 79          OUTCON:	LD	A,C
1497   DD91 FE 09       	CP	TAB		; IS IT A TAB?
1498   DD93 C2 48 DD    	JP	NZ,OUTCHAR	; USE REGULAR OUTPUT.
1499   DD96 0E 20       OUTCON1:LD	C,' '		; YES IT IS, USE SPACES INSTEAD.
1500   DD98 CD 48 DD    	CALL	OUTCHAR
1501   DD9B 3A 0C DF    	LD	A,(CURPOS)	; GO UNTIL THE CURSOR IS AT A MULTIPLE OF 8
1502   DD9E             
1503   DD9E E6 07       	AND	07H		; POSITION.
1504   DDA0 C2 96 DD    	JP	NZ,OUTCON1
1505   DDA3 C9          	RET
1506   DDA4             ;
1507   DDA4             ;   ECHO A BACKSPACE CHARACTER. ERASE THE PREVOIUS CHARACTER
1508   DDA4             ; ON THE SCREEN.
1509   DDA4             ;
1510   DDA4 CD AC DD    BACKUP:	CALL	BACKUP1		; BACKUP THE SCREEN 1 PLACE.
1511   DDA7 0E 20       	LD	C,' '		; THEN BLANK THAT CHARACTER.
1512   DDA9 CD 60 EB    	CALL	CONOUT
1513   DDAC 0E 08       BACKUP1:LD	C,BS		; THEN BACK SPACE ONCE MORE.
1514   DDAE C3 60 EB    	JP	CONOUT
1515   DDB1             ;
1516   DDB1             ;   SIGNAL A DELETED LINE. PRINT A '#' AT THE END AND START
1517   DDB1             ; OVER.
1518   DDB1             ;
1519   DDB1 0E 23       NEWLINE:LD	C,'#'
1520   DDB3 CD 48 DD    	CALL	OUTCHAR		; PRINT THIS.
1521   DDB6 CD C9 DD    	CALL	OUTCRLF		; START NEW LINE.
1522   DDB9 3A 0C DF    NEWLN1:	LD	A,(CURPOS)	; MOVE THE CURSOR TO THE STARTING POSITION.
1523   DDBC 21 0B DF    	LD	HL,STARTING
1524   DDBF BE          	CP	(HL)
1525   DDC0 D0          	RET	NC		; THERE YET?
1526   DDC1 0E 20       	LD	C,' '
1527   DDC3 CD 48 DD    	CALL	OUTCHAR		; NOPE, KEEP GOING.
1528   DDC6 C3 B9 DD    	JP	NEWLN1
1529   DDC9             ;
1530   DDC9             ;   OUTPUT A (CR) (LF) TO THE CONSOLE DEVICE (SCREEN).
1531   DDC9             ;
1532   DDC9 0E 0D       OUTCRLF:LD	C,CR
1533   DDCB CD 48 DD    	CALL	OUTCHAR
1534   DDCE 0E 0A       	LD	C,LF
1535   DDD0 C3 48 DD    	JP	OUTCHAR
1536   DDD3             ;
1537   DDD3             ;   PRINT MESSAGE POINTED TO BY (BC). IT WILL END WITH A '$'.
1538   DDD3             ;
1539   DDD3 0A          PRTMESG:LD	A,(BC)		; CHECK FOR TERMINATING CHARACTER.
1540   DDD4 FE 24       	CP	'$'
1541   DDD6 C8          	RET	Z
1542   DDD7 03          	INC	BC
1543   DDD8 C5          	PUSH	BC		; OTHERWISE, BUMP POINTER AND PRINT IT.
1544   DDD9 4F          	LD	C,A
1545   DDDA CD 90 DD    	CALL	OUTCON
1546   DDDD C1          	POP	BC
1547   DDDE C3 D3 DD    	JP	PRTMESG
1548   DDE1             ;
1549   DDE1             ;   FUNCTION TO EXECUTE A BUFFERED READ.
1550   DDE1             ;
1551   DDE1 3A 0C DF    RDBUFF:	LD	A,(CURPOS)	; USE PRESENT LOCATION AS STARTING ONE.
1552   DDE4 32 0B DF    	LD	(STARTING),A
1553   DDE7 2A 43 DF    	LD	HL,(PARAMS)	; GET THE MAXIMUM BUFFER SPACE.
1554   DDEA 4E          	LD	C,(HL)
1555   DDEB 23          	INC	HL		; POINT TO FIRST AVAILABLE SPACE.
1556   DDEC E5          	PUSH	HL		; AND SAVE.
1557   DDED 06 00       	LD	B,0		; KEEP A CHARACTER COUNT.
1558   DDEF C5          RDBUF1:	PUSH	BC
1559   DDF0 E5          	PUSH	HL
1560   DDF1 CD FB DC    RDBUF2:	CALL	GETCHAR		; GET THE NEXT INPUT CHARACTER.
1561   DDF4 E6 7F       	AND	7FH		; STRIP BIT 7.
1562   DDF6 E1          	POP	HL		; RESET REGISTERS.
1563   DDF7 C1          	POP	BC
1564   DDF8 FE 0D       	CP	CR		; EN OF THE LINE?
1565   DDFA CA C1 DE    	JP	Z,RDBUF17
1566   DDFD FE 0A       	CP	LF
1567   DDFF CA C1 DE    	JP	Z,RDBUF17
1568   DE02 FE 08       	CP	BS		; HOW ABOUT A BACKSPACE?
1569   DE04 C2 16 DE    	JP	NZ,RDBUF3
1570   DE07 78          	LD	A,B		; YES, BUT IGNORE AT THE BEGINNING OF THE LINE.
1571   DE08 B7          	OR	A
1572   DE09 CA EF DD    	JP	Z,RDBUF1
1573   DE0C 05          	DEC	B		; OK, UPDATE COUNTER.
1574   DE0D 3A 0C DF    	LD	A,(CURPOS)	; IF WE BACKSPACE TO THE START OF THE LINE,
1575   DE10 32 0A DF    	LD	(OUTFLAG),A	; TREAT AS A CANCEL (CONTROL-X).
1576   DE13 C3 70 DE    	JP	RDBUF10
1577   DE16 FE 7F       RDBUF3:	CP	DEL		; USER TYPED A RUBOUT?
1578   DE18 C2 26 DE    	JP	NZ,RDBUF4
1579   DE1B 78          	LD	A,B		; IGNORE AT THE START OF THE LINE.
1580   DE1C B7          	OR	A
1581   DE1D CA EF DD    	JP	Z,RDBUF1
1582   DE20 7E          	LD	A,(HL)		; OK, ECHO THE PREVOIUS CHARACTER.
1583   DE21 05          	DEC	B		; AND RESET POINTERS (COUNTERS).
1584   DE22 2B          	DEC	HL
1585   DE23 C3 A9 DE    	JP	RDBUF15
1586   DE26 FE 05       RDBUF4:	CP	CNTRLE		; PHYSICAL END OF LINE?
1587   DE28 C2 37 DE    	JP	NZ,RDBUF5
1588   DE2B C5          	PUSH	BC		; YES, DO IT.
1589   DE2C E5          	PUSH	HL
1590   DE2D CD C9 DD    	CALL	OUTCRLF
1591   DE30 AF          	XOR	A		; AND UPDATE STARTING POSITION.
1592   DE31 32 0B DF    	LD	(STARTING),A
1593   DE34 C3 F1 DD    	JP	RDBUF2
1594   DE37 FE 10       RDBUF5:	CP	CNTRLP		; CONTROL-P?
1595   DE39 C2 48 DE    	JP	NZ,RDBUF6
1596   DE3C E5          	PUSH	HL		; YES, FLIP THE PRINT FLAG FILP-FLOP BYTE.
1597   DE3D 21 0D DF    	LD	HL,PRTFLAG
1598   DE40 3E 01       	LD	A,1		; PRTFLAG=1-PRTFLAG
1599   DE42 96          	SUB	(HL)
1600   DE43 77          	LD	(HL),A
1601   DE44 E1          	POP	HL
1602   DE45 C3 EF DD    	JP	RDBUF1
1603   DE48 FE 18       RDBUF6:	CP	CNTRLX		; CONTROL-X (CANCEL)?
1604   DE4A C2 5F DE    	JP	NZ,RDBUF8
1605   DE4D E1          	POP	HL
1606   DE4E 3A 0B DF    RDBUF7:	LD	A,(STARTING)	; YES, BACKUP THE CURSOR TO HERE.
1607   DE51 21 0C DF    	LD	HL,CURPOS
1608   DE54 BE          	CP	(HL)
1609   DE55 D2 E1 DD    	JP	NC,RDBUFF	; DONE YET?
1610   DE58 35          	DEC	(HL)		; NO, DECREMENT POINTER AND OUTPUT BACK UP ONE SPACE.
1611   DE59 CD A4 DD    	CALL	BACKUP
1612   DE5C C3 4E DE    	JP	RDBUF7
1613   DE5F FE 15       RDBUF8:	CP	CNTRLU		; CNTROL-U (CANCEL LINE)?
1614   DE61 C2 6B DE    	JP	NZ,RDBUF9
1615   DE64 CD B1 DD    	CALL	NEWLINE		; START A NEW LINE.
1616   DE67 E1          	POP	HL
1617   DE68 C3 E1 DD    	JP	RDBUFF
1618   DE6B FE 12       RDBUF9:	CP	CNTRLR		; CONTROL-R?
1619   DE6D C2 A6 DE    	JP	NZ,RDBUF14
1620   DE70 C5          RDBUF10:PUSH	BC		; YES, START A NEW LINE AND RETYPE THE OLD ONE.
1621   DE71 CD B1 DD    	CALL	NEWLINE
1622   DE74 C1          	POP	BC
1623   DE75 E1          	POP	HL
1624   DE76 E5          	PUSH	HL
1625   DE77 C5          	PUSH	BC
1626   DE78 78          RDBUF11:LD	A,B		; DONE WHOLE LINE YET?
1627   DE79 B7          	OR	A
1628   DE7A CA 8A DE    	JP	Z,RDBUF12
1629   DE7D 23          	INC	HL		; NOPE, GET NEXT CHARACTER.
1630   DE7E 4E          	LD	C,(HL)
1631   DE7F 05          	DEC	B		; COUNT IT.
1632   DE80 C5          	PUSH	BC
1633   DE81 E5          	PUSH	HL
1634   DE82 CD 7F DD    	CALL	SHOWIT		; AND DISPLAY IT.
1635   DE85 E1          	POP	HL
1636   DE86 C1          	POP	BC
1637   DE87 C3 78 DE    	JP	RDBUF11
1638   DE8A E5          RDBUF12:PUSH	HL		; DONE WITH LINE. IF WE WERE DISPLAYING
1639   DE8B 3A 0A DF    	LD	A,(OUTFLAG)	; THEN UPDATE CURSOR POSITION.
1640   DE8E B7          	OR	A
1641   DE8F CA F1 DD    	JP	Z,RDBUF2
1642   DE92 21 0C DF    	LD	HL,CURPOS	; BECAUSE THIS LINE IS SHORTER, WE MUST
1643   DE95 96          	SUB	(HL)		; BACK UP THE CURSOR (NOT THE SCREEN HOWEVER)
1644   DE96 32 0A DF    	LD	(OUTFLAG),A	; SOME NUMBER OF POSITIONS.
1645   DE99 CD A4 DD    RDBUF13:CALL	BACKUP		; NOTE THAT AS LONG AS (OUTFLAG) IS NON
1646   DE9C 21 0A DF    	LD	HL,OUTFLAG	; ZERO, THE SCREEN WILL NOT BE CHANGED.
1647   DE9F 35          	DEC	(HL)
1648   DEA0 C2 99 DE    	JP	NZ,RDBUF13
1649   DEA3 C3 F1 DD    	JP	RDBUF2		; NOW JUST GET THE NEXT CHARACTER.
1650   DEA6             ;
1651   DEA6             ;   JUST A NORMAL CHARACTER, PUT THIS IN OUR BUFFER AND ECHO.
1652   DEA6             ;
1653   DEA6 23          RDBUF14:INC	HL
1654   DEA7 77          	LD	(HL),A		; STORE CHARACTER.
1655   DEA8 04          	INC	B		; AND COUNT IT.
1656   DEA9 C5          RDBUF15:PUSH	BC
1657   DEAA E5          	PUSH	HL
1658   DEAB 4F          	LD	C,A		; ECHO IT NOW.
1659   DEAC CD 7F DD    	CALL	SHOWIT
1660   DEAF E1          	POP	HL
1661   DEB0 C1          	POP	BC
1662   DEB1 7E          	LD	A,(HL)		; WAS IT AN ABORT REQUEST?
1663   DEB2 FE 03       	CP	CNTRLC		; CONTROL-C ABORT?
1664   DEB4 78          	LD	A,B
1665   DEB5 C2 BD DE    	JP	NZ,RDBUF16
1666   DEB8 FE 01       	CP	1		; ONLY IF AT START OF LINE.
1667   DEBA CA 00 00    	JP	Z,0
1668   DEBD B9          RDBUF16:CP	C		; NOPE, HAVE WE FILLED THE BUFFER?
1669   DEBE DA EF DD    	JP	C,RDBUF1
1670   DEC1 E1          RDBUF17:POP	HL		; YES END THE LINE AND RETURN.
1671   DEC2 70          	LD	(HL),B
1672   DEC3 0E 0D       	LD	C,CR
1673   DEC5 C3 48 DD    	JP	OUTCHAR		; OUTPUT (CR) AND RETURN.
1674   DEC8             ;
1675   DEC8             ;   FUNCTION TO GET A CHARACTER FROM THE CONSOLE DEVICE.
1676   DEC8             ;
1677   DEC8 CD 06 DD    GETCON:	CALL	GETECHO		; GET AND ECHO.
1678   DECB C3 01 DF    	JP	SETSTAT		; SAVE STATUS AND RETURN.
1679   DECE             ;
1680   DECE             ;   FUNCTION TO GET A CHARACTER FROM THE TAPE READER DEVICE.
1681   DECE             ;
1682   DECE CD 15 EA    GETRDR:	CALL	READER		; GET A CHARACTER FROM READER, SET STATUS AND RETURN.
1683   DED1 C3 01 DF    	JP	SETSTAT
1684   DED4             ;
1685   DED4             ;  FUNCTION TO PERFORM DIRECT CONSOLE I/O. IF (C) CONTAINS (FF)
1686   DED4             ; THEN THIS IS AN INPUT REQUEST. IF (C) CONTAINS (FE) THEN
1687   DED4             ; THIS IS A STATUS REQUEST. OTHERWISE WE ARE TO OUTPUT (C).
1688   DED4             ;
1689   DED4 79          DIRCIO:	LD	A,C		; TEST FOR (FF).
1690   DED5 3C          	INC	A
1691   DED6 CA E0 DE    	JP	Z,DIRC1
1692   DED9 3C          	INC	A		; TEST FOR (FE).
1693   DEDA CA 4B EB    	JP	Z,CONST
1694   DEDD C3 60 EB    	JP	CONOUT		; JUST OUTPUT (C).
1695   DEE0 CD 4B EB    DIRC1:	CALL	CONST		; THIS IS AN INPUT REQUEST.
1696   DEE3 B7          	OR	A
1697   DEE4 CA 91 E9    	JP	Z,GOBACK1	; NOT READY? JUST RETURN (DIRECTLY).
1698   DEE7 CD 55 EB    	CALL	CONIN		; YES, GET CHARACTER.
1699   DEEA C3 01 DF    	JP	SETSTAT		; SET STATUS AND RETURN.
1700   DEED             ;
1701   DEED             ;   FUNCTION TO RETURN THE I/O BYTE.
1702   DEED             ;
1703   DEED 3A 03 00    GETIOB:	LD	A,(IOBYTE)
1704   DEF0 C3 01 DF    	JP	SETSTAT
1705   DEF3             ;
1706   DEF3             ;   FUNCTION TO SET THE I/O BYTE.
1707   DEF3             ;
1708   DEF3 21 03 00    SETIOB:	LD	HL,IOBYTE
1709   DEF6 71          	LD	(HL),C
1710   DEF7 C9          	RET
1711   DEF8             ;
1712   DEF8             ;   FUNCTION TO PRINT THE CHARACTER STRING POINTED TO BY (DE)
1713   DEF8             ; ON THE CONSOLE DEVICE. THE STRING ENDS WITH A '$'.
1714   DEF8             ;
1715   DEF8 EB          PRTSTR:	EX	DE,HL
1716   DEF9 4D          	LD	C,L
1717   DEFA 44          	LD	B,H		; NOW (BC) POINTS TO IT.
1718   DEFB C3 D3 DD    	JP	PRTMESG
1719   DEFE             ;
1720   DEFE             ;   FUNCTION TO INTERIGATE THE CONSOLE DEVICE.
1721   DEFE             ;
1722   DEFE CD 23 DD    GETCSTS:CALL	CKCONSOL
1723   DF01             ;
1724   DF01             ;   GET HERE TO SET THE STATUS AND RETURN TO THE CLEANUP
1725   DF01             ; SECTION. THEN BACK TO THE USER.
1726   DF01             ;
1727   DF01 32 45 DF    SETSTAT:LD	(STATUS),A
1728   DF04 C9          RTN:	RET
1729   DF05             ;
1730   DF05             ;   SET THE STATUS TO 1 (READ OR WRITE ERROR CODE).
1731   DF05             ;
1732   DF05 3E 01       IOERR1:	LD	A,1
1733   DF07 C3 01 DF    	JP	SETSTAT
1734   DF0A             ;
1735   DF0A 00          OUTFLAG:.DB 0			; OUTPUT FLAG (NON ZERO MEANS NO OUTPUT).
1736   DF0B             STARTING:
1737   DF0B 02          	.DB 2			; STARTING POSITION FOR CURSOR.
1738   DF0C 00          CURPOS:	.DB 0			; CURSOR POSITION (0=START OF LINE).
1739   DF0D 00          PRTFLAG:.DB 0			; PRINTER FLAG (CONTROL-P TOGGLE). LIST IF NON ZERO.
1740   DF0E 00          CHARBUF:.DB 0			; SINGLE INPUT CHARACTER BUFFER.
1741   DF0F             ;
1742   DF0F             ;   STACK AREA FOR BDOS CALLS.
1743   DF0F             ;
1744   DF0F             USRSTACK:
1745   DF0F 00 00       	.DW 0			; SAVE USERS STACK POINTER HERE.
1746   DF11             ;
1747   DF11 00 00 00 00 	.DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1747   DF15 00 00 00 00 
1747   DF19 00 00 00 00 
1747   DF1D 00 00 00 00 
1747   DF21 00 00 00 00 
1747   DF25 00 00 00 00 
1748   DF29 00 00 00 00 	.DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1748   DF2D 00 00 00 00 
1748   DF31 00 00 00 00 
1748   DF35 00 00 00 00 
1748   DF39 00 00 00 00 
1748   DF3D 00 00 00 00 
1749   DF41             STKAREA:.EQU $			; END OF STACK AREA.
1750   DF41             ;
1751   DF41 00          USERNO:	.DB 0			; CURRENT USER NUMBER.
1752   DF42 00          ACTIVE:	.DB 0			; CURRENTLY ACTIVE DRIVE.
1753   DF43 00 00       PARAMS:	.DW 0			; SAVE (DE) PARAMETERS HERE ON ENTRY.
1754   DF45 00 00       STATUS:	.DW 0			; STATUS RETURNED FROM BDOS FUNCTION.
1755   DF47             ;
1756   DF47             ;   SELECT ERROR OCCURED, JUMP TO ERROR ROUTINE.
1757   DF47             ;
1758   DF47 21 0B DC    SLCTERR:LD	HL,BADSLCT
1759   DF4A             ;
1760   DF4A             ;   JUMP TO (HL) INDIRECTLY.
1761   DF4A             ;
1762   DF4A 5E          JUMPHL:	LD	E,(HL)
1763   DF4B 23          	INC	HL
1764   DF4C 56          	LD	D,(HL)		; NOW (DE) CONTAIN THE DESIRED ADDRESS.
1765   DF4D EB          	EX	DE,HL
1766   DF4E E9          	JP	(HL)
1767   DF4F             ;
1768   DF4F             ;   BLOCK MOVE. (DE) TO (HL), (C) BYTES TOTAL.
1769   DF4F             ;
1770   DF4F 0C          DE2HL:	INC	C		; IS COUNT DOWN TO ZERO?
1771   DF50 0D          DE2HL1:	DEC	C
1772   DF51 C8          	RET	Z		; YES, WE ARE DONE.
1773   DF52 1A          	LD	A,(DE)		; NO, MOVE ONE MORE BYTE.
1774   DF53 77          	LD	(HL),A
1775   DF54 13          	INC	DE
1776   DF55 23          	INC	HL
1777   DF56 C3 50 DF    	JP	DE2HL1		; AND REPEAT.
1778   DF59             ;
1779   DF59             ;   SELECT THE DESIRED DRIVE.
1780   DF59             ;
1781   DF59 3A 42 DF    SELECT:	LD	A,(ACTIVE)	; GET ACTIVE DISK.
1782   DF5C 4F          	LD	C,A
1783   DF5D CD 6E EB    	CALL	SELDSK		; SELECT IT.
1784   DF60 7C          	LD	A,H		; VALID DRIVE?
1785   DF61 B5          	OR	L		; VALID DRIVE?
1786   DF62 C8          	RET	Z		; RETURN IF NOT.
1787   DF63             ;
1788   DF63             ;   HERE, THE BIOS RETURNED THE ADDRESS OF THE PARAMETER BLOCK
1789   DF63             ; IN (HL). WE WILL EXTRACT THE NECESSARY POINTERS AND SAVE THEM.
1790   DF63             ;
1791   DF63 5E          	LD	E,(HL)		; YES, GET ADDRESS OF TRANSLATION TABLE INTO (DE).
1792   DF64 23          	INC	HL
1793   DF65 56          	LD	D,(HL)
1794   DF66 23          	INC	HL
1795   DF67 22 B3 E9    	LD	(SCRATCH1),HL	; SAVE POINTERS TO SCRATCH AREAS.
1796   DF6A 23          	INC	HL
1797   DF6B 23          	INC	HL
1798   DF6C 22 B5 E9    	LD	(SCRATCH2),HL	; DITTO.
1799   DF6F 23          	INC	HL
1800   DF70 23          	INC	HL
1801   DF71 22 B7 E9    	LD	(SCRATCH3),HL	; DITTO.
1802   DF74 23          	INC	HL
1803   DF75 23          	INC	HL
1804   DF76 EB          	EX	DE,HL		; NOW SAVE THE TRANSLATION TABLE ADDRESS.
1805   DF77 22 D0 E9    	LD	(XLATE),HL
1806   DF7A 21 B9 E9    	LD	HL,DIRBUF	; PUT THE NEXT 8 BYTES HERE.
1807   DF7D 0E 08       	LD	C,8		; THEY CONSIST OF THE DIRECTORY BUFFER
1808   DF7F CD 4F DF    	CALL	DE2HL		; POINTER, PARAMETER BLOCK POINTER,
1809   DF82 2A BB E9    	LD	HL,(DISKPB)	; CHECK AND ALLOCATION VECTORS.
1810   DF85 EB          	EX	DE,HL
1811   DF86 21 C1 E9    	LD	HL,SECTORS	; MOVE PARAMETER BLOCK INTO OUR RAM.
1812   DF89 0E 0F       	LD	C,15		; IT IS 15 BYTES LONG.
1813   DF8B CD 4F DF    	CALL	DE2HL
1814   DF8E 2A C6 E9    	LD	HL,(DSKSIZE)	; CHECK DISK SIZE.
1815   DF91 7C          	LD	A,H		; MORE THAN 256 BLOCKS ON THIS?
1816   DF92 21 DD E9    	LD	HL,BIGDISK
1817   DF95 36 FF       	LD	(HL),0FFH	; SET TO SAMLL.
1818   DF97 B7          	OR	A
1819   DF98 CA 9D DF    	JP	Z,SELECT1
1820   DF9B 36 00       	LD	(HL),0		; WRONG, SET TO LARGE.
1821   DF9D 3E FF       SELECT1:LD	A,0FFH		; CLEAR THE ZERO FLAG.
1822   DF9F B7          	OR	A
1823   DFA0 C9          	RET
1824   DFA1             ;
1825   DFA1             ;   ROUTINE TO HOME THE DISK TRACK HEAD AND CLEAR POINTERS.
1826   DFA1             ;
1827   DFA1 CD 87 EB    HOMEDRV:CALL	HOME		; HOME THE HEAD.
1828   DFA4 AF          	XOR	A
1829   DFA5 2A B5 E9    	LD	HL,(SCRATCH2)	; SET OUR TRACK POINTER ALSO.
1830   DFA8 77          	LD	(HL),A
1831   DFA9 23          	INC	HL
1832   DFAA 77          	LD	(HL),A
1833   DFAB 2A B7 E9    	LD	HL,(SCRATCH3)	; AND OUR SECTOR POINTER.
1834   DFAE 77          	LD	(HL),A
1835   DFAF 23          	INC	HL
1836   DFB0 77          	LD	(HL),A
1837   DFB1 C9          	RET
1838   DFB2             ;
1839   DFB2             ;   DO THE ACTUAL DISK READ AND CHECK THE ERROR RETURN STATUS.
1840   DFB2             ;
1841   DFB2 CD 9F EB    DOREAD:	CALL	READ
1842   DFB5 C3 BB DF    	JP	IORET
1843   DFB8             ;
1844   DFB8             ;   DO THE ACTUAL DISK WRITE AND HANDLE ANY BIOS ERROR.
1845   DFB8             ;
1846   DFB8 CD 72 EC    DOWRITE:CALL	WRITE
1847   DFBB B7          IORET:	OR	A
1848   DFBC C8          	RET	Z		; RETURN UNLESS AN ERROR OCCURED.
1849   DFBD 21 09 DC    	LD	HL,BADSCTR	; BAD READ/WRITE ON THIS SECTOR.
1850   DFC0 C3 4A DF    	JP	JUMPHL
1851   DFC3             ;
1852   DFC3             ;   ROUTINE TO SELECT THE TRACK AND SECTOR THAT THE DESIRED
1853   DFC3             ; BLOCK NUMBER FALLS IN.
1854   DFC3             ;
1855   DFC3 2A EA E9    TRKSEC:	LD	HL,(FILEPOS)	; GET POSITION OF LAST ACCESSED FILE
1856   DFC6 0E 02       	LD	C,2		; IN DIRECTORY AND COMPUTE SECTOR #.
1857   DFC8 CD EA E0    	CALL	SHIFTR		; SECTOR #=FILE-POSITION/4.
1858   DFCB 22 E5 E9    	LD	(BLKNMBR),HL	; SAVE THIS AS THE BLOCK NUMBER OF INTEREST.
1859   DFCE 22 EC E9    	LD	(CKSUMTBL),HL	; WHAT'S IT DOING HERE TOO?
1860   DFD1             ;
1861   DFD1             ;   IF THE SECTOR NUMBER HAS ALREADY BEEN SET (BLKNMBR), ENTER
1862   DFD1             ; AT THIS POINT.
1863   DFD1             ;
1864   DFD1 21 E5 E9    TRKSEC1:LD	HL,BLKNMBR
1865   DFD4 4E          	LD	C,(HL)		; MOVE SECTOR NUMBER INTO (BC).
1866   DFD5 23          	INC	HL
1867   DFD6 46          	LD	B,(HL)
1868   DFD7 2A B7 E9    	LD	HL,(SCRATCH3)	; GET CURRENT SECTOR NUMBER AND
1869   DFDA 5E          	LD	E,(HL)		; MOVE THIS INTO (DE).
1870   DFDB 23          	INC	HL
1871   DFDC 56          	LD	D,(HL)
1872   DFDD 2A B5 E9    	LD	HL,(SCRATCH2)	; GET CURRENT TRACK NUMBER.
1873   DFE0 7E          	LD	A,(HL)		; AND THIS INTO (HL).
1874   DFE1 23          	INC	HL
1875   DFE2 66          	LD	H,(HL)
1876   DFE3 6F          	LD	L,A
1877   DFE4 79          TRKSEC2:LD	A,C		; IS DESIRED SECTOR BEFORE CURRENT ONE?
1878   DFE5 93          	SUB	E
1879   DFE6 78          	LD	A,B
1880   DFE7 9A          	SBC	A,D
1881   DFE8 D2 FA DF    	JP	NC,TRKSEC3
1882   DFEB E5          	PUSH	HL		; YES, DECREMENT SECTORS BY ONE TRACK.
1883   DFEC 2A C1 E9    	LD	HL,(SECTORS)	; GET SECTORS PER TRACK.
1884   DFEF 7B          	LD	A,E
1885   DFF0 95          	SUB	L
1886   DFF1 5F          	LD	E,A
1887   DFF2 7A          	LD	A,D
1888   DFF3 9C          	SBC	A,H
1889   DFF4 57          	LD	D,A		; NOW WE HAVE BACKED UP ONE FULL TRACK.
1890   DFF5 E1          	POP	HL
1891   DFF6 2B          	DEC	HL		; ADJUST TRACK COUNTER.
1892   DFF7 C3 E4 DF    	JP	TRKSEC2
1893   DFFA E5          TRKSEC3:PUSH	HL		; DESIRED SECTOR IS AFTER CURRENT ONE.
1894   DFFB 2A C1 E9    	LD	HL,(SECTORS)	; GET SECTORS PER TRACK.
1895   DFFE 19          	ADD	HL,DE		; BUMP SECTOR POINTER TO NEXT TRACK.
1896   DFFF DA 0F E0    	JP	C,TRKSEC4
1897   E002 79          	LD	A,C		; IS DESIRED SECTOR NOW BEFORE CURRENT ONE?
1898   E003 95          	SUB	L
1899   E004 78          	LD	A,B
1900   E005 9C          	SBC	A,H
1901   E006 DA 0F E0    	JP	C,TRKSEC4
1902   E009 EB          	EX	DE,HL		; NOT YES, INCREMENT TRACK COUNTER
1903   E00A E1          	POP	HL		; AND CONTINUE UNTIL IT IS.
1904   E00B 23          	INC	HL
1905   E00C C3 FA DF    	JP	TRKSEC3
1906   E00F             ;
1907   E00F             ;   HERE WE HAVE DETERMINED THE TRACK NUMBER THAT CONTAINS THE
1908   E00F             ; DESIRED SECTOR.
1909   E00F             ;
1910   E00F E1          TRKSEC4:POP	HL		; GET TRACK NUMBER (HL).
1911   E010 C5          	PUSH	BC
1912   E011 D5          	PUSH	DE
1913   E012 E5          	PUSH	HL
1914   E013 EB          	EX	DE,HL
1915   E014 2A CE E9    	LD	HL,(OFFSET)	; ADJUST FOR FIRST TRACK OFFSET.
1916   E017 19          	ADD	HL,DE
1917   E018 44          	LD	B,H
1918   E019 4D          	LD	C,L
1919   E01A CD 8A EB    	CALL	SETTRK		; SELECT THIS TRACK.
1920   E01D D1          	POP	DE		; RESET CURRENT TRACK POINTER.
1921   E01E 2A B5 E9    	LD	HL,(SCRATCH2)
1922   E021 73          	LD	(HL),E
1923   E022 23          	INC	HL
1924   E023 72          	LD	(HL),D
1925   E024 D1          	POP	DE
1926   E025 2A B7 E9    	LD	HL,(SCRATCH3)	; RESET THE FIRST SECTOR ON THIS TRACK.
1927   E028 73          	LD	(HL),E
1928   E029 23          	INC	HL
1929   E02A 72          	LD	(HL),D
1930   E02B C1          	POP	BC
1931   E02C 79          	LD	A,C		; NOW SUBTRACT THE DESIRED ONE.
1932   E02D 93          	SUB	E		; TO MAKE IT RELATIVE (1-# SECTORS/TRACK).
1933   E02E 4F          	LD	C,A
1934   E02F 78          	LD	A,B
1935   E030 9A          	SBC	A,D
1936   E031 47          	LD	B,A
1937   E032 2A D0 E9    	LD	HL,(XLATE)	; TRANSLATE THIS SECTOR ACCORDING TO THIS TABLE.
1938   E035 EB          	EX	DE,HL
1939   E036 CD 96 EB    	CALL	SECTRN		; LET THE BIOS TRANSLATE IT.
1940   E039 4D          	LD	C,L
1941   E03A 44          	LD	B,H
1942   E03B C3 90 EB    	JP	SETSEC		; AND SELECT IT.
1943   E03E             ;
1944   E03E             ;   COMPUTE BLOCK NUMBER FROM RECORD NUMBER (SAVNREC) AND
1945   E03E             ; EXTENT NUMBER (SAVEXT).
1946   E03E             ;
1947   E03E             GETBLOCK:
1948   E03E 21 C3 E9    	LD	HL,BLKSHFT	; GET LOGICAL TO PHYSICAL CONVERSION.
1949   E041 4E          	LD	C,(HL)		; NOTE THAT THIS IS BASE 2 LOG OF RATIO.
1950   E042 3A E3 E9    	LD	A,(SAVNREC)	; GET RECORD NUMBER.
1951   E045 B7          GETBLK1:OR	A		; COMPUTE (A)=(A)/2^BLKSHFT.
1952   E046 1F          	RRA
1953   E047 0D          	DEC	C
1954   E048 C2 45 E0    	JP	NZ,GETBLK1
1955   E04B 47          	LD	B,A		; SAVE RESULT IN (B).
1956   E04C 3E 08       	LD	A,8
1957   E04E 96          	SUB	(HL)
1958   E04F 4F          	LD	C,A		; COMPUTE (C)=8-BLKSHFT.
1959   E050 3A E2 E9    	LD	A,(SAVEXT)
1960   E053 0D          GETBLK2:DEC	C		; COMPUTE (A)=SAVEXT*2^(8-BLKSHFT).
1961   E054 CA 5C E0    	JP	Z,GETBLK3
1962   E057 B7          	OR	A
1963   E058 17          	RLA
1964   E059 C3 53 E0    	JP	GETBLK2
1965   E05C 80          GETBLK3:ADD	A,B
1966   E05D C9          	RET
1967   E05E             ;
1968   E05E             ;   ROUTINE TO EXTRACT THE (BC) BLOCK BYTE FROM THE FCB POINTED
1969   E05E             ; TO BY (PARAMS). IF THIS IS A BIG-DISK, THEN THESE ARE 16 BIT
1970   E05E             ; BLOCK NUMBERS, ELSE THEY ARE 8 BIT NUMBERS.
1971   E05E             ; NUMBER IS RETURNED IN (HL).
1972   E05E             ;
1973   E05E 2A 43 DF    EXTBLK:	LD	HL,(PARAMS)	; GET FCB ADDRESS.
1974   E061 11 10 00    	LD	DE,16		; BLOCK NUMBERS START 16 BYTES INTO FCB.
1975   E064 19          	ADD	HL,DE
1976   E065 09          	ADD	HL,BC
1977   E066 3A DD E9    	LD	A,(BIGDISK)	; ARE WE USING A BIG-DISK?
1978   E069 B7          	OR	A
1979   E06A CA 71 E0    	JP	Z,EXTBLK1
1980   E06D 6E          	LD	L,(HL)		; NO, EXTRACT AN 8 BIT NUMBER FROM THE FCB.
1981   E06E 26 00       	LD	H,0
1982   E070 C9          	RET
1983   E071 09          EXTBLK1:ADD	HL,BC		; YES, EXTRACT A 16 BIT NUMBER.
1984   E072 5E          	LD	E,(HL)
1985   E073 23          	INC	HL
1986   E074 56          	LD	D,(HL)
1987   E075 EB          	EX	DE,HL		; RETURN IN (HL).
1988   E076 C9          	RET
1989   E077             ;
1990   E077             ;   COMPUTE BLOCK NUMBER.
1991   E077             ;
1992   E077 CD 3E E0    COMBLK:	CALL	GETBLOCK
1993   E07A 4F          	LD	C,A
1994   E07B 06 00       	LD	B,0
1995   E07D CD 5E E0    	CALL	EXTBLK
1996   E080 22 E5 E9    	LD	(BLKNMBR),HL
1997   E083 C9          	RET
1998   E084             ;
1999   E084             ;   CHECK FOR A ZERO BLOCK NUMBER (UNUSED).
2000   E084             ;
2001   E084 2A E5 E9    CHKBLK:	LD	HL,(BLKNMBR)
2002   E087 7D          	LD	A,L		; IS IT ZERO?
2003   E088 B4          	OR	H
2004   E089 C9          	RET
2005   E08A             ;
2006   E08A             ;   ADJUST PHYSICAL BLOCK (BLKNMBR) AND CONVERT TO LOGICAL
2007   E08A             ; SECTOR (LOGSECT). THIS IS THE STARTING SECTOR OF THIS BLOCK.
2008   E08A             ; THE ACTUAL SECTOR OF INTEREST IS THEN ADDED TO THIS AND THE
2009   E08A             ; RESULTING SECTOR NUMBER IS STORED BACK IN (BLKNMBR). THIS
2010   E08A             ; WILL STILL HAVE TO BE ADJUSTED FOR THE TRACK NUMBER.
2011   E08A             ;
2012   E08A 3A C3 E9    LOGICAL:LD	A,(BLKSHFT)	; GET LOG2(PHYSICAL/LOGICAL SECTORS).
2013   E08D 2A E5 E9    	LD	HL,(BLKNMBR)	; GET PHYSICAL SECTOR DESIRED.
2014   E090 29          LOGICL1:ADD	HL,HL		; COMPUTE LOGICAL SECTOR NUMBER.
2015   E091 3D          	DEC	A		; NOTE LOGICAL SECTORS ARE 128 BYTES LONG.
2016   E092 C2 90 E0    	JP	NZ,LOGICL1
2017   E095 22 E7 E9    	LD	(LOGSECT),HL	; SAVE LOGICAL SECTOR.
2018   E098 3A C4 E9    	LD	A,(BLKMASK)	; GET BLOCK MASK.
2019   E09B 4F          	LD	C,A
2020   E09C 3A E3 E9    	LD	A,(SAVNREC)	; GET NEXT SECTOR TO ACCESS.
2021   E09F A1          	AND	C		; EXTRACT THE RELATIVE POSITION WITHIN PHYSICAL BLOCK.
2022   E0A0 B5          	OR	L		; AND ADD IT TOO LOGICAL SECTOR.
2023   E0A1 6F          	LD	L,A
2024   E0A2 22 E5 E9    	LD	(BLKNMBR),HL	; AND STORE.
2025   E0A5 C9          	RET
2026   E0A6             ;
2027   E0A6             ;   SET (HL) TO POINT TO EXTENT BYTE IN FCB.
2028   E0A6             ;
2029   E0A6 2A 43 DF    SETEXT:	LD	HL,(PARAMS)
2030   E0A9 11 0C 00    	LD	DE,12		; IT IS THE TWELTH BYTE.
2031   E0AC 19          	ADD	HL,DE
2032   E0AD C9          	RET
2033   E0AE             ;
2034   E0AE             ;   SET (HL) TO POINT TO RECORD COUNT BYTE IN FCB AND (DE) TO
2035   E0AE             ; NEXT RECORD NUMBER BYTE.
2036   E0AE             ;
2037   E0AE 2A 43 DF    SETHLDE:LD	HL,(PARAMS)
2038   E0B1 11 0F 00    	LD	DE,15		; RECORD COUNT BYTE (#15).
2039   E0B4 19          	ADD	HL,DE
2040   E0B5 EB          	EX	DE,HL
2041   E0B6 21 11 00    	LD	HL,17		; NEXT RECORD NUMBER (#32).
2042   E0B9 19          	ADD	HL,DE
2043   E0BA C9          	RET
2044   E0BB             ;
2045   E0BB             ;   SAVE CURRENT FILE DATA FROM FCB.
2046   E0BB             ;
2047   E0BB CD AE E0    STRDATA:CALL	SETHLDE
2048   E0BE 7E          	LD	A,(HL)		; GET AND STORE RECORD COUNT BYTE.
2049   E0BF 32 E3 E9    	LD	(SAVNREC),A
2050   E0C2 EB          	EX	DE,HL
2051   E0C3 7E          	LD	A,(HL)		; GET AND STORE NEXT RECORD NUMBER BYTE.
2052   E0C4 32 E1 E9    	LD	(SAVNXT),A
2053   E0C7 CD A6 E0    	CALL	SETEXT		; POINT TO EXTENT BYTE.
2054   E0CA 3A C5 E9    	LD	A,(EXTMASK)	; GET EXTENT MASK.
2055   E0CD A6          	AND	(HL)
2056   E0CE 32 E2 E9    	LD	(SAVEXT),A	; AND SAVE EXTENT HERE.
2057   E0D1 C9          	RET
2058   E0D2             ;
2059   E0D2             ;   SET THE NEXT RECORD TO ACCESS. IF (MODE) IS SET TO 2, THEN
2060   E0D2             ; THE LAST RECORD BYTE (SAVNREC) HAS THE CORRECT NUMBER TO ACCESS.
2061   E0D2             ; FOR SEQUENTIAL ACCESS, (MODE) WILL BE EQUAL TO 1.
2062   E0D2             ;
2063   E0D2 CD AE E0    SETNREC:CALL	SETHLDE
2064   E0D5 3A D5 E9    	LD	A,(MODE)	; GET SEQUENTIAL FLAG (=1).
2065   E0D8 FE 02       	CP	2		; A 2 INDICATES THAT NO ADDER IS NEEDED.
2066   E0DA C2 DE E0    	JP	NZ,STNREC1
2067   E0DD AF          	XOR	A		; CLEAR ADDER (RANDOM ACCESS?).
2068   E0DE 4F          STNREC1:LD	C,A
2069   E0DF 3A E3 E9    	LD	A,(SAVNREC)	; GET LAST RECORD NUMBER.
2070   E0E2 81          	ADD	A,C		; INCREMENT RECORD COUNT.
2071   E0E3 77          	LD	(HL),A		; AND SET FCB'S NEXT RECORD BYTE.
2072   E0E4 EB          	EX	DE,HL
2073   E0E5 3A E1 E9    	LD	A,(SAVNXT)	; GET NEXT RECORD BYTE FROM STORAGE.
2074   E0E8 77          	LD	(HL),A		; AND PUT THIS INTO FCB AS NUMBER OF RECORDS USED.
2075   E0E9 C9          	RET
2076   E0EA             ;
2077   E0EA             ;   SHIFT (HL) RIGHT (C) BITS.
2078   E0EA             ;
2079   E0EA 0C          SHIFTR:	INC	C
2080   E0EB 0D          SHIFTR1:DEC	C
2081   E0EC C8          	RET	Z
2082   E0ED 7C          	LD	A,H
2083   E0EE B7          	OR	A
2084   E0EF 1F          	RRA
2085   E0F0 67          	LD	H,A
2086   E0F1 7D          	LD	A,L
2087   E0F2 1F          	RRA
2088   E0F3 6F          	LD	L,A
2089   E0F4 C3 EB E0    	JP	SHIFTR1
2090   E0F7             ;
2091   E0F7             ;   COMPUTE THE CHECK-SUM FOR THE DIRECTORY BUFFER. RETURN
2092   E0F7             ; INTEGER SUM IN (A).
2093   E0F7             ;
2094   E0F7             CHECKSUM:
2095   E0F7 0E 80       	LD	C,128		; LENGTH OF BUFFER.
2096   E0F9 2A B9 E9    	LD	HL,(DIRBUF)	; GET ITS LOCATION.
2097   E0FC AF          	XOR	A		; CLEAR SUMMATION BYTE.
2098   E0FD 86          CHKSUM1:ADD	A,(HL)		; AND COMPUTE SUM IGNORING CARRIES.
2099   E0FE 23          	INC	HL
2100   E0FF 0D          	DEC	C
2101   E100 C2 FD E0    	JP	NZ,CHKSUM1
2102   E103 C9          	RET
2103   E104             ;
2104   E104             ;   SHIFT (HL) LEFT (C) BITS.
2105   E104             ;
2106   E104 0C          SHIFTL:	INC	C
2107   E105 0D          SHIFTL1:DEC	C
2108   E106 C8          	RET	Z
2109   E107 29          	ADD	HL,HL		; SHIFT LEFT 1 BIT.
2110   E108 C3 05 E1    	JP	SHIFTL1
2111   E10B             ;
2112   E10B             ;   ROUTINE TO SET A BIT IN A 16 BIT VALUE CONTAINED IN (BC).
2113   E10B             ; THE BIT SET DEPENDS ON THE CURRENT DRIVE SELECTION.
2114   E10B             ;
2115   E10B C5          SETBIT:	PUSH	BC		; SAVE 16 BIT WORD.
2116   E10C 3A 42 DF    	LD	A,(ACTIVE)	; GET ACTIVE DRIVE.
2117   E10F 4F          	LD	C,A
2118   E110 21 01 00    	LD	HL,1
2119   E113 CD 04 E1    	CALL	SHIFTL		; SHIFT BIT 0 INTO PLACE.
2120   E116 C1          	POP	BC		; NOW 'OR' THIS WITH THE ORIGINAL WORD.
2121   E117 79          	LD	A,C
2122   E118 B5          	OR	L
2123   E119 6F          	LD	L,A		; LOW BYTE DONE, DO HIGH BYTE.
2124   E11A 78          	LD	A,B
2125   E11B B4          	OR	H
2126   E11C 67          	LD	H,A
2127   E11D C9          	RET
2128   E11E             ;
2129   E11E             ;   EXTRACT THE WRITE PROTECT STATUS BIT FOR THE CURRENT DRIVE.
2130   E11E             ; THE RESULT IS RETURNED IN (A), BIT 0.
2131   E11E             ;
2132   E11E 2A AD E9    GETWPRT:LD	HL,(WRTPRT)	; GET STATUS BYTES.
2133   E121 3A 42 DF    	LD	A,(ACTIVE)	; WHICH DRIVE IS CURRENT?
2134   E124 4F          	LD	C,A
2135   E125 CD EA E0    	CALL	SHIFTR		; SHIFT STATUS SUCH THAT BIT 0 IS THE
2136   E128 7D          	LD	A,L		; ONE OF INTEREST FOR THIS DRIVE.
2137   E129 E6 01       	AND	01H		; AND ISOLATE IT.
2138   E12B C9          	RET
2139   E12C             ;
2140   E12C             ;   FUNCTION TO WRITE PROTECT THE CURRENT DISK.
2141   E12C             ;
2142   E12C 21 AD E9    WRTPRTD:LD	HL,WRTPRT	; POINT TO STATUS WORD.
2143   E12F 4E          	LD	C,(HL)		; SET (BC) EQUAL TO THE STATUS.
2144   E130 23          	INC	HL
2145   E131 46          	LD	B,(HL)
2146   E132 CD 0B E1    	CALL	SETBIT		; AND SET THIS BIT ACCORDING TO CURRENT DRIVE.
2147   E135 22 AD E9    	LD	(WRTPRT),HL	; THEN SAVE.
2148   E138 2A C8 E9    	LD	HL,(DIRSIZE)	; NOW SAVE DIRECTORY SIZE LIMIT.
2149   E13B 23          	INC	HL		; REMEMBER THE LAST ONE.
2150   E13C EB          	EX	DE,HL
2151   E13D 2A B3 E9    	LD	HL,(SCRATCH1)	; AND STORE IT HERE.
2152   E140 73          	LD	(HL),E		; PUT LOW BYTE.
2153   E141 23          	INC	HL
2154   E142 72          	LD	(HL),D		; THEN HIGH BYTE.
2155   E143 C9          	RET
2156   E144             ;
2157   E144             ;   CHECK FOR A READ ONLY FILE.
2158   E144             ;
2159   E144 CD 5E E1    CHKROFL:CALL	FCB2HL		; SET (HL) TO FILE ENTRY IN DIRECTORY BUFFER.
2160   E147 11 09 00    CKROF1:	LD	DE,9		; LOOK AT BIT 7 OF THE NINTH BYTE.
2161   E14A 19          	ADD	HL,DE
2162   E14B 7E          	LD	A,(HL)
2163   E14C 17          	RLA
2164   E14D D0          	RET	NC		; RETURN IF OK.
2165   E14E 21 0F DC    	LD	HL,ROFILE	; ELSE, PRINT ERROR MESSAGE AND TERMINATE.
2166   E151 C3 4A DF    	JP	JUMPHL
2167   E154             ;
2168   E154             ;   CHECK THE WRITE PROTECT STATUS OF THE ACTIVE DISK.
2169   E154             ;
2170   E154 CD 1E E1    CHKWPRT:CALL	GETWPRT
2171   E157 C8          	RET	Z		; RETURN IF OK.
2172   E158 21 0D DC    	LD	HL,RODISK	; ELSE PRINT MESSAGE AND TERMINATE.
2173   E15B C3 4A DF    	JP	JUMPHL
2174   E15E             ;
2175   E15E             ;   ROUTINE TO SET (HL) POINTING TO THE PROPER ENTRY IN THE
2176   E15E             ; DIRECTORY BUFFER.
2177   E15E             ;
2178   E15E 2A B9 E9    FCB2HL:	LD	HL,(DIRBUF)	; GET ADDRESS OF BUFFER.
2179   E161 3A E9 E9    	LD	A,(FCBPOS)	; RELATIVE POSITION OF FILE.
2180   E164             ;
2181   E164             ;   ROUTINE TO ADD (A) TO (HL).
2182   E164             ;
2183   E164 85          ADDA2HL:ADD	A,L
2184   E165 6F          	LD	L,A
2185   E166 D0          	RET	NC
2186   E167 24          	INC	H		; TAKE CARE OF ANY CARRY.
2187   E168 C9          	RET
2188   E169             ;
2189   E169             ;   ROUTINE TO GET THE 'S2' BYTE FROM THE FCB SUPPLIED IN
2190   E169             ; THE INITIAL PARAMETER SPECIFICATION.
2191   E169             ;
2192   E169 2A 43 DF    GETS2:	LD	HL,(PARAMS)	; GET ADDRESS OF FCB.
2193   E16C 11 0E 00    	LD	DE,14		; RELATIVE POSITION OF 'S2'.
2194   E16F 19          	ADD	HL,DE
2195   E170 7E          	LD	A,(HL)		; EXTRACT THIS BYTE.
2196   E171 C9          	RET
2197   E172             ;
2198   E172             ;   CLEAR THE 'S2' BYTE IN THE FCB.
2199   E172             ;
2200   E172 CD 69 E1    CLEARS2:CALL	GETS2		; THIS SETS (HL) POINTING TO IT.
2201   E175 36 00       	LD	(HL),0		; NOW CLEAR IT.
2202   E177 C9          	RET
2203   E178             ;
2204   E178             ;   SET BIT 7 IN THE 'S2' BYTE OF THE FCB.
2205   E178             ;
2206   E178 CD 69 E1    SETS2B7:CALL	GETS2		; GET THE BYTE.
2207   E17B F6 80       	OR	80H		; AND SET BIT 7.
2208   E17D 77          	LD	(HL),A		; THEN STORE.
2209   E17E C9          	RET
2210   E17F             ;
2211   E17F             ;   COMPARE (FILEPOS) WITH (SCRATCH1) AND SET FLAGS BASED ON
2212   E17F             ; THE DIFFERENCE. THIS CHECKS TO SEE IF THERE ARE MORE FILE
2213   E17F             ; NAMES IN THE DIRECTORY. WE ARE AT (FILEPOS) AND THERE ARE
2214   E17F             ; (SCRATCH1) OF THEM TO CHECK.
2215   E17F             ;
2216   E17F 2A EA E9    MOREFLS:LD	HL,(FILEPOS)	; WE ARE HERE.
2217   E182 EB          	EX	DE,HL
2218   E183 2A B3 E9    	LD	HL,(SCRATCH1)	; AND DON'T GO PAST HERE.
2219   E186 7B          	LD	A,E		; COMPUTE DIFFERENCE BUT DON'T KEEP.
2220   E187 96          	SUB	(HL)
2221   E188 23          	INC	HL
2222   E189 7A          	LD	A,D
2223   E18A 9E          	SBC	A,(HL)		; SET CARRY IF NO MORE NAMES.
2224   E18B C9          	RET
2225   E18C             ;
2226   E18C             ;   CALL THIS ROUTINE TO PREVENT (SCRATCH1) FROM BEING GREATER
2227   E18C             ; THAN (FILEPOS).
2228   E18C             ;
2229   E18C CD 7F E1    CHKNMBR:CALL	MOREFLS		; SCRATCH1 TOO BIG?
2230   E18F D8          	RET	C
2231   E190 13          	INC	DE		; YES, RESET IT TO (FILEPOS).
2232   E191 72          	LD	(HL),D
2233   E192 2B          	DEC	HL
2234   E193 73          	LD	(HL),E
2235   E194 C9          	RET
2236   E195             ;
2237   E195             ;   COMPUTE (HL)=(DE)-(HL)
2238   E195             ;
2239   E195 7B          SUBHL:	LD	A,E		; COMPUTE DIFFERENCE.
2240   E196 95          	SUB	L
2241   E197 6F          	LD	L,A		; STORE LOW BYTE.
2242   E198 7A          	LD	A,D
2243   E199 9C          	SBC	A,H
2244   E19A 67          	LD	H,A		; AND THEN HIGH BYTE.
2245   E19B C9          	RET
2246   E19C             ;
2247   E19C             ;   SET THE DIRECTORY CHECKSUM BYTE.
2248   E19C             ;
2249   E19C 0E FF       SETDIR:	LD	C,0FFH
2250   E19E             ;
2251   E19E             ;   ROUTINE TO SET OR COMPARE THE DIRECTORY CHECKSUM BYTE. IF
2252   E19E             ; (C)=0FFH, THEN THIS WILL SET THE CHECKSUM BYTE. ELSE THE BYTE
2253   E19E             ; WILL BE CHECKED. IF THE CHECK FAILS (THE DISK HAS BEEN CHANGED),
2254   E19E             ; THEN THIS DISK WILL BE WRITE PROTECTED.
2255   E19E             ;
2256   E19E             CHECKDIR:
2257   E19E 2A EC E9    	LD	HL,(CKSUMTBL)
2258   E1A1 EB          	EX	DE,HL
2259   E1A2 2A CC E9    	LD	HL,(ALLOC1)
2260   E1A5 CD 95 E1    	CALL	SUBHL
2261   E1A8 D0          	RET	NC		; OK IF (CKSUMTBL) > (ALLOC1), SO RETURN.
2262   E1A9 C5          	PUSH	BC
2263   E1AA CD F7 E0    	CALL	CHECKSUM	; ELSE COMPUTE CHECKSUM.
2264   E1AD 2A BD E9    	LD	HL,(CHKVECT)	; GET ADDRESS OF CHECKSUM TABLE.
2265   E1B0 EB          	EX	DE,HL
2266   E1B1 2A EC E9    	LD	HL,(CKSUMTBL)
2267   E1B4 19          	ADD	HL,DE		; SET (HL) TO POINT TO BYTE FOR THIS DRIVE.
2268   E1B5 C1          	POP	BC
2269   E1B6 0C          	INC	C		; SET OR CHECK ?
2270   E1B7 CA C4 E1    	JP	Z,CHKDIR1
2271   E1BA BE          	CP	(HL)		; CHECK THEM.
2272   E1BB C8          	RET	Z		; RETURN IF THEY ARE THE SAME.
2273   E1BC CD 7F E1    	CALL	MOREFLS		; NOT THE SAME, DO WE CARE?
2274   E1BF D0          	RET	NC
2275   E1C0 CD 2C E1    	CALL	WRTPRTD		; YES, MARK THIS AS WRITE PROTECTED.
2276   E1C3 C9          	RET
2277   E1C4 77          CHKDIR1:LD	(HL),A		; JUST SET THE BYTE.
2278   E1C5 C9          	RET
2279   E1C6             ;
2280   E1C6             ;   DO A WRITE TO THE DIRECTORY OF THE CURRENT DISK.
2281   E1C6             ;
2282   E1C6             DIRWRITE:
2283   E1C6 CD 9C E1    	CALL	SETDIR		; SET CHECKSUM BYTE.
2284   E1C9 CD E0 E1    	CALL	DIRDMA		; SET DIRECTORY DMA ADDRESS.
2285   E1CC 0E 01       	LD	C,1		; TELL THE BIOS TO ACTUALLY WRITE.
2286   E1CE CD B8 DF    	CALL	DOWRITE		; THEN DO THE WRITE.
2287   E1D1 C3 DA E1    	JP	DEFDMA
2288   E1D4             ;
2289   E1D4             ;   READ FROM THE DIRECTORY.
2290   E1D4             ;
2291   E1D4 CD E0 E1    DIRREAD:CALL	DIRDMA		; SET THE DIRECTORY DMA ADDRESS.
2292   E1D7 CD B2 DF    	CALL	DOREAD		; AND READ IT.
2293   E1DA             ;
2294   E1DA             ;   ROUTINE TO SET THE DMA ADDRESS TO THE USERS CHOICE.
2295   E1DA             ;
2296   E1DA 21 B1 E9    DEFDMA:	LD	HL,USERDMA	; RESET THE DEFAULT DMA ADDRESS AND RETURN.
2297   E1DD C3 E3 E1    	JP	DIRDMA1
2298   E1E0             ;
2299   E1E0             ;   ROUTINE TO SET THE DMA ADDRESS FOR DIRECTORY WORK.
2300   E1E0             ;
2301   E1E0 21 B9 E9    DIRDMA:	LD	HL,DIRBUF
2302   E1E3             ;
2303   E1E3             ;   SET THE DMA ADDRESS. ON ENTRY, (HL) POINTS TO
2304   E1E3             ; WORD CONTAINING THE DESIRED DMA ADDRESS.
2305   E1E3             ;
2306   E1E3 4E          DIRDMA1:LD	C,(HL)
2307   E1E4 23          	INC	HL
2308   E1E5 46          	LD	B,(HL)		; SETUP (BC) AND GO TO THE BIOS TO SET IT.
2309   E1E6 C3 99 EB    	JP	SETDMA
2310   E1E9             ;
2311   E1E9             ;   MOVE THE DIRECTORY BUFFER INTO USER'S DMA SPACE.
2312   E1E9             ;
2313   E1E9 2A B9 E9    MOVEDIR:LD	HL,(DIRBUF)	; BUFFER IS LOCATED HERE, AND
2314   E1EC EB          	EX	DE,HL
2315   E1ED 2A B1 E9    	LD	HL,(USERDMA)	; PUT IT HERE.
2316   E1F0 0E 80       	LD	C,128		; THIS IS ITS LENGTH.
2317   E1F2 C3 4F DF    	JP	DE2HL		; MOVE IT NOW AND RETURN.
2318   E1F5             ;
2319   E1F5             ;   CHECK (FILEPOS) AND SET THE ZERO FLAG IF IT EQUALS 0FFFFH.
2320   E1F5             ;
2321   E1F5             CKFILPOS:
2322   E1F5 21 EA E9    	LD	HL,FILEPOS
2323   E1F8 7E          	LD	A,(HL)
2324   E1F9 23          	INC	HL
2325   E1FA BE          	CP	(HL)		; ARE BOTH BYTES THE SAME?
2326   E1FB C0          	RET	NZ
2327   E1FC 3C          	INC	A		; YES, BUT ARE THEY EACH 0FFH?
2328   E1FD C9          	RET
2329   E1FE             ;
2330   E1FE             ;   SET LOCATION (FILEPOS) TO 0FFFFH.
2331   E1FE             ;
2332   E1FE             STFILPOS:
2333   E1FE 21 FF FF    	LD	HL,0FFFFH
2334   E201 22 EA E9    	LD	(FILEPOS),HL
2335   E204 C9          	RET
2336   E205             ;
2337   E205             ;   MOVE ON TO THE NEXT FILE POSITION WITHIN THE CURRENT
2338   E205             ; DIRECTORY BUFFER. IF NO MORE EXIST, SET POINTER TO 0FFFFH
2339   E205             ; AND THE CALLING ROUTINE WILL CHECK FOR THIS. ENTER WITH (C)
2340   E205             ; EQUAL TO 0FFH TO CAUSE THE CHECKSUM BYTE TO BE SET, ELSE WE
2341   E205             ; WILL CHECK THIS DISK AND SET WRITE PROTECT IF CHECKSUMS ARE
2342   E205             ; NOT THE SAME (APPLIES ONLY IF ANOTHER DIRECTORY SECTOR MUST
2343   E205             ; BE READ).
2344   E205             ;
2345   E205 2A C8 E9    NXENTRY:LD	HL,(DIRSIZE)	; GET DIRECTORY ENTRY SIZE LIMIT.
2346   E208 EB          	EX	DE,HL
2347   E209 2A EA E9    	LD	HL,(FILEPOS)	; GET CURRENT COUNT.
2348   E20C 23          	INC	HL		; GO ON TO THE NEXT ONE.
2349   E20D 22 EA E9    	LD	(FILEPOS),HL
2350   E210 CD 95 E1    	CALL	SUBHL		; (HL)=(DIRSIZE)-(FILEPOS)
2351   E213 D2 19 E2    	JP	NC,NXENT1	; IS THERE MORE ROOM LEFT?
2352   E216 C3 FE E1    	JP	STFILPOS	; NO. SET THIS FLAG AND RETURN.
2353   E219 3A EA E9    NXENT1:	LD	A,(FILEPOS)	; GET FILE POSITION WITHIN DIRECTORY.
2354   E21C E6 03       	AND	03H		; ONLY LOOK WITHIN THIS SECTOR (ONLY 4 ENTRIES FIT).
2355   E21E 06 05       	LD	B,5		; CONVERT TO RELATIVE POSITION (32 BYTES EACH).
2356   E220 87          NXENT2:	ADD	A,A		; NOTE THAT THIS IS NOT EFFICIENT CODE.
2357   E221 05          	DEC	B		; 5 'ADD A'S WOULD BE BETTER.
2358   E222 C2 20 E2    	JP	NZ,NXENT2
2359   E225 32 E9 E9    	LD	(FCBPOS),A	; SAVE IT AS POSITION OF FCB.
2360   E228 B7          	OR	A
2361   E229 C0          	RET	NZ		; RETURN IF WE ARE WITHIN BUFFER.
2362   E22A C5          	PUSH	BC
2363   E22B CD C3 DF    	CALL	TRKSEC		; WE NEED THE NEXT DIRECTORY SECTOR.
2364   E22E CD D4 E1    	CALL	DIRREAD
2365   E231 C1          	POP	BC
2366   E232 C3 9E E1    	JP	CHECKDIR
2367   E235             ;
2368   E235             ;   ROUTINE TO TO GET A BIT FROM THE DISK SPACE ALLOCATION
2369   E235             ; MAP. IT IS RETURNED IN (A), BIT POSITION 0. ON ENTRY TO HERE,
2370   E235             ; SET (BC) TO THE BLOCK NUMBER ON THE DISK TO CHECK.
2371   E235             ; ON RETURN, (D) WILL CONTAIN THE ORIGINAL BIT POSITION FOR
2372   E235             ; THIS BLOCK NUMBER AND (HL) WILL POINT TO THE ADDRESS FOR IT.
2373   E235             ;
2374   E235             CKBITMAP:
2375   E235 79          	LD	A,C		; DETERMINE BIT NUMBER OF INTEREST.
2376   E236 E6 07       	AND	07H		; COMPUTE (D)=(E)=(C AND 7)+1.
2377   E238 3C          	INC	A
2378   E239 5F          	LD	E,A		; SAVE PARTICULAR BIT NUMBER.
2379   E23A 57          	LD	D,A
2380   E23B             ;
2381   E23B             ;   COMPUTE (BC)=(BC)/8.
2382   E23B             ;
2383   E23B 79          	LD	A,C
2384   E23C 0F          	RRCA			; NOW SHIFT RIGHT 3 BITS.
2385   E23D 0F          	RRCA
2386   E23E 0F          	RRCA
2387   E23F E6 1F       	AND	1FH		; AND CLEAR BITS 7,6,5.
2388   E241 4F          	LD	C,A
2389   E242 78          	LD	A,B
2390   E243 87          	ADD	A,A		; NOW SHIFT (B) INTO BITS 7,6,5.
2391   E244 87          	ADD	A,A
2392   E245 87          	ADD	A,A
2393   E246 87          	ADD	A,A
2394   E247 87          	ADD	A,A
2395   E248 B1          	OR	C		; AND ADD IN (C).
2396   E249 4F          	LD	C,A		; OK, (C) HA BEEN COMPLETED.
2397   E24A 78          	LD	A,B		; IS THERE A BETTER WAY OF DOING THIS?
2398   E24B 0F          	RRCA
2399   E24C 0F          	RRCA
2400   E24D 0F          	RRCA
2401   E24E E6 1F       	AND	1FH
2402   E250 47          	LD	B,A		; AND NOW (B) IS COMPLETED.
2403   E251             ;
2404   E251             ;   USE THIS AS AN OFFSET INTO THE DISK SPACE ALLOCATION
2405   E251             ; TABLE.
2406   E251             ;
2407   E251 2A BF E9    	LD	HL,(ALOCVECT)
2408   E254 09          	ADD	HL,BC
2409   E255 7E          	LD	A,(HL)		; NOW GET CORRECT BYTE.
2410   E256 07          CKBMAP1:RLCA			; GET CORRECT BIT INTO POSITION 0.
2411   E257 1D          	DEC	E
2412   E258 C2 56 E2    	JP	NZ,CKBMAP1
2413   E25B C9          	RET
2414   E25C             ;
2415   E25C             ;   SET OR CLEAR THE BIT MAP SUCH THAT BLOCK NUMBER (BC) WILL BE MARKED
2416   E25C             ; AS USED. ON ENTRY, IF (E)=0 THEN THIS BIT WILL BE CLEARED, IF IT EQUALS
2417   E25C             ; 1 THEN IT WILL BE SET (DON'T USE ANYOTHER VALUES).
2418   E25C             ;
2419   E25C             STBITMAP:
2420   E25C D5          	PUSH	DE
2421   E25D CD 35 E2    	CALL	CKBITMAP	; GET THE BYTE OF INTEREST.
2422   E260 E6 FE       	AND	0FEH		; CLEAR THE AFFECTED BIT.
2423   E262 C1          	POP	BC
2424   E263 B1          	OR	C		; AND NOW SET IT ACORDING TO (C).
2425   E264             ;
2426   E264             ;  ENTRY TO RESTORE THE ORIGINAL BIT POSITION AND THEN STORE
2427   E264             ; IN TABLE. (A) CONTAINS THE VALUE, (D) CONTAINS THE BIT
2428   E264             ; POSITION (1-8), AND (HL) POINTS TO THE ADDRESS WITHIN THE
2429   E264             ; SPACE ALLOCATION TABLE FOR THIS BYTE.
2430   E264             ;
2431   E264 0F          STBMAP1:RRCA			; RESTORE ORIGINAL BIT POSITION.
2432   E265 15          	DEC	D
2433   E266 C2 64 E2    	JP	NZ,STBMAP1
2434   E269 77          	LD	(HL),A		; AND STOR BYTE IN TABLE.
2435   E26A C9          	RET
2436   E26B             ;
2437   E26B             ;   SET/CLEAR SPACE USED BITS IN ALLOCATION MAP FOR THIS FILE.
2438   E26B             ; ON ENTRY, (C)=1 TO SET THE MAP AND (C)=0 TO CLEAR IT.
2439   E26B             ;
2440   E26B CD 5E E1    SETFILE:CALL	FCB2HL		; GET ADDRESS OF FCB
2441   E26E 11 10 00    	LD	DE,16
2442   E271 19          	ADD	HL,DE		; GET TO BLOCK NUMBER BYTES.
2443   E272 C5          	PUSH	BC
2444   E273 0E 11       	LD	C,17		; CHECK ALL 17 BYTES (MAX) OF TABLE.
2445   E275 D1          SETFL1:	POP	DE
2446   E276 0D          	DEC	C		; DONE ALL BYTES YET?
2447   E277 C8          	RET	Z
2448   E278 D5          	PUSH	DE
2449   E279 3A DD E9    	LD	A,(BIGDISK)	; CHECK DISK SIZE FOR 16 BIT BLOCK NUMBERS.
2450   E27C B7          	OR	A
2451   E27D CA 88 E2    	JP	Z,SETFL2
2452   E280 C5          	PUSH	BC		; ONLY 8 BIT NUMBERS. SET (BC) TO THIS ONE.
2453   E281 E5          	PUSH	HL
2454   E282 4E          	LD	C,(HL)		; GET LOW BYTE FROM TABLE, ALWAYS
2455   E283 06 00       	LD	B,0		; SET HIGH BYTE TO ZERO.
2456   E285 C3 8E E2    	JP	SETFL3
2457   E288 0D          SETFL2:	DEC	C		; FOR 16 BIT BLOCK NUMBERS, ADJUST COUNTER.
2458   E289 C5          	PUSH	BC
2459   E28A 4E          	LD	C,(HL)		; NOW GET BOTH THE LOW AND HIGH BYTES.
2460   E28B 23          	INC	HL
2461   E28C 46          	LD	B,(HL)
2462   E28D E5          	PUSH	HL
2463   E28E 79          SETFL3:	LD	A,C		; BLOCK USED?
2464   E28F B0          	OR	B
2465   E290 CA 9D E2    	JP	Z,SETFL4
2466   E293 2A C6 E9    	LD	HL,(DSKSIZE)	; IS THIS BLOCK NUMBER WITHIN THE
2467   E296 7D          	LD	A,L		; SPACE ON THE DISK?
2468   E297 91          	SUB	C
2469   E298 7C          	LD	A,H
2470   E299 98          	SBC	A,B
2471   E29A D4 5C E2    	CALL	NC,STBITMAP	; YES, SET THE PROPER BIT.
2472   E29D E1          SETFL4:	POP	HL		; POINT TO NEXT BLOCK NUMBER IN FCB.
2473   E29E 23          	INC	HL
2474   E29F C1          	POP	BC
2475   E2A0 C3 75 E2    	JP	SETFL1
2476   E2A3             ;
2477   E2A3             ;   CONSTRUCT THE SPACE USED ALLOCATION BIT MAP FOR THE ACTIVE
2478   E2A3             ; DRIVE. IF A FILE NAME STARTS WITH '$' AND IT IS UNDER THE
2479   E2A3             ; CURRENT USER NUMBER, THEN (STATUS) IS SET TO MINUS 1. OTHERWISE
2480   E2A3             ; IT IS NOT SET AT ALL.
2481   E2A3             ;
2482   E2A3 2A C6 E9    BITMAP:	LD	HL,(DSKSIZE)	; COMPUTE SIZE OF ALLOCATION TABLE.
2483   E2A6 0E 03       	LD	C,3
2484   E2A8 CD EA E0    	CALL	SHIFTR		; (HL)=(HL)/8.
2485   E2AB 23          	INC	HL		; AT LEASE 1 BYTE.
2486   E2AC 44          	LD	B,H
2487   E2AD 4D          	LD	C,L		; SET (BC) TO THE ALLOCATION TABLE LENGTH.
2488   E2AE             ;
2489   E2AE             ;   INITIALIZE THE BITMAP FOR THIS DRIVE. RIGHT NOW, THE FIRST
2490   E2AE             ; TWO BYTES ARE SPECIFIED BY THE DISK PARAMETER BLOCK. HOWEVER
2491   E2AE             ; A PATCH COULD BE ENTERED HERE IF IT WERE NECESSARY TO SETUP
2492   E2AE             ; THIS TABLE IN A SPECIAL MANNOR. FOR EXAMPLE, THE BIOS COULD
2493   E2AE             ; DETERMINE LOCATIONS OF 'BAD BLOCKS' AND SET THEM AS ALREADY
2494   E2AE             ; 'USED' IN THE MAP.
2495   E2AE             ;
2496   E2AE 2A BF E9    	LD	HL,(ALOCVECT)	; NOW ZERO OUT THE TABLE NOW.
2497   E2B1 36 00       BITMAP1:LD	(HL),0
2498   E2B3 23          	INC	HL
2499   E2B4 0B          	DEC	BC
2500   E2B5 78          	LD	A,B
2501   E2B6 B1          	OR	C
2502   E2B7 C2 B1 E2    	JP	NZ,BITMAP1
2503   E2BA 2A CA E9    	LD	HL,(ALLOC0)	; GET INITIAL SPACE USED BY DIRECTORY.
2504   E2BD EB          	EX	DE,HL
2505   E2BE 2A BF E9    	LD	HL,(ALOCVECT)	; AND PUT THIS INTO MAP.
2506   E2C1 73          	LD	(HL),E
2507   E2C2 23          	INC	HL
2508   E2C3 72          	LD	(HL),D
2509   E2C4             ;
2510   E2C4             ;   END OF INITIALIZATION PORTION.
2511   E2C4             ;
2512   E2C4 CD A1 DF    	CALL	HOMEDRV		; NOW HOME THE DRIVE.
2513   E2C7 2A B3 E9    	LD	HL,(SCRATCH1)
2514   E2CA 36 03       	LD	(HL),3		; FORCE NEXT DIRECTORY REQUEST TO READ
2515   E2CC 23          	INC	HL		; IN A SECTOR.
2516   E2CD 36 00       	LD	(HL),0
2517   E2CF CD FE E1    	CALL	STFILPOS	; CLEAR INITIAL FILE POSITION ALSO.
2518   E2D2 0E FF       BITMAP2:LD	C,0FFH		; READ NEXT FILE NAME IN DIRECTORY
2519   E2D4 CD 05 E2    	CALL	NXENTRY		; AND SET CHECKSUM BYTE.
2520   E2D7 CD F5 E1    	CALL	CKFILPOS	; IS THERE ANOTHER FILE?
2521   E2DA C8          	RET	Z
2522   E2DB CD 5E E1    	CALL	FCB2HL		; YES, GET ITS ADDRESS.
2523   E2DE 3E E5       	LD	A,0E5H
2524   E2E0 BE          	CP	(HL)		; EMPTY FILE ENTRY?
2525   E2E1 CA D2 E2    	JP	Z,BITMAP2
2526   E2E4 3A 41 DF    	LD	A,(USERNO)	; NO, CORRECT USER NUMBER?
2527   E2E7 BE          	CP	(HL)
2528   E2E8 C2 F6 E2    	JP	NZ,BITMAP3
2529   E2EB 23          	INC	HL
2530   E2EC 7E          	LD	A,(HL)		; YES, DOES NAME START WITH A '$'?
2531   E2ED D6 24       	SUB	'$'
2532   E2EF C2 F6 E2    	JP	NZ,BITMAP3
2533   E2F2 3D          	DEC	A		; YES, SET ATATUS TO MINUS ONE.
2534   E2F3 32 45 DF    	LD	(STATUS),A
2535   E2F6 0E 01       BITMAP3:LD	C,1		; NOW SET THIS FILE'S SPACE AS USED IN BIT MAP.
2536   E2F8 CD 6B E2    	CALL	SETFILE
2537   E2FB CD 8C E1    	CALL	CHKNMBR		; KEEP (SCRATCH1) IN BOUNDS.
2538   E2FE C3 D2 E2    	JP	BITMAP2
2539   E301             ;
2540   E301             ;   SET THE STATUS (STATUS) AND RETURN.
2541   E301             ;
2542   E301             STSTATUS:
2543   E301 3A D4 E9    	LD	A,(FNDSTAT)
2544   E304 C3 01 DF    	JP	SETSTAT
2545   E307             ;
2546   E307             ;   CHECK EXTENTS IN (A) AND (C). SET THE ZERO FLAG IF THEY
2547   E307             ; ARE THE SAME. THE NUMBER OF 16K CHUNKS OF DISK SPACE THAT
2548   E307             ; THE DIRECTORY EXTENT COVERS IS EXPRESSAD IS (EXTMASK+1).
2549   E307             ; NO REGISTERS ARE MODIFIED.
2550   E307             ;
2551   E307 C5          SAMEXT:	PUSH	BC
2552   E308 F5          	PUSH	AF
2553   E309 3A C5 E9    	LD	A,(EXTMASK)	; GET EXTENT MASK AND USE IT TO
2554   E30C 2F          	CPL			; TO COMPARE BOTH EXTENT NUMBERS.
2555   E30D 47          	LD	B,A		; SAVE RESULTING MASK HERE.
2556   E30E 79          	LD	A,C		; MASK FIRST EXTENT AND SAVE IN (C).
2557   E30F A0          	AND	B
2558   E310 4F          	LD	C,A
2559   E311 F1          	POP	AF		; NOW MASK SECOND EXTENT AND COMPARE
2560   E312 A0          	AND	B		; WITH THE FIRST ONE.
2561   E313 91          	SUB	C
2562   E314 E6 1F       	AND	1FH		; (* ONLY CHECK BUTS 0-4 *)
2563   E316 C1          	POP	BC		; THE ZERO FLAG IS SET IF THEY ARE THE SAME.
2564   E317 C9          	RET			; RESTORE (BC) AND RETURN.
2565   E318             ;
2566   E318             ;   SEARCH FOR THE FIRST OCCURENCE OF A FILE NAME. ON ENTRY,
2567   E318             ; REGISTER (C) SHOULD CONTAIN THE NUMBER OF BYTES OF THE FCB
2568   E318             ; THAT MUST MATCH.
2569   E318             ;
2570   E318 3E FF       FINDFST:LD	A,0FFH
2571   E31A 32 D4 E9    	LD	(FNDSTAT),A
2572   E31D 21 D8 E9    	LD	HL,COUNTER	; SAVE CHARACTER COUNT.
2573   E320 71          	LD	(HL),C
2574   E321 2A 43 DF    	LD	HL,(PARAMS)	; GET FILENAME TO MATCH.
2575   E324 22 D9 E9    	LD	(SAVEFCB),HL	; AND SAVE.
2576   E327 CD FE E1    	CALL	STFILPOS	; CLEAR INITIAL FILE POSITION (SET TO 0FFFFH).
2577   E32A CD A1 DF    	CALL	HOMEDRV		; HOME THE DRIVE.
2578   E32D             ;
2579   E32D             ;   ENTRY TO LOCATE THE NEXT OCCURENCE OF A FILENAME WITHIN THE
2580   E32D             ; DIRECTORY. THE DISK IS NOT EXPECTED TO HAVE BEEN CHANGED. IF
2581   E32D             ; IT WAS, THEN IT WILL BE WRITE PROTECTED.
2582   E32D             ;
2583   E32D 0E 00       FINDNXT:LD	C,0		; WRITE PROTECT THE DISK IF CHANGED.
2584   E32F CD 05 E2    	CALL	NXENTRY		; GET NEXT FILENAME ENTRY IN DIRECTORY.
2585   E332 CD F5 E1    	CALL	CKFILPOS	; IS FILE POSITION = 0FFFFH?
2586   E335 CA 94 E3    	JP	Z,FNDNXT6	; YES, EXIT NOW THEN.
2587   E338 2A D9 E9    	LD	HL,(SAVEFCB)	; SET (DE) POINTING TO FILENAME TO MATCH.
2588   E33B EB          	EX	DE,HL
2589   E33C 1A          	LD	A,(DE)
2590   E33D FE E5       	CP	0E5H		; EMPTY DIRECTORY ENTRY?
2591   E33F CA 4A E3    	JP	Z,FNDNXT1	; (* ARE WE TRYING TO RESERECT ERASED ENTRIES? *)
2592   E342 D5          	PUSH	DE
2593   E343 CD 7F E1    	CALL	MOREFLS		; MORE FILES IN DIRECTORY?
2594   E346 D1          	POP	DE
2595   E347 D2 94 E3    	JP	NC,FNDNXT6	; NO MORE. EXIT NOW.
2596   E34A CD 5E E1    FNDNXT1:CALL	FCB2HL		; GET ADDRESS OF THIS FCB IN DIRECTORY.
2597   E34D 3A D8 E9    	LD	A,(COUNTER)	; GET NUMBER OF BYTES (CHARACTERS) TO CHECK.
2598   E350 4F          	LD	C,A
2599   E351 06 00       	LD	B,0		; INITIALIZE BYTE POSITION COUNTER.
2600   E353 79          FNDNXT2:LD	A,C		; ARE WE DONE WITH THE COMPARE?
2601   E354 B7          	OR	A
2602   E355 CA 83 E3    	JP	Z,FNDNXT5
2603   E358 1A          	LD	A,(DE)		; NO, CHECK NEXT BYTE.
2604   E359 FE 3F       	CP	'?'		; DON'T CARE ABOUT THIS CHARACTER?
2605   E35B CA 7C E3    	JP	Z,FNDNXT4
2606   E35E 78          	LD	A,B		; GET BYTES POSITION IN FCB.
2607   E35F FE 0D       	CP	13		; DON'T CARE ABOUT THE THIRTEENTH BYTE EITHER.
2608   E361 CA 7C E3    	JP	Z,FNDNXT4
2609   E364 FE 0C       	CP	12		; EXTENT BYTE?
2610   E366 1A          	LD	A,(DE)
2611   E367 CA 73 E3    	JP	Z,FNDNXT3
2612   E36A 96          	SUB	(HL)		; OTHERWISE COMPARE CHARACTERS.
2613   E36B E6 7F       	AND	7FH
2614   E36D C2 2D E3    	JP	NZ,FINDNXT	; NOT THE SAME, CHECK NEXT ENTRY.
2615   E370 C3 7C E3    	JP	FNDNXT4		; SO FAR SO GOOD, KEEP CHECKING.
2616   E373 C5          FNDNXT3:PUSH	BC		; CHECK THE EXTENT BYTE HERE.
2617   E374 4E          	LD	C,(HL)
2618   E375 CD 07 E3    	CALL	SAMEXT
2619   E378 C1          	POP	BC
2620   E379 C2 2D E3    	JP	NZ,FINDNXT	; NOT THE SAME, LOOK SOME MORE.
2621   E37C             ;
2622   E37C             ;   SO FAR THE NAMES COMPARE. BUMP POINTERS TO THE NEXT BYTE
2623   E37C             ; AND CONTINUE UNTIL ALL (C) CHARACTERS HAVE BEEN CHECKED.
2624   E37C             ;
2625   E37C 13          FNDNXT4:INC	DE		; BUMP POINTERS.
2626   E37D 23          	INC	HL
2627   E37E 04          	INC	B
2628   E37F 0D          	DEC	C		; ADJUST CHARACTER COUNTER.
2629   E380 C3 53 E3    	JP	FNDNXT2
2630   E383 3A EA E9    FNDNXT5:LD	A,(FILEPOS)	; RETURN THE POSITION OF THIS ENTRY.
2631   E386 E6 03       	AND	03H
2632   E388 32 45 DF    	LD	(STATUS),A
2633   E38B 21 D4 E9    	LD	HL,FNDSTAT
2634   E38E 7E          	LD	A,(HL)
2635   E38F 17          	RLA
2636   E390 D0          	RET	NC
2637   E391 AF          	XOR	A
2638   E392 77          	LD	(HL),A
2639   E393 C9          	RET
2640   E394             ;
2641   E394             ;   FILENAME WAS NOT FOUND. SET APPROPRIATE STATUS.
2642   E394             ;
2643   E394 CD FE E1    FNDNXT6:CALL	STFILPOS	; SET (FILEPOS) TO 0FFFFH.
2644   E397 3E FF       	LD	A,0FFH		; SAY NOT LOCATED.
2645   E399 C3 01 DF    	JP	SETSTAT
2646   E39C             ;
2647   E39C             ;   ERASE FILES FROM THE DIRECTORY. ONLY THE FIRST BYTE OF THE
2648   E39C             ; FCB WILL BE AFFECTED. IT IS SET TO (E5).
2649   E39C             ;
2650   E39C CD 54 E1    ERAFILE:CALL	CHKWPRT		; IS DISK WRITE PROTECTED?
2651   E39F 0E 0C       	LD	C,12		; ONLY COMPARE FILE NAMES.
2652   E3A1 CD 18 E3    	CALL	FINDFST		; GET FIRST FILE NAME.
2653   E3A4 CD F5 E1    ERAFIL1:CALL	CKFILPOS	; ANY FOUND?
2654   E3A7 C8          	RET	Z		; NOPE, WE MUST BE DONE.
2655   E3A8 CD 44 E1    	CALL	CHKROFL		; IS FILE READ ONLY?
2656   E3AB CD 5E E1    	CALL	FCB2HL		; NOPE, GET ADDRESS OF FCB AND
2657   E3AE 36 E5       	LD	(HL),0E5H	; SET FIRST BYTE TO 'EMPTY'.
2658   E3B0 0E 00       	LD	C,0		; CLEAR THE SPACE FROM THE BIT MAP.
2659   E3B2 CD 6B E2    	CALL	SETFILE
2660   E3B5 CD C6 E1    	CALL	DIRWRITE	; NOW WRITE THE DIRECTORY SECTOR BACK OUT.
2661   E3B8 CD 2D E3    	CALL	FINDNXT		; FIND THE NEXT FILE NAME.
2662   E3BB C3 A4 E3    	JP	ERAFIL1		; AND REPEAT PROCESS.
2663   E3BE             ;
2664   E3BE             ;   LOOK THROUGH THE SPACE ALLOCATION MAP (BIT MAP) FOR THE
2665   E3BE             ; NEXT AVAILABLE BLOCK. START SEARCHING AT BLOCK NUMBER (BC-1).
2666   E3BE             ; THE SEARCH PROCEDURE IS TO LOOK FOR AN EMPTY BLOCK THAT IS
2667   E3BE             ; BEFORE THE STARTING BLOCK. IF NOT EMPTY, LOOK AT A LATER
2668   E3BE             ; BLOCK NUMBER. IN THIS WAY, WE RETURN THE CLOSEST EMPTY BLOCK
2669   E3BE             ; ON EITHER SIDE OF THE 'TARGET' BLOCK NUMBER. THIS WILL SPEED
2670   E3BE             ; ACCESS ON RANDOM DEVICES. FOR SERIAL DEVICES, THIS SHOULD BE
2671   E3BE             ; CHANGED TO LOOK IN THE FORWARD DIRECTION FIRST AND THEN START
2672   E3BE             ; AT THE FRONT AND SEARCH SOME MORE.
2673   E3BE             ;
2674   E3BE             ;   ON RETURN, (DE)= BLOCK NUMBER THAT IS EMPTY AND (HL) =0
2675   E3BE             ; IF NO EMPRY BLOCK WAS FOUND.
2676   E3BE             ;
2677   E3BE             FNDSPACE:
2678   E3BE 50          	LD	D,B		; SET (DE) AS THE BLOCK THAT IS CHECKED.
2679   E3BF 59          	LD	E,C
2680   E3C0             ;
2681   E3C0             ;   LOOK BEFORE TARGET BLOCK. REGISTERS (BC) ARE USED AS THE LOWER
2682   E3C0             ; POINTER AND (DE) AS THE UPPER POINTER.
2683   E3C0             ;
2684   E3C0 79          FNDSPA1:LD	A,C		; IS BLOCK 0 SPECIFIED?
2685   E3C1 B0          	OR	B
2686   E3C2 CA D1 E3    	JP	Z,FNDSPA2
2687   E3C5 0B          	DEC	BC		; NOPE, CHECK PREVIOUS BLOCK.
2688   E3C6 D5          	PUSH	DE
2689   E3C7 C5          	PUSH	BC
2690   E3C8 CD 35 E2    	CALL	CKBITMAP
2691   E3CB 1F          	RRA			; IS THIS BLOCK EMPTY?
2692   E3CC D2 EC E3    	JP	NC,FNDSPA3	; YES. USE THIS.
2693   E3CF             ;
2694   E3CF             ;   NOTE THAT THE ABOVE LOGIC GETS THE FIRST BLOCK THAT IT FINDS
2695   E3CF             ; THAT IS EMPTY. THUS A FILE COULD BE WRITTEN 'BACKWARD' MAKING
2696   E3CF             ; IT VERY SLOW TO ACCESS. THIS COULD BE CHANGED TO LOOK FOR THE
2697   E3CF             ; FIRST EMPTY BLOCK AND THEN CONTINUE UNTIL THE START OF THIS
2698   E3CF             ; EMPTY SPACE IS LOCATED AND THEN USED THAT STARTING BLOCK.
2699   E3CF             ; THIS SHOULD HELP SPEED UP ACCESS TO SOME FILES ESPECIALLY ON
2700   E3CF             ; A WELL USED DISK WITH LOTS OF FAIRLY SMALL 'HOLES'.
2701   E3CF             ;
2702   E3CF C1          	POP	BC		; NOPE, CHECK SOME MORE.
2703   E3D0 D1          	POP	DE
2704   E3D1             ;
2705   E3D1             ;   NOW LOOK AFTER TARGET BLOCK.
2706   E3D1             ;
2707   E3D1 2A C6 E9    FNDSPA2:LD	HL,(DSKSIZE)	; IS BLOCK (DE) WITHIN DISK LIMITS?
2708   E3D4 7B          	LD	A,E
2709   E3D5 95          	SUB	L
2710   E3D6 7A          	LD	A,D
2711   E3D7 9C          	SBC	A,H
2712   E3D8 D2 F4 E3    	JP	NC,FNDSPA4
2713   E3DB 13          	INC	DE		; YES, MOVE ON TO NEXT ONE.
2714   E3DC C5          	PUSH	BC
2715   E3DD D5          	PUSH	DE
2716   E3DE 42          	LD	B,D
2717   E3DF 4B          	LD	C,E
2718   E3E0 CD 35 E2    	CALL	CKBITMAP	; CHECK IT.
2719   E3E3 1F          	RRA			; EMPTY?
2720   E3E4 D2 EC E3    	JP	NC,FNDSPA3
2721   E3E7 D1          	POP	DE		; NOPE, CONTINUE SEARCHING.
2722   E3E8 C1          	POP	BC
2723   E3E9 C3 C0 E3    	JP	FNDSPA1
2724   E3EC             ;
2725   E3EC             ;   EMPTY BLOCK FOUND. SET IT AS USED AND RETURN WITH (HL)
2726   E3EC             ; POINTING TO IT (TRUE?).
2727   E3EC             ;
2728   E3EC 17          FNDSPA3:RLA			; RESET BYTE.
2729   E3ED 3C          	INC	A		; AND SET BIT 0.
2730   E3EE CD 64 E2    	CALL	STBMAP1		; UPDATE BIT MAP.
2731   E3F1 E1          	POP	HL		; SET RETURN REGISTERS.
2732   E3F2 D1          	POP	DE
2733   E3F3 C9          	RET
2734   E3F4             ;
2735   E3F4             ;   FREE BLOCK WAS NOT FOUND. IF (BC) IS NOT ZERO, THEN WE HAVE
2736   E3F4             ; NOT CHECKED ALL OF THE DISK SPACE.
2737   E3F4             ;
2738   E3F4 79          FNDSPA4:LD	A,C
2739   E3F5 B0          	OR	B
2740   E3F6 C2 C0 E3    	JP	NZ,FNDSPA1
2741   E3F9 21 00 00    	LD	HL,0		; SET 'NOT FOUND' STATUS.
2742   E3FC C9          	RET
2743   E3FD             ;
2744   E3FD             ;   MOVE A COMPLETE FCB ENTRY INTO THE DIRECTORY AND WRITE IT.
2745   E3FD             ;
2746   E3FD 0E 00       FCBSET:	LD	C,0
2747   E3FF 1E 20       	LD	E,32		; LENGTH OF EACH ENTRY.
2748   E401             ;
2749   E401             ;   MOVE (E) BYTES FROM THE FCB POINTED TO BY (PARAMS) INTO
2750   E401             ; FCB IN DIRECTORY STARTING AT RELATIVE BYTE (C). THIS UPDATED
2751   E401             ; DIRECTORY BUFFER IS THEN WRITTEN TO THE DISK.
2752   E401             ;
2753   E401 D5          UPDATE:	PUSH	DE
2754   E402 06 00       	LD	B,0		; SET (BC) TO RELATIVE BYTE POSITION.
2755   E404 2A 43 DF    	LD	HL,(PARAMS)	; GET ADDRESS OF FCB.
2756   E407 09          	ADD	HL,BC		; COMPUTE STARTING BYTE.
2757   E408 EB          	EX	DE,HL
2758   E409 CD 5E E1    	CALL	FCB2HL		; GET ADDRESS OF FCB TO UPDATE IN DIRECTORY.
2759   E40C C1          	POP	BC		; SET (C) TO NUMBER OF BYTES TO CHANGE.
2760   E40D CD 4F DF    	CALL	DE2HL
2761   E410 CD C3 DF    UPDATE1:CALL	TRKSEC		; DETERMINE THE TRACK AND SECTOR AFFECTED.
2762   E413 C3 C6 E1    	JP	DIRWRITE	; THEN WRITE THIS SECTOR OUT.
2763   E416             ;
2764   E416             ;   ROUTINE TO CHANGE THE NAME OF ALL FILES ON THE DISK WITH A
2765   E416             ; SPECIFIED NAME. THE FCB CONTAINS THE CURRENT NAME AS THE
2766   E416             ; FIRST 12 CHARACTERS AND THE NEW NAME 16 BYTES INTO THE FCB.
2767   E416             ;
2768   E416             CHGNAMES:
2769   E416 CD 54 E1    	CALL	CHKWPRT		; CHECK FOR A WRITE PROTECTED DISK.
2770   E419 0E 0C       	LD	C,12		; MATCH FIRST 12 BYTES OF FCB ONLY.
2771   E41B CD 18 E3    	CALL	FINDFST		; GET FIRST NAME.
2772   E41E 2A 43 DF    	LD	HL,(PARAMS)	; GET ADDRESS OF FCB.
2773   E421 7E          	LD	A,(HL)		; GET USER NUMBER.
2774   E422 11 10 00    	LD	DE,16		; MOVE OVER TO DESIRED NAME.
2775   E425 19          	ADD	HL,DE
2776   E426 77          	LD	(HL),A		; KEEP SAME USER NUMBER.
2777   E427 CD F5 E1    CHGNAM1:CALL	CKFILPOS	; ANY MATCHING FILE FOUND?
2778   E42A C8          	RET	Z		; NO, WE MUST BE DONE.
2779   E42B CD 44 E1    	CALL	CHKROFL		; CHECK FOR READ ONLY FILE.
2780   E42E 0E 10       	LD	C,16		; START 16 BYTES INTO FCB.
2781   E430 1E 0C       	LD	E,12		; AND UPDATE THE FIRST 12 BYTES OF DIRECTORY.
2782   E432 CD 01 E4    	CALL	UPDATE
2783   E435 CD 2D E3    	CALL	FINDNXT		; GET TE NEXT FILE NAME.
2784   E438 C3 27 E4    	JP	CHGNAM1		; AND CONTINUE.
2785   E43B             ;
2786   E43B             ;   UPDATE A FILES ATTRIBUTES. THE PROCEDURE IS TO SEARCH FOR
2787   E43B             ; EVERY FILE WITH THE SAME NAME AS SHOWN IN FCB (IGNORING BIT 7)
2788   E43B             ; AND THEN TO UPDATE IT (WHICH INCLUDES BIT 7). NO OTHER CHANGES
2789   E43B             ; ARE MADE.
2790   E43B             ;
2791   E43B             SAVEATTR:
2792   E43B 0E 0C       	LD	C,12		; MATCH FIRST 12 BYTES.
2793   E43D CD 18 E3    	CALL	FINDFST		; LOOK FOR FIRST FILENAME.
2794   E440 CD F5 E1    SAVATR1:CALL	CKFILPOS	; WAS ONE FOUND?
2795   E443 C8          	RET	Z		; NOPE, WE MUST BE DONE.
2796   E444 0E 00       	LD	C,0		; YES, UPDATE THE FIRST 12 BYTES NOW.
2797   E446 1E 0C       	LD	E,12
2798   E448 CD 01 E4    	CALL	UPDATE		; UPDATE FILENAME AND WRITE DIRECTORY.
2799   E44B CD 2D E3    	CALL	FINDNXT		; AND GET THE NEXT FILE.
2800   E44E C3 40 E4    	JP	SAVATR1		; THEN CONTINUE UNTIL DONE.
2801   E451             ;
2802   E451             ;  OPEN A FILE (NAME SPECIFIED IN FCB).
2803   E451             ;
2804   E451 0E 0F       OPENIT:	LD	C,15		; COMPARE THE FIRST 15 BYTES.
2805   E453 CD 18 E3    	CALL	FINDFST		; GET THE FIRST ONE IN DIRECTORY.
2806   E456 CD F5 E1    	CALL	CKFILPOS	; ANY AT ALL?
2807   E459 C8          	RET	Z
2808   E45A CD A6 E0    OPENIT1:CALL	SETEXT		; POINT TO EXTENT BYTE WITHIN USERS FCB.
2809   E45D 7E          	LD	A,(HL)		; AND GET IT.
2810   E45E F5          	PUSH	AF		; SAVE IT AND ADDRESS.
2811   E45F E5          	PUSH	HL
2812   E460 CD 5E E1    	CALL	FCB2HL		; POINT TO FCB IN DIRECTORY.
2813   E463 EB          	EX	DE,HL
2814   E464 2A 43 DF    	LD	HL,(PARAMS)	; THIS IS THE USERS COPY.
2815   E467 0E 20       	LD	C,32		; MOVE IT INTO USERS SPACE.
2816   E469 D5          	PUSH	DE
2817   E46A CD 4F DF    	CALL	DE2HL
2818   E46D CD 78 E1    	CALL	SETS2B7		; SET BIT 7 IN 'S2' BYTE (UNMODIFIED).
2819   E470 D1          	POP	DE		; NOW GET THE EXTENT BYTE FROM THIS FCB.
2820   E471 21 0C 00    	LD	HL,12
2821   E474 19          	ADD	HL,DE
2822   E475 4E          	LD	C,(HL)		; INTO (C).
2823   E476 21 0F 00    	LD	HL,15		; NOW GET THE RECORD COUNT BYTE INTO (B).
2824   E479 19          	ADD	HL,DE
2825   E47A 46          	LD	B,(HL)
2826   E47B E1          	POP	HL		; KEEP THE SAME EXTENT AS THE USER HAD ORIGINALLY.
2827   E47C F1          	POP	AF
2828   E47D 77          	LD	(HL),A
2829   E47E 79          	LD	A,C		; IS IT THE SAME AS IN THE DIRECTORY FCB?
2830   E47F BE          	CP	(HL)
2831   E480 78          	LD	A,B		; IF YES, THEN USE THE SAME RECORD COUNT.
2832   E481 CA 8B E4    	JP	Z,OPENIT2
2833   E484 3E 00       	LD	A,0		; IF THE USER SPECIFIED AN EXTENT GREATER THAN
2834   E486 DA 8B E4    	JP	C,OPENIT2	; THE ONE IN THE DIRECTORY, THEN SET RECORD COUNT TO 0.
2835   E489 3E 80       	LD	A,128		; OTHERWISE SET TO MAXIMUM.
2836   E48B 2A 43 DF    OPENIT2:LD	HL,(PARAMS)	; SET RECORD COUNT IN USERS FCB TO (A).
2837   E48E 11 0F 00    	LD	DE,15
2838   E491 19          	ADD	HL,DE		; COMPUTE RELATIVE POSITION.
2839   E492 77          	LD	(HL),A		; AND SET THE RECORD COUNT.
2840   E493 C9          	RET
2841   E494             ;
2842   E494             ;   MOVE TWO BYTES FROM (DE) TO (HL) IF (AND ONLY IF) (HL)
2843   E494             ; POINT TO A ZERO VALUE (16 BIT).
2844   E494             ;   RETURN WITH ZERO FLAG SET IT (DE) WAS MOVED. REGISTERS (DE)
2845   E494             ; AND (HL) ARE NOT CHANGED. HOWEVER (A) IS.
2846   E494             ;
2847   E494             MOVEWORD:
2848   E494 7E          	LD	A,(HL)		; CHECK FOR A ZERO WORD.
2849   E495 23          	INC	HL
2850   E496 B6          	OR	(HL)		; BOTH BYTES ZERO?
2851   E497 2B          	DEC	HL
2852   E498 C0          	RET	NZ		; NOPE, JUST RETURN.
2853   E499 1A          	LD	A,(DE)		; YES, MOVE TWO BYTES FROM (DE) INTO
2854   E49A 77          	LD	(HL),A		; THIS ZERO SPACE.
2855   E49B 13          	INC	DE
2856   E49C 23          	INC	HL
2857   E49D 1A          	LD	A,(DE)
2858   E49E 77          	LD	(HL),A
2859   E49F 1B          	DEC	DE		; DON'T DISTURB THESE REGISTERS.
2860   E4A0 2B          	DEC	HL
2861   E4A1 C9          	RET
2862   E4A2             ;
2863   E4A2             ;   GET HERE TO CLOSE A FILE SPECIFIED BY (FCB).
2864   E4A2             ;
2865   E4A2 AF          CLOSEIT:XOR	A		; CLEAR STATUS AND FILE POSITION BYTES.
2866   E4A3 32 45 DF    	LD	(STATUS),A
2867   E4A6 32 EA E9    	LD	(FILEPOS),A
2868   E4A9 32 EB E9    	LD	(FILEPOS+1),A
2869   E4AC CD 1E E1    	CALL	GETWPRT		; GET WRITE PROTECT BIT FOR THIS DRIVE.
2870   E4AF C0          	RET	NZ		; JUST RETURN IF IT IS SET.
2871   E4B0 CD 69 E1    	CALL	GETS2		; ELSE GET THE 'S2' BYTE.
2872   E4B3 E6 80       	AND	80H		; AND LOOK AT BIT 7 (FILE UNMODIFIED?).
2873   E4B5 C0          	RET	NZ		; JUST RETURN IF SET.
2874   E4B6 0E 0F       	LD	C,15		; ELSE LOOK UP THIS FILE IN DIRECTORY.
2875   E4B8 CD 18 E3    	CALL	FINDFST
2876   E4BB CD F5 E1    	CALL	CKFILPOS	; WAS IT FOUND?
2877   E4BE C8          	RET	Z		; JUST RETURN IF NOT.
2878   E4BF 01 10 00    	LD	BC,16		; SET (HL) POINTING TO RECORDS USED SECTION.
2879   E4C2 CD 5E E1    	CALL	FCB2HL
2880   E4C5 09          	ADD	HL,BC
2881   E4C6 EB          	EX	DE,HL
2882   E4C7 2A 43 DF    	LD	HL,(PARAMS)	; DO THE SAME FOR USERS SPECIFIED FCB.
2883   E4CA 09          	ADD	HL,BC
2884   E4CB 0E 10       	LD	C,16		; THIS MANY BYTES ARE PRESENT IN THIS EXTENT.
2885   E4CD             CLOSEIT1:
2886   E4CD 3A DD E9    	LD	A,(BIGDISK)	; 8 OR 16 BIT RECORD NUMBERS?
2887   E4D0 B7          	OR	A
2888   E4D1 CA E8 E4    	JP	Z,CLOSEIT4
2889   E4D4 7E          	LD	A,(HL)		; JUST 8 BIT. GET ONE FROM USERS FCB.
2890   E4D5 B7          	OR	A
2891   E4D6 1A          	LD	A,(DE)		; NOW GET ONE FROM DIRECTORY FCB.
2892   E4D7 C2 DB E4    	JP	NZ,CLOSEIT2
2893   E4DA 77          	LD	(HL),A		; USERS BYTE WAS ZERO. UPDATE FROM DIRECTORY.
2894   E4DB             CLOSEIT2:
2895   E4DB B7          	OR	A
2896   E4DC C2 E1 E4    	JP	NZ,CLOSEIT3
2897   E4DF 7E          	LD	A,(HL)		; DIRECTORIES BYTE WAS ZERO, UPDATE FROM USERS FCB.
2898   E4E0 12          	LD	(DE),A
2899   E4E1             CLOSEIT3:
2900   E4E1 BE          	CP	(HL)		; IF NEITHER ONE OF THESE BYTES WERE ZERO,
2901   E4E2 C2 1F E5    	JP	NZ,CLOSEIT7	; THEN CLOSE ERROR IF THEY ARE NOT THE SAME.
2902   E4E5 C3 FD E4    	JP	CLOSEIT5	; OK SO FAR, GET TO NEXT BYTE IN FCBS.
2903   E4E8             CLOSEIT4:
2904   E4E8 CD 94 E4    	CALL	MOVEWORD	; UPDATE USERS FCB IF IT IS ZERO.
2905   E4EB EB          	EX	DE,HL
2906   E4EC CD 94 E4    	CALL	MOVEWORD	; UPDATE DIRECTORIES FCB IF IT IS ZERO.
2907   E4EF EB          	EX	DE,HL
2908   E4F0 1A          	LD	A,(DE)		; IF THESE TWO VALUES ARE NO DIFFERENT,
2909   E4F1 BE          	CP	(HL)		; THEN A CLOSE ERROR OCCURED.
2910   E4F2 C2 1F E5    	JP	NZ,CLOSEIT7
2911   E4F5 13          	INC	DE		; CHECK SECOND BYTE.
2912   E4F6 23          	INC	HL
2913   E4F7 1A          	LD	A,(DE)
2914   E4F8 BE          	CP	(HL)
2915   E4F9 C2 1F E5    	JP	NZ,CLOSEIT7
2916   E4FC 0D          	DEC	C		; REMEMBER 16 BIT VALUES.
2917   E4FD             CLOSEIT5:
2918   E4FD 13          	INC	DE		; BUMP TO NEXT ITEM IN TABLE.
2919   E4FE 23          	INC	HL
2920   E4FF 0D          	DEC	C		; THERE ARE 16 ENTRIES ONLY.
2921   E500 C2 CD E4    	JP	NZ,CLOSEIT1	; CONTINUE IF MORE TO DO.
2922   E503 01 EC FF    	LD	BC,0FFECH	; BACKUP 20 PLACES (EXTENT BYTE).
2923   E506 09          	ADD	HL,BC
2924   E507 EB          	EX	DE,HL
2925   E508 09          	ADD	HL,BC
2926   E509 1A          	LD	A,(DE)
2927   E50A BE          	CP	(HL)		; DIRECTORY'S EXTENT ALREADY GREATER THAN THE
2928   E50B DA 17 E5    	JP	C,CLOSEIT6	; USERS EXTENT?
2929   E50E 77          	LD	(HL),A		; NO, UPDATE DIRECTORY EXTENT.
2930   E50F 01 03 00    	LD	BC,3		; AND UPDATE THE RECORD COUNT BYTE IN
2931   E512 09          	ADD	HL,BC		; DIRECTORIES FCB.
2932   E513 EB          	EX	DE,HL
2933   E514 09          	ADD	HL,BC
2934   E515 7E          	LD	A,(HL)		; GET FROM USER.
2935   E516 12          	LD	(DE),A		; AND PUT IN DIRECTORY.
2936   E517             CLOSEIT6:
2937   E517 3E FF       	LD	A,0FFH		; SET 'WAS OPEN AND IS NOW CLOSED' BYTE.
2938   E519 32 D2 E9    	LD	(CLOSEFLG),A
2939   E51C C3 10 E4    	JP	UPDATE1		; UPDATE THE DIRECTORY NOW.
2940   E51F             CLOSEIT7:
2941   E51F 21 45 DF    	LD	HL,STATUS	; SET RETURN STATUS AND THEN RETURN.
2942   E522 35          	DEC	(HL)
2943   E523 C9          	RET
2944   E524             ;
2945   E524             ;   ROUTINE TO GET THE NEXT EMPTY SPACE IN THE DIRECTORY. IT
2946   E524             ; WILL THEN BE CLEARED FOR USE.
2947   E524             ;
2948   E524             GETEMPTY:
2949   E524 CD 54 E1    	CALL	CHKWPRT		; MAKE SURE DISK IS NOT WRITE PROTECTED.
2950   E527 2A 43 DF    	LD	HL,(PARAMS)	; SAVE CURRENT PARAMETERS (FCB).
2951   E52A E5          	PUSH	HL
2952   E52B 21 AC E9    	LD	HL,EMPTYFCB	; USE SPECIAL ONE FOR EMPTY SPACE.
2953   E52E 22 43 DF    	LD	(PARAMS),HL
2954   E531 0E 01       	LD	C,1		; SEARCH FOR FIRST EMPTY SPOT IN DIRECTORY.
2955   E533 CD 18 E3    	CALL	FINDFST		; (* ONLY CHECK FIRST BYTE *)
2956   E536 CD F5 E1    	CALL	CKFILPOS	; NONE?
2957   E539 E1          	POP	HL
2958   E53A 22 43 DF    	LD	(PARAMS),HL	; RESTORE ORIGINAL FCB ADDRESS.
2959   E53D C8          	RET	Z		; RETURN IF NO MORE SPACE.
2960   E53E EB          	EX	DE,HL
2961   E53F 21 0F 00    	LD	HL,15		; POINT TO NUMBER OF RECORDS FOR THIS FILE.
2962   E542 19          	ADD	HL,DE
2963   E543 0E 11       	LD	C,17		; AND CLEAR ALL OF THIS SPACE.
2964   E545 AF          	XOR	A
2965   E546 77          GETMT1:	LD	(HL),A
2966   E547 23          	INC	HL
2967   E548 0D          	DEC	C
2968   E549 C2 46 E5    	JP	NZ,GETMT1
2969   E54C 21 0D 00    	LD	HL,13		; CLEAR THE 'S1' BYTE ALSO.
2970   E54F 19          	ADD	HL,DE
2971   E550 77          	LD	(HL),A
2972   E551 CD 8C E1    	CALL	CHKNMBR		; KEEP (SCRATCH1) WITHIN BOUNDS.
2973   E554 CD FD E3    	CALL	FCBSET		; WRITE OUT THIS FCB ENTRY TO DIRECTORY.
2974   E557 C3 78 E1    	JP	SETS2B7		; SET 'S2' BYTE BIT 7 (UNMODIFIED AT PRESENT).
2975   E55A             ;
2976   E55A             ;   ROUTINE TO CLOSE THE CURRENT EXTENT AND OPEN THE NEXT ONE
2977   E55A             ; FOR READING.
2978   E55A             ;
2979   E55A AF          GETNEXT:XOR	A
2980   E55B 32 D2 E9    	LD	(CLOSEFLG),A	; CLEAR CLOSE FLAG.
2981   E55E CD A2 E4    	CALL	CLOSEIT		; CLOSE THIS EXTENT.
2982   E561 CD F5 E1    	CALL	CKFILPOS
2983   E564 C8          	RET	Z		; NOT THERE???
2984   E565 2A 43 DF    	LD	HL,(PARAMS)	; GET EXTENT BYTE.
2985   E568 01 0C 00    	LD	BC,12
2986   E56B 09          	ADD	HL,BC
2987   E56C 7E          	LD	A,(HL)		; AND INCREMENT IT.
2988   E56D 3C          	INC	A
2989   E56E E6 1F       	AND	1FH		; KEEP WITHIN RANGE 0-31.
2990   E570 77          	LD	(HL),A
2991   E571 CA 83 E5    	JP	Z,GTNEXT1	; OVERFLOW?
2992   E574 47          	LD	B,A		; MASK EXTENT BYTE.
2993   E575 3A C5 E9    	LD	A,(EXTMASK)
2994   E578 A0          	AND	B
2995   E579 21 D2 E9    	LD	HL,CLOSEFLG	; CHECK CLOSE FLAG (0FFH IS OK).
2996   E57C A6          	AND	(HL)
2997   E57D CA 8E E5    	JP	Z,GTNEXT2	; IF ZERO, WE MUST READ IN NEXT EXTENT.
2998   E580 C3 AC E5    	JP	GTNEXT3		; ELSE, IT IS ALREADY IN MEMORY.
2999   E583 01 02 00    GTNEXT1:LD	BC,2		; POINT TO THE 'S2' BYTE.
3000   E586 09          	ADD	HL,BC
3001   E587 34          	INC	(HL)		; AND BUMP IT.
3002   E588 7E          	LD	A,(HL)		; TOO MANY EXTENTS?
3003   E589 E6 0F       	AND	0FH
3004   E58B CA B6 E5    	JP	Z,GTNEXT5	; YES, SET ERROR CODE.
3005   E58E             ;
3006   E58E             ;   GET HERE TO OPEN THE NEXT EXTENT.
3007   E58E             ;
3008   E58E 0E 0F       GTNEXT2:LD	C,15		; SET TO CHECK FIRST 15 BYTES OF FCB.
3009   E590 CD 18 E3    	CALL	FINDFST		; FIND THE FIRST ONE.
3010   E593 CD F5 E1    	CALL	CKFILPOS	; NONE AVAILABLE?
3011   E596 C2 AC E5    	JP	NZ,GTNEXT3
3012   E599 3A D3 E9    	LD	A,(RDWRTFLG)	; NO EXTENT PRESENT. CAN WE OPEN AN EMPTY ONE?
3013   E59C 3C          	INC	A		; 0FFH MEANS READING (SO NOT POSSIBLE).
3014   E59D CA B6 E5    	JP	Z,GTNEXT5	; OR AN ERROR.
3015   E5A0 CD 24 E5    	CALL	GETEMPTY	; WE ARE WRITING, GET AN EMPTY ENTRY.
3016   E5A3 CD F5 E1    	CALL	CKFILPOS	; NONE?
3017   E5A6 CA B6 E5    	JP	Z,GTNEXT5	; ERROR IF TRUE.
3018   E5A9 C3 AF E5    	JP	GTNEXT4		; ELSE WE ARE ALMOST DONE.
3019   E5AC CD 5A E4    GTNEXT3:CALL	OPENIT1		; OPEN THIS EXTENT.
3020   E5AF CD BB E0    GTNEXT4:CALL	STRDATA		; MOVE IN UPDATED DATA (REC #, EXTENT #, ETC.)
3021   E5B2 AF          	XOR	A		; CLEAR STATUS AND RETURN.
3022   E5B3 C3 01 DF    	JP	SETSTAT
3023   E5B6             ;
3024   E5B6             ;   ERROR IN EXTENDING THE FILE. TOO MANY EXTENTS WERE NEEDED
3025   E5B6             ; OR NOT ENOUGH SPACE ON THE DISK.
3026   E5B6             ;
3027   E5B6 CD 05 DF    GTNEXT5:CALL	IOERR1		; SET ERROR CODE, CLEAR BIT 7 OF 'S2'
3028   E5B9 C3 78 E1    	JP	SETS2B7		; SO THIS IS NOT WRITTEN ON A CLOSE.
3029   E5BC             ;
3030   E5BC             ;   READ A SEQUENTIAL FILE.
3031   E5BC             ;
3032   E5BC 3E 01       RDSEQ:	LD	A,1		; SET SEQUENTIAL ACCESS MODE.
3033   E5BE 32 D5 E9    	LD	(MODE),A
3034   E5C1 3E FF       RDSEQ1:	LD	A,0FFH		; DON'T ALLOW READING UNWRITTEN SPACE.
3035   E5C3 32 D3 E9    	LD	(RDWRTFLG),A
3036   E5C6 CD BB E0    	CALL	STRDATA		; PUT REC# AND EXT# INTO FCB.
3037   E5C9 3A E3 E9    	LD	A,(SAVNREC)	; GET NEXT RECORD TO READ.
3038   E5CC 21 E1 E9    	LD	HL,SAVNXT	; GET NUMBER OF RECORDS IN EXTENT.
3039   E5CF BE          	CP	(HL)		; WITHIN THIS EXTENT?
3040   E5D0 DA E6 E5    	JP	C,RDSEQ2
3041   E5D3 FE 80       	CP	128		; NO. IS THIS EXTENT FULLY USED?
3042   E5D5 C2 FB E5    	JP	NZ,RDSEQ3	; NO. END-OF-FILE.
3043   E5D8 CD 5A E5    	CALL	GETNEXT		; YES, OPEN THE NEXT ONE.
3044   E5DB AF          	XOR	A		; RESET NEXT RECORD TO READ.
3045   E5DC 32 E3 E9    	LD	(SAVNREC),A
3046   E5DF 3A 45 DF    	LD	A,(STATUS)	; CHECK ON OPEN, SUCCESSFUL?
3047   E5E2 B7          	OR	A
3048   E5E3 C2 FB E5    	JP	NZ,RDSEQ3	; NO, ERROR.
3049   E5E6 CD 77 E0    RDSEQ2:	CALL	COMBLK		; OK. COMPUTE BLOCK NUMBER TO READ.
3050   E5E9 CD 84 E0    	CALL	CHKBLK		; CHECK IT. WITHIN BOUNDS?
3051   E5EC CA FB E5    	JP	Z,RDSEQ3	; NO, ERROR.
3052   E5EF CD 8A E0    	CALL	LOGICAL		; CONVERT (BLKNMBR) TO LOGICAL SECTOR (128 BYTE).
3053   E5F2 CD D1 DF    	CALL	TRKSEC1		; SET THE TRACK AND SECTOR FOR THIS BLOCK #.
3054   E5F5 CD B2 DF    	CALL	DOREAD		; AND READ IT.
3055   E5F8 C3 D2 E0    	JP	SETNREC		; AND SET THE NEXT RECORD TO BE ACCESSED.
3056   E5FB             ;
3057   E5FB             ;   READ ERROR OCCURED. SET STATUS AND RETURN.
3058   E5FB             ;
3059   E5FB C3 05 DF    RDSEQ3:	JP	IOERR1
3060   E5FE             ;
3061   E5FE             ;   WRITE THE NEXT SEQUENTIAL RECORD.
3062   E5FE             ;
3063   E5FE 3E 01       WTSEQ:	LD	A,1		; SET SEQUENTIAL ACCESS MODE.
3064   E600 32 D5 E9    	LD	(MODE),A
3065   E603 3E 00       WTSEQ1:	LD	A,0		; ALLOW AN ADDITION EMPTY EXTENT TO BE OPENED.
3066   E605 32 D3 E9    	LD	(RDWRTFLG),A
3067   E608 CD 54 E1    	CALL	CHKWPRT		; CHECK WRITE PROTECT STATUS.
3068   E60B 2A 43 DF    	LD	HL,(PARAMS)
3069   E60E CD 47 E1    	CALL	CKROF1		; CHECK FOR READ ONLY FILE, (HL) ALREADY SET TO FCB.
3070   E611 CD BB E0    	CALL	STRDATA		; PUT UPDATED DATA INTO FCB.
3071   E614 3A E3 E9    	LD	A,(SAVNREC)	; GET RECORD NUMBER TO WRITE.
3072   E617 FE 80       	CP	128		; WITHIN RANGE?
3073   E619 D2 05 DF    	JP	NC,IOERR1	; NO, ERROR(?).
3074   E61C CD 77 E0    	CALL	COMBLK		; COMPUTE BLOCK NUMBER.
3075   E61F CD 84 E0    	CALL	CHKBLK		; CHECK NUMBER.
3076   E622 0E 00       	LD	C,0		; IS THERE ONE TO WRITE TO?
3077   E624 C2 6E E6    	JP	NZ,WTSEQ6	; YES, GO DO IT.
3078   E627 CD 3E E0    	CALL	GETBLOCK	; GET NEXT BLOCK NUMBER WITHIN FCB TO USE.
3079   E62A 32 D7 E9    	LD	(RELBLOCK),A	; AND SAVE.
3080   E62D 01 00 00    	LD	BC,0		; START LOOKING FOR SPACE FROM THE START
3081   E630 B7          	OR	A		; IF NONE ALLOCATED AS YET.
3082   E631 CA 3B E6    	JP	Z,WTSEQ2
3083   E634 4F          	LD	C,A		; EXTRACT PREVIOUS BLOCK NUMBER FROM FCB
3084   E635 0B          	DEC	BC		; SO WE CAN BE CLOSEST TO IT.
3085   E636 CD 5E E0    	CALL	EXTBLK
3086   E639 44          	LD	B,H
3087   E63A 4D          	LD	C,L
3088   E63B CD BE E3    WTSEQ2:	CALL	FNDSPACE	; FIND THE NEXT EMPTY BLOCK NEAREST NUMBER (BC).
3089   E63E 7D          	LD	A,L		; CHECK FOR A ZERO NUMBER.
3090   E63F B4          	OR	H
3091   E640 C2 48 E6    	JP	NZ,WTSEQ3
3092   E643 3E 02       	LD	A,2		; NO MORE SPACE?
3093   E645 C3 01 DF    	JP	SETSTAT
3094   E648 22 E5 E9    WTSEQ3:	LD	(BLKNMBR),HL	; SAVE BLOCK NUMBER TO ACCESS.
3095   E64B EB          	EX	DE,HL		; PUT BLOCK NUMBER INTO (DE).
3096   E64C 2A 43 DF    	LD	HL,(PARAMS)	; NOW WE MUST UPDATE THE FCB FOR THIS
3097   E64F 01 10 00    	LD	BC,16		; NEWLY ALLOCATED BLOCK.
3098   E652 09          	ADD	HL,BC
3099   E653 3A DD E9    	LD	A,(BIGDISK)	; 8 OR 16 BIT BLOCK NUMBERS?
3100   E656 B7          	OR	A
3101   E657 3A D7 E9    	LD	A,(RELBLOCK)	; (* UPDATE THIS ENTRY *)
3102   E65A CA 64 E6    	JP	Z,WTSEQ4	; ZERO MEANS 16 BIT ONES.
3103   E65D CD 64 E1    	CALL	ADDA2HL		; (HL)=(HL)+(A)
3104   E660 73          	LD	(HL),E		; STORE NEW BLOCK NUMBER.
3105   E661 C3 6C E6    	JP	WTSEQ5
3106   E664 4F          WTSEQ4:	LD	C,A		; COMPUTE SPOT IN THIS 16 BIT TABLE.
3107   E665 06 00       	LD	B,0
3108   E667 09          	ADD	HL,BC
3109   E668 09          	ADD	HL,BC
3110   E669 73          	LD	(HL),E		; STUFF BLOCK NUMBER (DE) THERE.
3111   E66A 23          	INC	HL
3112   E66B 72          	LD	(HL),D
3113   E66C 0E 02       WTSEQ5:	LD	C,2		; SET (C) TO INDICATE WRITING TO UN-USED DISK SPACE.
3114   E66E 3A 45 DF    WTSEQ6:	LD	A,(STATUS)	; ARE WE OK SO FAR?
3115   E671 B7          	OR	A
3116   E672 C0          	RET	NZ
3117   E673 C5          	PUSH	BC		; YES, SAVE WRITE FLAG FOR BIOS (REGISTER C).
3118   E674 CD 8A E0    	CALL	LOGICAL		; CONVERT (BLKNMBR) OVER TO LOICAL SECTORS.
3119   E677 3A D5 E9    	LD	A,(MODE)	; GET ACCESS MODE FLAG (1=SEQUENTIAL,
3120   E67A 3D          	DEC	A		; 0=RANDOM, 2=SPECIAL?).
3121   E67B 3D          	DEC	A
3122   E67C C2 BB E6    	JP	NZ,WTSEQ9
3123   E67F             ;
3124   E67F             ;   SPECIAL RANDOM I/O FROM FUNCTION #40. MAYBE FOR M/PM, BUT THE
3125   E67F             ; CURRENT BLOCK, IF IT HAS NOT BEEN WRITTEN TO, WILL BE ZEROED
3126   E67F             ; OUT AND THEN WRITTEN (REASON?).
3127   E67F             ;
3128   E67F C1          	POP	BC
3129   E680 C5          	PUSH	BC
3130   E681 79          	LD	A,C		; GET WRITE STATUS FLAG (2=WRITING UNUSED SPACE).
3131   E682 3D          	DEC	A
3132   E683 3D          	DEC	A
3133   E684 C2 BB E6    	JP	NZ,WTSEQ9
3134   E687 E5          	PUSH	HL
3135   E688 2A B9 E9    	LD	HL,(DIRBUF)	; ZERO OUT THE DIRECTORY BUFFER.
3136   E68B 57          	LD	D,A		; NOTE THAT (A) IS ZERO HERE.
3137   E68C 77          WTSEQ7:	LD	(HL),A
3138   E68D 23          	INC	HL
3139   E68E 14          	INC	D		; DO 128 BYTES.
3140   E68F F2 8C E6    	JP	P,WTSEQ7
3141   E692 CD E0 E1    	CALL	DIRDMA		; TELL THE BIOS THE DMA ADDRESS FOR DIRECTORY ACCESS.
3142   E695 2A E7 E9    	LD	HL,(LOGSECT)	; GET SECTOR THAT STARTS CURRENT BLOCK.
3143   E698 0E 02       	LD	C,2		; SET 'WRITING TO UNUSED SPACE' FLAG.
3144   E69A 22 E5 E9    WTSEQ8:	LD	(BLKNMBR),HL	; SAVE SECTOR TO WRITE.
3145   E69D C5          	PUSH	BC
3146   E69E CD D1 DF    	CALL	TRKSEC1		; DETERMINE ITS TRACK AND SECTOR NUMBERS.
3147   E6A1 C1          	POP	BC
3148   E6A2 CD B8 DF    	CALL	DOWRITE		; NOW WRITE OUT 128 BYTES OF ZEROS.
3149   E6A5 2A E5 E9    	LD	HL,(BLKNMBR)	; GET SECTOR NUMBER.
3150   E6A8 0E 00       	LD	C,0		; SET NORMAL WRITE FLAG.
3151   E6AA 3A C4 E9    	LD	A,(BLKMASK)	; DETERMINE IF WE HAVE WRITTEN THE ENTIRE
3152   E6AD 47          	LD	B,A		; PHYSICAL BLOCK.
3153   E6AE A5          	AND	L
3154   E6AF B8          	CP	B
3155   E6B0 23          	INC	HL		; PREPARE FOR THE NEXT ONE.
3156   E6B1 C2 9A E6    	JP	NZ,WTSEQ8	; CONTINUE UNTIL (BLKMASK+1) SECTORS WRITTEN.
3157   E6B4 E1          	POP	HL		; RESET NEXT SECTOR NUMBER.
3158   E6B5 22 E5 E9    	LD	(BLKNMBR),HL
3159   E6B8 CD DA E1    	CALL	DEFDMA		; AND RESET DMA ADDRESS.
3160   E6BB             ;
3161   E6BB             ;   NORMAL DISK WRITE. SET THE DESIRED TRACK AND SECTOR THEN
3162   E6BB             ; DO THE ACTUAL WRITE.
3163   E6BB             ;
3164   E6BB CD D1 DF    WTSEQ9:	CALL	TRKSEC1		; DETERMINE TRACK AND SECTOR FOR THIS WRITE.
3165   E6BE C1          	POP	BC		; GET WRITE STATUS FLAG.
3166   E6BF C5          	PUSH	BC
3167   E6C0 CD B8 DF    	CALL	DOWRITE		; AND WRITE THIS OUT.
3168   E6C3 C1          	POP	BC
3169   E6C4 3A E3 E9    	LD	A,(SAVNREC)	; GET NUMBER OF RECORDS IN FILE.
3170   E6C7 21 E1 E9    	LD	HL,SAVNXT	; GET LAST RECORD WRITTEN.
3171   E6CA BE          	CP	(HL)
3172   E6CB DA D2 E6    	JP	C,WTSEQ10
3173   E6CE 77          	LD	(HL),A		; WE HAVE TO UPDATE RECORD COUNT.
3174   E6CF 34          	INC	(HL)
3175   E6D0 0E 02       	LD	C,2
3176   E6D2             ;
3177   E6D2             ;*   THIS AREA HAS BEEN PATCHED TO CORRECT DISK UPDATE PROBLEM
3178   E6D2             ;* WHEN USING BLOCKING AND DE-BLOCKING IN THE BIOS.
3179   E6D2             ;
3180   E6D2 00          WTSEQ10:NOP			; WAS 'DCR C'
3181   E6D3 00          	NOP			; WAS 'DCR C'
3182   E6D4 21 00 00    	LD	HL,0		; WAS 'JNZ WTSEQ99'
3183   E6D7             ;
3184   E6D7             ; *   END OF PATCH.
3185   E6D7             ;
3186   E6D7 F5          	PUSH	AF
3187   E6D8 CD 69 E1    	CALL	GETS2		; SET 'EXTENT WRITTEN TO' FLAG.
3188   E6DB E6 7F       	AND	7FH		; (* CLEAR BIT 7 *)
3189   E6DD 77          	LD	(HL),A
3190   E6DE F1          	POP	AF		; GET RECORD COUNT FOR THIS EXTENT.
3191   E6DF FE 7F       WTSEQ99:CP	127		; IS IT FULL?
3192   E6E1 C2 00 E7    	JP	NZ,WTSEQ12
3193   E6E4 3A D5 E9    	LD	A,(MODE)	; YES, ARE WE IN SEQUENTIAL MODE?
3194   E6E7 FE 01       	CP	1
3195   E6E9 C2 00 E7    	JP	NZ,WTSEQ12
3196   E6EC CD D2 E0    	CALL	SETNREC		; YES, SET NEXT RECORD NUMBER.
3197   E6EF CD 5A E5    	CALL	GETNEXT		; AND GET NEXT EMPTY SPACE IN DIRECTORY.
3198   E6F2 21 45 DF    	LD	HL,STATUS	; OK?
3199   E6F5 7E          	LD	A,(HL)
3200   E6F6 B7          	OR	A
3201   E6F7 C2 FE E6    	JP	NZ,WTSEQ11
3202   E6FA 3D          	DEC	A		; YES, SET RECORD COUNT TO -1.
3203   E6FB 32 E3 E9    	LD	(SAVNREC),A
3204   E6FE 36 00       WTSEQ11:LD	(HL),0		; CLEAR STATUS.
3205   E700 C3 D2 E0    WTSEQ12:JP	SETNREC		; SET NEXT RECORD TO ACCESS.
3206   E703             ;
3207   E703             ;   FOR RANDOM I/O, SET THE FCB FOR THE DESIRED RECORD NUMBER
3208   E703             ; BASED ON THE 'R0,R1,R2' BYTES. THESE BYTES IN THE FCB ARE
3209   E703             ; USED AS FOLLOWS:
3210   E703             ;
3211   E703             ;       FCB+35            FCB+34            FCB+33
3212   E703             ;  |     'R-2'      |      'R-1'      |      'R-0'     |
3213   E703             ;  |7             0 | 7             0 | 7             0|
3214   E703             ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3215   E703             ;  |    OVERFLOW   | | EXTRA |  EXTENT   |   RECORD #  |
3216   E703             ;  | ______________| |_EXTENT|__NUMBER___|_____________|
3217   E703             ;                     ALSO 'S2'
3218   E703             ;
3219   E703             ;   ON ENTRY, REGISTER (C) CONTAINS 0FFH IF THIS IS A READ
3220   E703             ; AND THUS WE CAN NOT ACCESS UNWRITTEN DISK SPACE. OTHERWISE,
3221   E703             ; ANOTHER EXTENT WILL BE OPENED (FOR WRITING) IF REQUIRED.
3222   E703             ;
3223   E703             POSITION:
3224   E703 AF          	XOR	A		; SET RANDOM I/O FLAG.
3225   E704 32 D5 E9    	LD	(MODE),A
3226   E707             ;
3227   E707             ;   SPECIAL ENTRY (FUNCTION #40). M/PM ?
3228   E707             ;
3229   E707 C5          POSITN1:PUSH	BC		; SAVE READ/WRITE FLAG.
3230   E708 2A 43 DF    	LD	HL,(PARAMS)	; GET ADDRESS OF FCB.
3231   E70B EB          	EX	DE,HL
3232   E70C 21 21 00    	LD	HL,33		; NOW GET BYTE 'R0'.
3233   E70F 19          	ADD	HL,DE
3234   E710 7E          	LD	A,(HL)
3235   E711 E6 7F       	AND	7FH		; KEEP BITS 0-6 FOR THE RECORD NUMBER TO ACCESS.
3236   E713 F5          	PUSH	AF
3237   E714 7E          	LD	A,(HL)		; NOW GET BIT 7 OF 'R0' AND BITS 0-3 OF 'R1'.
3238   E715 17          	RLA
3239   E716 23          	INC	HL
3240   E717 7E          	LD	A,(HL)
3241   E718 17          	RLA
3242   E719 E6 1F       	AND	1FH		; AND SAVE THIS IN BITS 0-4 OF (C).
3243   E71B 4F          	LD	C,A		; THIS IS THE EXTENT BYTE.
3244   E71C 7E          	LD	A,(HL)		; NOW GET THE EXTRA EXTENT BYTE.
3245   E71D 1F          	RRA
3246   E71E 1F          	RRA
3247   E71F 1F          	RRA
3248   E720 1F          	RRA
3249   E721 E6 0F       	AND	0FH
3250   E723 47          	LD	B,A		; AND SAVE IT IN (B).
3251   E724 F1          	POP	AF		; GET RECORD NUMBER BACK TO (A).
3252   E725 23          	INC	HL		; CHECK OVERFLOW BYTE 'R2'.
3253   E726 6E          	LD	L,(HL)
3254   E727 2C          	INC	L
3255   E728 2D          	DEC	L
3256   E729 2E 06       	LD	L,6		; PREPARE FOR ERROR.
3257   E72B C2 8B E7    	JP	NZ,POSITN5	; OUT OF DISK SPACE ERROR.
3258   E72E 21 20 00    	LD	HL,32		; STORE RECORD NUMBER INTO FCB.
3259   E731 19          	ADD	HL,DE
3260   E732 77          	LD	(HL),A
3261   E733 21 0C 00    	LD	HL,12		; AND NOW CHECK THE EXTENT BYTE.
3262   E736 19          	ADD	HL,DE
3263   E737 79          	LD	A,C
3264   E738 96          	SUB	(HL)		; SAME EXTENT AS BEFORE?
3265   E739 C2 47 E7    	JP	NZ,POSITN2
3266   E73C 21 0E 00    	LD	HL,14		; YES, CHECK EXTRA EXTENT BYTE 'S2' ALSO.
3267   E73F 19          	ADD	HL,DE
3268   E740 78          	LD	A,B
3269   E741 96          	SUB	(HL)
3270   E742 E6 7F       	AND	7FH
3271   E744 CA 7F E7    	JP	Z,POSITN3	; SAME, WE ARE ALMOST DONE THEN.
3272   E747             ;
3273   E747             ;  GET HERE WHEN ANOTHER EXTENT IS REQUIRED.
3274   E747             ;
3275   E747 C5          POSITN2:PUSH	BC
3276   E748 D5          	PUSH	DE
3277   E749 CD A2 E4    	CALL	CLOSEIT		; CLOSE CURRENT EXTENT.
3278   E74C D1          	POP	DE
3279   E74D C1          	POP	BC
3280   E74E 2E 03       	LD	L,3		; PREPARE FOR ERROR.
3281   E750 3A 45 DF    	LD	A,(STATUS)
3282   E753 3C          	INC	A
3283   E754 CA 84 E7    	JP	Z,POSITN4	; CLOSE ERROR.
3284   E757 21 0C 00    	LD	HL,12		; PUT DESIRED EXTENT INTO FCB NOW.
3285   E75A 19          	ADD	HL,DE
3286   E75B 71          	LD	(HL),C
3287   E75C 21 0E 00    	LD	HL,14		; AND STORE EXTRA EXTENT BYTE 'S2'.
3288   E75F 19          	ADD	HL,DE
3289   E760 70          	LD	(HL),B
3290   E761 CD 51 E4    	CALL	OPENIT		; TRY AND GET THIS EXTENT.
3291   E764 3A 45 DF    	LD	A,(STATUS)	; WAS IT THERE?
3292   E767 3C          	INC	A
3293   E768 C2 7F E7    	JP	NZ,POSITN3
3294   E76B C1          	POP	BC		; NO. CAN WE CREATE A NEW ONE (WRITING?).
3295   E76C C5          	PUSH	BC
3296   E76D 2E 04       	LD	L,4		; PREPARE FOR ERROR.
3297   E76F 0C          	INC	C
3298   E770 CA 84 E7    	JP	Z,POSITN4	; NOPE, READING UNWRITTEN SPACE ERROR.
3299   E773 CD 24 E5    	CALL	GETEMPTY	; YES WE CAN, TRY TO FIND SPACE.
3300   E776 2E 05       	LD	L,5		; PREPARE FOR ERROR.
3301   E778 3A 45 DF    	LD	A,(STATUS)
3302   E77B 3C          	INC	A
3303   E77C CA 84 E7    	JP	Z,POSITN4	; OUT OF SPACE?
3304   E77F             ;
3305   E77F             ;   NORMAL RETURN LOCATION. CLEAR ERROR CODE AND RETURN.
3306   E77F             ;
3307   E77F C1          POSITN3:POP	BC		; RESTORE STACK.
3308   E780 AF          	XOR	A		; AND CLEAR ERROR CODE BYTE.
3309   E781 C3 01 DF    	JP	SETSTAT
3310   E784             ;
3311   E784             ;   ERROR. SET THE 'S2' BYTE TO INDICATE THIS (WHY?).
3312   E784             ;
3313   E784 E5          POSITN4:PUSH	HL
3314   E785 CD 69 E1    	CALL	GETS2
3315   E788 36 C0       	LD	(HL),0C0H
3316   E78A E1          	POP	HL
3317   E78B             ;
3318   E78B             ;   RETURN WITH ERROR CODE (PRESENTLY IN L).
3319   E78B             ;
3320   E78B C1          POSITN5:POP	BC
3321   E78C 7D          	LD	A,L		; GET ERROR CODE.
3322   E78D 32 45 DF    	LD	(STATUS),A
3323   E790 C3 78 E1    	JP	SETS2B7
3324   E793             ;
3325   E793             ;   READ A RANDOM RECORD.
3326   E793             ;
3327   E793 0E FF       READRAN:LD	C,0FFH		; SET 'READ' STATUS.
3328   E795 CD 03 E7    	CALL	POSITION	; POSITION THE FILE TO PROPER RECORD.
3329   E798 CC C1 E5    	CALL	Z,RDSEQ1	; AND READ IT AS USUAL (IF NO ERRORS).
3330   E79B C9          	RET
3331   E79C             ;
3332   E79C             ;   WRITE TO A RANDOM RECORD.
3333   E79C             ;
3334   E79C             WRITERAN:
3335   E79C 0E 00       	LD	C,0		; SET 'WRITING' FLAG.
3336   E79E CD 03 E7    	CALL	POSITION	; POSITION THE FILE TO PROPER RECORD.
3337   E7A1 CC 03 E6    	CALL	Z,WTSEQ1	; AND WRITE AS USUAL (IF NO ERRORS).
3338   E7A4 C9          	RET
3339   E7A5             ;
3340   E7A5             ;   COMPUTE THE RANDOM RECORD NUMBER. ENTER WITH (HL) POINTING
3341   E7A5             ; TO A FCB AN (DE) CONTAINS A RELATIVE LOCATION OF A RECORD
3342   E7A5             ; NUMBER. ON EXIT, (C) CONTAINS THE 'R0' BYTE, (B) THE 'R1'
3343   E7A5             ; BYTE, AND (A) THE 'R2' BYTE.
3344   E7A5             ;
3345   E7A5             ;   ON RETURN, THE ZERO FLAG IS SET IF THE RECORD IS WITHIN
3346   E7A5             ; BOUNDS. OTHERWISE, AN OVERFLOW OCCURED.
3347   E7A5             ;
3348   E7A5             COMPRAND:
3349   E7A5 EB          	EX	DE,HL		; SAVE FCB POINTER IN (DE).
3350   E7A6 19          	ADD	HL,DE		; COMPUTE RELATIVE POSITION OF RECORD #.
3351   E7A7 4E          	LD	C,(HL)		; GET RECORD NUMBER INTO (BC).
3352   E7A8 06 00       	LD	B,0
3353   E7AA 21 0C 00    	LD	HL,12		; NOW GET EXTENT.
3354   E7AD 19          	ADD	HL,DE
3355   E7AE 7E          	LD	A,(HL)		; COMPUTE (BC)=(RECORD #)+(EXTENT)*128.
3356   E7AF 0F          	RRCA			; MOVE LOWER BIT INTO BIT 7.
3357   E7B0 E6 80       	AND	80H		; AND IGNORE ALL OTHER BITS.
3358   E7B2 81          	ADD	A,C		; ADD TO OUR RECORD NUMBER.
3359   E7B3 4F          	LD	C,A
3360   E7B4 3E 00       	LD	A,0		; TAKE CARE OF ANY CARRY.
3361   E7B6 88          	ADC	A,B
3362   E7B7 47          	LD	B,A
3363   E7B8 7E          	LD	A,(HL)		; NOW GET THE UPPER BITS OF EXTENT INTO
3364   E7B9 0F          	RRCA			; BIT POSITIONS 0-3.
3365   E7BA E6 0F       	AND	0FH		; AND IGNORE ALL OTHERS.
3366   E7BC 80          	ADD	A,B		; ADD THIS IN TO 'R1' BYTE.
3367   E7BD 47          	LD	B,A
3368   E7BE 21 0E 00    	LD	HL,14		; GET THE 'S2' BYTE (EXTRA EXTENT).
3369   E7C1 19          	ADD	HL,DE
3370   E7C2 7E          	LD	A,(HL)
3371   E7C3 87          	ADD	A,A		; AND SHIFT IT LEFT 4 BITS (BITS 4-7).
3372   E7C4 87          	ADD	A,A
3373   E7C5 87          	ADD	A,A
3374   E7C6 87          	ADD	A,A
3375   E7C7 F5          	PUSH	AF		; SAVE CARRY FLAG (BIT 0 OF FLAG BYTE).
3376   E7C8 80          	ADD	A,B		; NOW ADD EXTRA EXTENT INTO 'R1'.
3377   E7C9 47          	LD	B,A
3378   E7CA F5          	PUSH	AF		; AND SAVE CARRY (OVERFLOW BYTE 'R2').
3379   E7CB E1          	POP	HL		; BIT 0 OF (L) IS THE OVERFLOW INDICATOR.
3380   E7CC 7D          	LD	A,L
3381   E7CD E1          	POP	HL		; AND SAME FOR FIRST CARRY FLAG.
3382   E7CE B5          	OR	L		; EITHER ONE OF THESE SET?
3383   E7CF E6 01       	AND	01H		; ONLY CHECK THE CARRY FLAGS.
3384   E7D1 C9          	RET
3385   E7D2             ;
3386   E7D2             ;   ROUTINE TO SETUP THE FCB (BYTES 'R0', 'R1', 'R2') TO
3387   E7D2             ; REFLECT THE LAST RECORD USED FOR A RANDOM (OR OTHER) FILE.
3388   E7D2             ; THIS READS THE DIRECTORY AND LOOKS AT ALL EXTENTS COMPUTING
3389   E7D2             ; THE LARGERST RECORD NUMBER FOR EACH AND KEEPING THE MAXIMUM
3390   E7D2             ; VALUE ONLY. THEN 'R0', 'R1', AND 'R2' WILL REFLECT THIS
3391   E7D2             ; MAXIMUM RECORD NUMBER. THIS IS USED TO COMPUTE THE SPACE USED
3392   E7D2             ; BY A RANDOM FILE.
3393   E7D2             ;
3394   E7D2 0E 0C       RANSIZE:LD	C,12		; LOOK THRU DIRECTORY FOR FIRST ENTRY WITH
3395   E7D4 CD 18 E3    	CALL	FINDFST		; THIS NAME.
3396   E7D7 2A 43 DF    	LD	HL,(PARAMS)	; ZERO OUT THE 'R0, R1, R2' BYTES.
3397   E7DA 11 21 00    	LD	DE,33
3398   E7DD 19          	ADD	HL,DE
3399   E7DE E5          	PUSH	HL
3400   E7DF 72          	LD	(HL),D		; NOTE THAT (D)=0.
3401   E7E0 23          	INC	HL
3402   E7E1 72          	LD	(HL),D
3403   E7E2 23          	INC	HL
3404   E7E3 72          	LD	(HL),D
3405   E7E4 CD F5 E1    RANSIZ1:CALL	CKFILPOS	; IS THERE AN EXTENT TO PROCESS?
3406   E7E7 CA 0C E8    	JP	Z,RANSIZ3	; NO, WE ARE DONE.
3407   E7EA CD 5E E1    	CALL	FCB2HL		; SET (HL) POINTING TO PROPER FCB IN DIR.
3408   E7ED 11 0F 00    	LD	DE,15		; POINT TO LAST RECORD IN EXTENT.
3409   E7F0 CD A5 E7    	CALL	COMPRAND	; AND COMPUTE RANDOM PARAMETERS.
3410   E7F3 E1          	POP	HL
3411   E7F4 E5          	PUSH	HL		; NOW CHECK THESE VALUES AGAINST THOSE
3412   E7F5 5F          	LD	E,A		; ALREADY IN FCB.
3413   E7F6 79          	LD	A,C		; THE CARRY FLAG WILL BE SET IF THOSE
3414   E7F7 96          	SUB	(HL)		; IN THE FCB REPRESENT A LARGER SIZE THAN
3415   E7F8 23          	INC	HL		; THIS EXTENT DOES.
3416   E7F9 78          	LD	A,B
3417   E7FA 9E          	SBC	A,(HL)
3418   E7FB 23          	INC	HL
3419   E7FC 7B          	LD	A,E
3420   E7FD 9E          	SBC	A,(HL)
3421   E7FE DA 06 E8    	JP	C,RANSIZ2
3422   E801 73          	LD	(HL),E		; WE FOUND A LARGER (IN SIZE) EXTENT.
3423   E802 2B          	DEC	HL		; STUFF THESE VALUES INTO FCB.
3424   E803 70          	LD	(HL),B
3425   E804 2B          	DEC	HL
3426   E805 71          	LD	(HL),C
3427   E806 CD 2D E3    RANSIZ2:CALL	FINDNXT		; NOW GET THE NEXT EXTENT.
3428   E809 C3 E4 E7    	JP	RANSIZ1		; CONTINUE TIL ALL DONE.
3429   E80C E1          RANSIZ3:POP	HL		; WE ARE DONE, RESTORE THE STACK AND
3430   E80D C9          	RET			; RETURN.
3431   E80E             ;
3432   E80E             ;   FUNCTION TO RETURN THE RANDOM RECORD POSITION OF A GIVEN
3433   E80E             ; FILE WHICH HAS BEEN READ IN SEQUENTIAL MODE UP TO NOW.
3434   E80E             ;
3435   E80E 2A 43 DF    SETRAN:	LD	HL,(PARAMS)	; POINT TO FCB.
3436   E811 11 20 00    	LD	DE,32		; AND TO LAST USED RECORD.
3437   E814 CD A5 E7    	CALL	COMPRAND	; COMPUTE RANDOM POSITION.
3438   E817 21 21 00    	LD	HL,33		; NOW STUFF THESE VALUES INTO FCB.
3439   E81A 19          	ADD	HL,DE
3440   E81B 71          	LD	(HL),C		; MOVE 'R0'.
3441   E81C 23          	INC	HL
3442   E81D 70          	LD	(HL),B		; AND 'R1'.
3443   E81E 23          	INC	HL
3444   E81F 77          	LD	(HL),A		; AND LASTLY 'R2'.
3445   E820 C9          	RET
3446   E821             ;
3447   E821             ;   THIS ROUTINE SELECT THE DRIVE SPECIFIED IN (ACTIVE) AND
3448   E821             ; UPDATE THE LOGIN VECTOR AND BITMAP TABLE IF THIS DRIVE WAS
3449   E821             ; NOT ALREADY ACTIVE.
3450   E821             ;
3451   E821             LOGINDRV:
3452   E821 2A AF E9    	LD	HL,(LOGIN)	; GET THE LOGIN VECTOR.
3453   E824 3A 42 DF    	LD	A,(ACTIVE)	; GET THE DEFAULT DRIVE.
3454   E827 4F          	LD	C,A
3455   E828 CD EA E0    	CALL	SHIFTR		; POSITION ACTIVE BIT FOR THIS DRIVE
3456   E82B E5          	PUSH	HL		; INTO BIT 0.
3457   E82C EB          	EX	DE,HL
3458   E82D CD 59 DF    	CALL	SELECT		; SELECT THIS DRIVE.
3459   E830 E1          	POP	HL
3460   E831 CC 47 DF    	CALL	Z,SLCTERR	; VALID DRIVE?
3461   E834 7D          	LD	A,L		; IS THIS A NEWLY ACTIVATED DRIVE?
3462   E835 1F          	RRA
3463   E836 D8          	RET	C
3464   E837 2A AF E9    	LD	HL,(LOGIN)	; YES, UPDATE THE LOGIN VECTOR.
3465   E83A 4D          	LD	C,L
3466   E83B 44          	LD	B,H
3467   E83C CD 0B E1    	CALL	SETBIT
3468   E83F 22 AF E9    	LD	(LOGIN),HL	; AND SAVE.
3469   E842 C3 A3 E2    	JP	BITMAP		; NOW UPDATE THE BITMAP.
3470   E845             ;
3471   E845             ;   FUNCTION TO SET THE ACTIVE DISK NUMBER.
3472   E845             ;
3473   E845 3A D6 E9    SETDSK:	LD	A,(EPARAM)	; GET PARAMETER PASSED AND SEE IF THIS
3474   E848 21 42 DF    	LD	HL,ACTIVE	; REPRESENTS A CHANGE IN DRIVES.
3475   E84B BE          	CP	(HL)
3476   E84C C8          	RET	Z
3477   E84D 77          	LD	(HL),A		; YES IT DOES, LOG IT IN.
3478   E84E C3 21 E8    	JP	LOGINDRV
3479   E851             ;
3480   E851             ;   THIS IS THE 'AUTO DISK SELECT' ROUTINE. THE FIRSST BYTE
3481   E851             ; OF THE FCB IS EXAMINED FOR A DRIVE SPECIFICATION. IF NON
3482   E851             ; ZERO THEN THE DRIVE WILL BE SELECTED AND LOGED IN.
3483   E851             ;
3484   E851 3E FF       AUTOSEL:LD	A,0FFH		; SAY 'AUTO-SELECT ACTIVATED'.
3485   E853 32 DE E9    	LD	(AUTO),A
3486   E856 2A 43 DF    	LD	HL,(PARAMS)	; GET DRIVE SPECIFIED.
3487   E859 7E          	LD	A,(HL)
3488   E85A E6 1F       	AND	1FH		; LOOK AT LOWER 5 BITS.
3489   E85C 3D          	DEC	A		; ADJUST FOR (1=A, 2=B) ETC.
3490   E85D 32 D6 E9    	LD	(EPARAM),A	; AND SAVE FOR THE SELECT ROUTINE.
3491   E860 FE 1E       	CP	1EH		; CHECK FOR 'NO CHANGE' CONDITION.
3492   E862 D2 75 E8    	JP	NC,AUTOSL1	; YES, DON'T CHANGE.
3493   E865 3A 42 DF    	LD	A,(ACTIVE)	; WE MUST CHANGE, SAVE CURRENTLY ACTIVE
3494   E868 32 DF E9    	LD	(OLDDRV),A	; DRIVE.
3495   E86B 7E          	LD	A,(HL)		; AND SAVE FIRST BYTE OF FCB ALSO.
3496   E86C 32 E0 E9    	LD	(AUTOFLAG),A	; THIS MUST BE NON-ZERO.
3497   E86F E6 E0       	AND	0E0H		; WHATS THIS FOR (BITS 6,7 ARE USED FOR
3498   E871 77          	LD	(HL),A		; SOMETHING)?
3499   E872 CD 45 E8    	CALL	SETDSK		; SELECT AND LOG IN THIS DRIVE.
3500   E875 3A 41 DF    AUTOSL1:LD	A,(USERNO)	; MOVE USER NUMBER INTO FCB.
3501   E878 2A 43 DF    	LD	HL,(PARAMS)	; (* UPPER HALF OF FIRST BYTE *)
3502   E87B B6          	OR	(HL)
3503   E87C 77          	LD	(HL),A
3504   E87D C9          	RET			; AND RETURN (ALL DONE).
3505   E87E             ;
3506   E87E             ;   FUNCTION TO RETURN THE CURRENT CP/M VERSION NUMBER.
3507   E87E             ;
3508   E87E 3E 22       GETVER:	LD	A,022H		; VERSION 2.2
3509   E880 C3 01 DF    	JP	SETSTAT
3510   E883             ;
3511   E883             ;   FUNCTION TO RESET THE DISK SYSTEM.
3512   E883             ;
3513   E883 21 00 00    RSTDSK:	LD	HL,0		; CLEAR WRITE PROTECT STATUS AND LOG
3514   E886 22 AD E9    	LD	(WRTPRT),HL	; IN VECTOR.
3515   E889 22 AF E9    	LD	(LOGIN),HL
3516   E88C AF          	XOR	A		; SELECT DRIVE 'A'.
3517   E88D 32 42 DF    	LD	(ACTIVE),A
3518   E890 21 80 00    	LD	HL,TBUFF	; SETUP DEFAULT DMA ADDRESS.
3519   E893 22 B1 E9    	LD	(USERDMA),HL
3520   E896 CD DA E1    	CALL	DEFDMA
3521   E899 C3 21 E8    	JP	LOGINDRV	; NOW LOG IN DRIVE 'A'.
3522   E89C             ;
3523   E89C             ;   FUNCTION TO OPEN A SPECIFIED FILE.
3524   E89C             ;
3525   E89C CD 72 E1    OPENFIL:CALL	CLEARS2		; CLEAR 'S2' BYTE.
3526   E89F CD 51 E8    	CALL	AUTOSEL		; SELECT PROPER DISK.
3527   E8A2 C3 51 E4    	JP	OPENIT		; AND OPEN THE FILE.
3528   E8A5             ;
3529   E8A5             ;   FUNCTION TO CLOSE A SPECIFIED FILE.
3530   E8A5             ;
3531   E8A5             CLOSEFIL:
3532   E8A5 CD 51 E8    	CALL	AUTOSEL		; SELECT PROPER DISK.
3533   E8A8 C3 A2 E4    	JP	CLOSEIT		; AND CLOSE THE FILE.
3534   E8AB             ;
3535   E8AB             ;   FUNCTION TO RETURN THE FIRST OCCURENCE OF A SPECIFIED FILE
3536   E8AB             ; NAME. IF THE FIRST BYTE OF THE FCB IS '?' THEN THE NAME WILL
3537   E8AB             ; NOT BE CHECKED (GET THE FIRST ENTRY NO MATTER WHAT).
3538   E8AB             ;
3539   E8AB 0E 00       GETFST:	LD	C,0		; PREPARE FOR SPECIAL SEARCH.
3540   E8AD EB          	EX	DE,HL
3541   E8AE 7E          	LD	A,(HL)		; IS FIRST BYTE A '?'?
3542   E8AF FE 3F       	CP	'?'
3543   E8B1 CA C2 E8    	JP	Z,GETFST1	; YES, JUST GET VERY FIRST ENTRY (ZERO LENGTH MATCH).
3544   E8B4 CD A6 E0    	CALL	SETEXT		; GET THE EXTENSION BYTE FROM FCB.
3545   E8B7 7E          	LD	A,(HL)		; IS IT '?'? IF YES, THEN WE WANT
3546   E8B8 FE 3F       	CP	'?'		; AN ENTRY WITH A SPECIFIC 'S2' BYTE.
3547   E8BA C4 72 E1    	CALL	NZ,CLEARS2	; OTHERWISE, LOOK FOR A ZERO 'S2' BYTE.
3548   E8BD CD 51 E8    	CALL	AUTOSEL		; SELECT PROPER DRIVE.
3549   E8C0 0E 0F       	LD	C,15		; COMPARE BYTES 0-14 IN FCB (12&13 EXCLUDED).
3550   E8C2 CD 18 E3    GETFST1:CALL	FINDFST		; FIND AN ENTRY AND THEN MOVE IT INTO
3551   E8C5 C3 E9 E1    	JP	MOVEDIR		; THE USERS DMA SPACE.
3552   E8C8             ;
3553   E8C8             ;   FUNCTION TO RETURN THE NEXT OCCURENCE OF A FILE NAME.
3554   E8C8             ;
3555   E8C8 2A D9 E9    GETNXT:	LD	HL,(SAVEFCB)	; RESTORE POINTERS. NOTE THAT NO
3556   E8CB 22 43 DF    	LD	(PARAMS),HL	; OTHER DBOS CALLS ARE ALLOWED.
3557   E8CE CD 51 E8    	CALL	AUTOSEL		; NO ERROR WILL BE RETURNED, BUT THE
3558   E8D1 CD 2D E3    	CALL	FINDNXT		; RESULTS WILL BE WRONG.
3559   E8D4 C3 E9 E1    	JP	MOVEDIR
3560   E8D7             ;
3561   E8D7             ;   FUNCTION TO DELETE A FILE BY NAME.
3562   E8D7             ;
3563   E8D7 CD 51 E8    DELFILE:CALL	AUTOSEL		; SELECT PROPER DRIVE.
3564   E8DA CD 9C E3    	CALL	ERAFILE		; ERASE THE FILE.
3565   E8DD C3 01 E3    	JP	STSTATUS	; SET STATUS AND RETURN.
3566   E8E0             ;
3567   E8E0             ;   FUNCTION TO EXECUTE A SEQUENTIAL READ OF THE SPECIFIED
3568   E8E0             ; RECORD NUMBER.
3569   E8E0             ;
3570   E8E0 CD 51 E8    READSEQ:CALL	AUTOSEL		; SELECT PROPER DRIVE THEN READ.
3571   E8E3 C3 BC E5    	JP	RDSEQ
3572   E8E6             ;
3573   E8E6             ;   FUNCTION TO WRITE THE NET SEQUENTIAL RECORD.
3574   E8E6             ;
3575   E8E6 CD 51 E8    WRTSEQ:	CALL	AUTOSEL		; SELECT PROPER DRIVE THEN WRITE.
3576   E8E9 C3 FE E5    	JP	WTSEQ
3577   E8EC             ;
3578   E8EC             ;   CREATE A FILE FUNCTION.
3579   E8EC             ;
3580   E8EC CD 72 E1    FCREATE:CALL	CLEARS2		; CLEAR THE 'S2' BYTE ON ALL CREATES.
3581   E8EF CD 51 E8    	CALL	AUTOSEL		; SELECT PROPER DRIVE AND GET THE NEXT
3582   E8F2 C3 24 E5    	JP	GETEMPTY	; EMPTY DIRECTORY SPACE.
3583   E8F5             ;
3584   E8F5             ;   FUNCTION TO RENAME A FILE.
3585   E8F5             ;
3586   E8F5 CD 51 E8    RENFILE:CALL	AUTOSEL		; SELECT PROPER DRIVE AND THEN SWITCH
3587   E8F8 CD 16 E4    	CALL	CHGNAMES	; FILE NAMES.
3588   E8FB C3 01 E3    	JP	STSTATUS
3589   E8FE             ;
3590   E8FE             ;   FUNCTION TO RETURN THE LOGIN VECTOR.
3591   E8FE             ;
3592   E8FE 2A AF E9    GETLOG:	LD	HL,(LOGIN)
3593   E901 C3 29 E9    	JP	GETPRM1
3594   E904             ;
3595   E904             ;   FUNCTION TO RETURN THE CURRENT DISK ASSIGNMENT.
3596   E904             ;
3597   E904 3A 42 DF    GETCRNT:LD	A,(ACTIVE)
3598   E907 C3 01 DF    	JP	SETSTAT
3599   E90A             ;
3600   E90A             ;   FUNCTION TO SET THE DMA ADDRESS.
3601   E90A             ;
3602   E90A EB          PUTDMA:	EX	DE,HL
3603   E90B 22 B1 E9    	LD	(USERDMA),HL	; SAVE IN OUR SPACE AND THEN GET TO
3604   E90E C3 DA E1    	JP	DEFDMA		; THE BIOS WITH THIS ALSO.
3605   E911             ;
3606   E911             ;   FUNCTION TO RETURN THE ALLOCATION VECTOR.
3607   E911             ;
3608   E911 2A BF E9    GETALOC:LD	HL,(ALOCVECT)
3609   E914 C3 29 E9    	JP	GETPRM1
3610   E917             ;
3611   E917             ;   FUNCTION TO RETURN THE READ-ONLY STATUS VECTOR.
3612   E917             ;
3613   E917 2A AD E9    GETROV:	LD	HL,(WRTPRT)
3614   E91A C3 29 E9    	JP	GETPRM1
3615   E91D             ;
3616   E91D             ;   FUNCTION TO SET THE FILE ATTRIBUTES (READ-ONLY, SYSTEM).
3617   E91D             ;
3618   E91D CD 51 E8    SETATTR:CALL	AUTOSEL		; SELECT PROPER DRIVE THEN SAVE ATTRIBUTES.
3619   E920 CD 3B E4    	CALL	SAVEATTR
3620   E923 C3 01 E3    	JP	STSTATUS
3621   E926             ;
3622   E926             ;   FUNCTION TO RETURN THE ADDRESS OF THE DISK PARAMETER BLOCK
3623   E926             ; FOR THE CURRENT DRIVE.
3624   E926             ;
3625   E926 2A BB E9    GETPARM:LD	HL,(DISKPB)
3626   E929 22 45 DF    GETPRM1:LD	(STATUS),HL
3627   E92C C9          	RET
3628   E92D             ;
3629   E92D             ;   FUNCTION TO GET OR SET THE USER NUMBER. IF (E) WAS (FF)
3630   E92D             ; THEN THIS IS A REQUEST TO RETURN THE CURRENT USER NUMBER.
3631   E92D             ; ELSE SET THE USER NUMBER FROM (E).
3632   E92D             ;
3633   E92D 3A D6 E9    GETUSER:LD	A,(EPARAM)	; GET PARAMETER.
3634   E930 FE FF       	CP	0FFH		; GET USER NUMBER?
3635   E932 C2 3B E9    	JP	NZ,SETUSER
3636   E935 3A 41 DF    	LD	A,(USERNO)	; YES, JUST DO IT.
3637   E938 C3 01 DF    	JP	SETSTAT
3638   E93B E6 1F       SETUSER:AND	1FH		; NO, WE SHOULD SET IT INSTEAD. KEEP LOW
3639   E93D 32 41 DF    	LD	(USERNO),A	; BITS (0-4) ONLY.
3640   E940 C9          	RET
3641   E941             ;
3642   E941             ;   FUNCTION TO READ A RANDOM RECORD FROM A FILE.
3643   E941             ;
3644   E941             RDRANDOM:
3645   E941 CD 51 E8    	CALL	AUTOSEL		; SELECT PROPER DRIVE AND READ.
3646   E944 C3 93 E7    	JP	READRAN
3647   E947             ;
3648   E947             ;   FUNCTION TO COMPUTE THE FILE SIZE FOR RANDOM FILES.
3649   E947             ;
3650   E947             WTRANDOM:
3651   E947 CD 51 E8    	CALL	AUTOSEL		; SELECT PROPER DRIVE AND WRITE.
3652   E94A C3 9C E7    	JP	WRITERAN
3653   E94D             ;
3654   E94D             ;   FUNCTION TO COMPUTE THE SIZE OF A RANDOM FILE.
3655   E94D             ;
3656   E94D             FILESIZE:
3657   E94D CD 51 E8    	CALL	AUTOSEL		; SELECT PROPER DRIVE AND CHECK FILE LENGTH
3658   E950 C3 D2 E7    	JP	RANSIZE
3659   E953             ;
3660   E953             ;   FUNCTION #37. THIS ALLOWS A PROGRAM TO LOG OFF ANY DRIVES.
3661   E953             ; ON ENTRY, SET (DE) TO CONTAIN A WORD WITH BITS SET FOR THOSE
3662   E953             ; DRIVES THAT ARE TO BE LOGGED OFF. THE LOG-IN VECTOR AND THE
3663   E953             ; WRITE PROTECT VECTOR WILL BE UPDATED. THIS MUST BE A M/PM
3664   E953             ; SPECIAL FUNCTION.
3665   E953             ;
3666   E953 2A 43 DF    LOGOFF:	LD	HL,(PARAMS)	; GET DRIVES TO LOG OFF.
3667   E956 7D          	LD	A,L		; FOR EACH BIT THAT IS SET, WE WANT
3668   E957 2F          	CPL			; TO CLEAR THAT BIT IN (LOGIN)
3669   E958 5F          	LD	E,A		; AND (WRTPRT).
3670   E959 7C          	LD	A,H
3671   E95A 2F          	CPL
3672   E95B 2A AF E9    	LD	HL,(LOGIN)	; RESET THE LOGIN VECTOR.
3673   E95E A4          	AND	H
3674   E95F 57          	LD	D,A
3675   E960 7D          	LD	A,L
3676   E961 A3          	AND	E
3677   E962 5F          	LD	E,A
3678   E963 2A AD E9    	LD	HL,(WRTPRT)
3679   E966 EB          	EX	DE,HL
3680   E967 22 AF E9    	LD	(LOGIN),HL	; AND SAVE.
3681   E96A 7D          	LD	A,L		; NOW DO THE WRITE PROTECT VECTOR.
3682   E96B A3          	AND	E
3683   E96C 6F          	LD	L,A
3684   E96D 7C          	LD	A,H
3685   E96E A2          	AND	D
3686   E96F 67          	LD	H,A
3687   E970 22 AD E9    	LD	(WRTPRT),HL	; AND SAVE. ALL DONE.
3688   E973 C9          	RET
3689   E974             ;
3690   E974             ;   GET HERE TO RETURN TO THE USER.
3691   E974             ;
3692   E974 3A DE E9    GOBACK:	LD	A,(AUTO)	; WAS AUTO SELECT ACTIVATED?
3693   E977 B7          	OR	A
3694   E978 CA 91 E9    	JP	Z,GOBACK1
3695   E97B 2A 43 DF    	LD	HL,(PARAMS)	; YES, BUT WAS A CHANGE MADE?
3696   E97E 36 00       	LD	(HL),0		; (* RESET FIRST BYTE OF FCB *)
3697   E980 3A E0 E9    	LD	A,(AUTOFLAG)
3698   E983 B7          	OR	A
3699   E984 CA 91 E9    	JP	Z,GOBACK1
3700   E987 77          	LD	(HL),A		; YES, RESET FIRST BYTE PROPERLY.
3701   E988 3A DF E9    	LD	A,(OLDDRV)	; AND GET THE OLD DRIVE AND SELECT IT.
3702   E98B 32 D6 E9    	LD	(EPARAM),A
3703   E98E CD 45 E8    	CALL	SETDSK
3704   E991 2A 0F DF    GOBACK1:LD	HL,(USRSTACK)	; RESET THE USERS STACK POINTER.
3705   E994 F9          	LD	SP,HL
3706   E995 2A 45 DF    	LD	HL,(STATUS)	; GET RETURN STATUS.
3707   E998 7D          	LD	A,L		; FORCE VERSION 1.4 COMPATABILITY.
3708   E999 44          	LD	B,H
3709   E99A C9          	RET			; AND GO BACK TO USER.
3710   E99B             ;
3711   E99B             ;   FUNCTION #40. THIS IS A SPECIAL ENTRY TO DO RANDOM I/O.
3712   E99B             ; FOR THE CASE WHERE WE ARE WRITING TO UNUSED DISK SPACE, THIS
3713   E99B             ; SPACE WILL BE ZEROED OUT FIRST. THIS MUST BE A M/PM SPECIAL
3714   E99B             ; PURPOSE FUNCTION, BECAUSE WHY WOULD ANY NORMAL PROGRAM EVEN
3715   E99B             ; CARE ABOUT THE PREVIOUS CONTENTS OF A SECTOR ABOUT TO BE
3716   E99B             ; WRITTEN OVER.
3717   E99B             ;
3718   E99B CD 51 E8    WTSPECL:CALL	AUTOSEL		; SELECT PROPER DRIVE.
3719   E99E 3E 02       	LD	A,2		; USE SPECIAL WRITE MODE.
3720   E9A0 32 D5 E9    	LD	(MODE),A
3721   E9A3 0E 00       	LD	C,0		; SET WRITE INDICATOR.
3722   E9A5 CD 07 E7    	CALL	POSITN1		; POSITION THE FILE.
3723   E9A8 CC 03 E6    	CALL	Z,WTSEQ1	; AND WRITE (IF NO ERRORS).
3724   E9AB C9          	RET
3725   E9AC             ;
3726   E9AC             ;**************************************************************
3727   E9AC             ;*
3728   E9AC             ;*     BDOS DATA STORAGE POOL.
3729   E9AC             ;*
3730   E9AC             ;**************************************************************
3731   E9AC             ;
3732   E9AC             EMPTYFCB:
3733   E9AC E5          	.DB 0E5H		; EMPTY DIRECTORY SEGMENT INDICATOR.
3734   E9AD 00 00       WRTPRT:	.DW 0			; WRITE PROTECT STATUS FOR ALL 16 DRIVES.
3735   E9AF 00 00       LOGIN:	.DW 0			; DRIVE ACTIVE WORD (1 BIT PER DRIVE).
3736   E9B1 80 00       USERDMA:.DW 080H		; USER'S DMA ADDRESS (DEFAULTS TO 80H).
3737   E9B3             ;
3738   E9B3             ;   SCRATCH AREAS FROM PARAMETER BLOCK.
3739   E9B3             ;
3740   E9B3             SCRATCH1:
3741   E9B3 00 00       	.DW 0			; RELATIVE POSITION WITHIN DIR SEGMENT FOR FILE (0-3).
3742   E9B5             SCRATCH2:
3743   E9B5 00 00       	.DW 0			; LAST SELECTED TRACK NUMBER.
3744   E9B7             SCRATCH3:
3745   E9B7 00 00       	.DW 0			; LAST SELECTED SECTOR NUMBER.
3746   E9B9             ;
3747   E9B9             ;   DISK STORAGE AREAS FROM PARAMETER BLOCK.
3748   E9B9             ;
3749   E9B9 00 00       DIRBUF:	.DW 0			; ADDRESS OF DIRECTORY BUFFER TO USE.
3750   E9BB 00 00       DISKPB:	.DW 0			; CONTAINS ADDRESS OF DISK PARAMETER BLOCK.
3751   E9BD 00 00       CHKVECT:.DW 0			; ADDRESS OF CHECK VECTOR.
3752   E9BF             ALOCVECT:
3753   E9BF 00 00       	.DW 0			; ADDRESS OF ALLOCATION VECTOR (BIT MAP).
3754   E9C1             ;
3755   E9C1             ;   PARAMETER BLOCK RETURNED FROM THE BIOS.
3756   E9C1             ;
3757   E9C1 00 00       SECTORS:.DW 0			; SECTORS PER TRACK FROM BIOS.
3758   E9C3 00          BLKSHFT:.DB 0			; BLOCK SHIFT.
3759   E9C4 00          BLKMASK:.DB 0			; BLOCK MASK.
3760   E9C5 00          EXTMASK:.DB 0			; EXTENT MASK.
3761   E9C6 00 00       DSKSIZE:.DW 0			; DISK SIZE FROM BIOS (NUMBER OF BLOCKS-1).
3762   E9C8 00 00       DIRSIZE:.DW 0			; DIRECTORY SIZE.
3763   E9CA 00 00       ALLOC0:	.DW 0			; STORAGE FOR FIRST BYTES OF BIT MAP (DIR SPACE USED).
3764   E9CC 00 00       ALLOC1:	.DW 0
3765   E9CE 00 00       OFFSET:	.DW 0			; FIRST USABLE TRACK NUMBER.
3766   E9D0 00 00       XLATE:	.DW 0			; SECTOR TRANSLATION TABLE ADDRESS.
3767   E9D2             ;
3768   E9D2             ;
3769   E9D2             CLOSEFLG:
3770   E9D2 00          	.DB 0			; CLOSE FLAG (=0FFH IS EXTENT WRITTEN OK).
3771   E9D3             RDWRTFLG:
3772   E9D3 00          	.DB 0			; READ/WRITE FLAG (0FFH=READ, 0=WRITE).
3773   E9D4 00          FNDSTAT:.DB 0			; FILENAME FOUND STATUS (0=FOUND FIRST ENTRY).
3774   E9D5 00          MODE:	.DB 0			; I/O MODE SELECT (0=RANDOM, 1=SEQUENTIAL, 2=SPECIAL RANDOM).
3775   E9D6 00          EPARAM:	.DB 0			; STORAGE FOR REGISTER (E) ON ENTRY TO BDOS.
3776   E9D7             RELBLOCK:
3777   E9D7 00          	.DB 0			; RELATIVE POSITION WITHIN FCB OF BLOCK NUMBER WRITTEN.
3778   E9D8 00          COUNTER:.DB 0			; BYTE COUNTER FOR DIRECTORY NAME SEARCHES.
3779   E9D9 00 00 00 00 SAVEFCB:.DW 0,0			; SAVE SPACE FOR ADDRESS OF FCB (FOR DIRECTORY SEARCHES).
3780   E9DD 00          BIGDISK:.DB 0			; IF =0 THEN DISK IS > 256 BLOCKS LONG.
3781   E9DE 00          AUTO:	.DB 0			; IF NON-ZERO, THEN AUTO SELECT ACTIVATED.
3782   E9DF 00          OLDDRV:	.DB 0			; ON AUTO SELECT, STORAGE FOR PREVIOUS DRIVE.
3783   E9E0             AUTOFLAG:
3784   E9E0 00          	.DB 0			; IF NON-ZERO, THEN AUTO SELECT CHANGED DRIVES.
3785   E9E1 00          SAVNXT:	.DB 0			; STORAGE FOR NEXT RECORD NUMBER TO ACCESS.
3786   E9E2 00          SAVEXT:	.DB 0			; STORAGE FOR EXTENT NUMBER OF FILE.
3787   E9E3 00 00       SAVNREC:.DW 0			; STORAGE FOR NUMBER OF RECORDS IN FILE.
3788   E9E5 00 00       BLKNMBR:.DW 0			; BLOCK NUMBER (PHYSICAL SECTOR) USED WITHIN A FILE OR LOGICAL SEC
3789   E9E7 00 00       LOGSECT:.DW 0			; STARTING LOGICAL (128 BYTE) SECTOR OF BLOCK (PHYSICAL SECTOR).
3790   E9E9 00          FCBPOS:	.DB 0			; RELATIVE POSITION WITHIN BUFFER FOR FCB OF FILE OF INTEREST.
3791   E9EA 00 00       FILEPOS:.DW 0			; FILES POSITION WITHIN DIRECTORY (0 TO MAX ENTRIES -1).
3792   E9EC             ;
3793   E9EC             ;   DISK DIRECTORY BUFFER CHECKSUM BYTES. ONE FOR EACH OF THE
3794   E9EC             ; 16 POSSIBLE DRIVES.
3795   E9EC             ;
3796   E9EC             CKSUMTBL:
3797   E9EC 00 00 00 00 	.DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3797   E9F0 00 00 00 00 
3797   E9F4 00 00 00 00 
3797   E9F8 00 00 00 00 
3798   E9FC             ;
3799   E9FC             ;   EXTRA SPACE ?
3800   E9FC             ;
3801   E9FC 00 00 00 00 	.DB 0,0,0,0
3802   EA00             ;
3803   EA00             ;**************************************************************
3804   EA00             ;*
3805   EA00             ;*        B I O S   J U M P   T A B L E
3806   EA00             ;*
3807   EA00             ;**************************************************************
3808   EA00             ;
3809   EA00             ;BOOT	JMP	0	;NOTE WE USE FAKE DESTINATIONS
3810   EA00             ;WBOOT	JMP	0
3811   EA00             ;CONST	JMP	0
3812   EA00             ;CONIN	JMP	0
3813   EA00             ;CONOUT	JMP	0
3814   EA00             ;LIST	JMP	0
3815   EA00             ;PUNCH	JMP	0
3816   EA00             ;READER	JMP	0
3817   EA00             ;HOME	JMP	0
3818   EA00             ;SELDSK	JMP	0
3819   EA00             ;SETTRK	JMP	0
3820   EA00             ;SETSEC	JMP	0
3821   EA00             ;SETDMA	JMP	0
3822   EA00             ;READ	JMP	0
3823   EA00             ;WRITE	JMP	0
3824   EA00             ;PRSTAT	JMP	0
3825   EA00             ;SECTRN	JMP	0
3826   EA00             ;
3827   EA00             ;*
3828   EA00             ;******************   E N D   O F   C P / M   *****************
3829   EA00             ;*
3830   EA00             
3831   EA00             ;	.END
3832   EA00             
3833   EA00             
3834   EA00             ;
3835   EA00             ;**************************************************************
3836   EA00             ;*
3837   EA00             ;*        C B I O S  f o r
3838   EA00             ;*
3839   EA00             ;*  T e s t   P r o t o t y p e
3840   EA00             ;*
3841   EA00             ;*  by Andrew Lynch, with input from many sources
3842   EA00             ;*
3843   EA00             ;**************************************************************
3844   EA00             ;
3845   EA00             ;	SKELETAL CBIOS FOR FIRST LEVEL OF CP/M 2.0 ALTERATION
3846   EA00             ;             WITH MODS FOR CP/M  ROMDISK AND RAMDISK.
3847   EA00             ;
3848   EA00             ;             ENTIRELY IN 8080 MNEUMONICS (SO ASM CAN BE USED)
3849   EA00             ;             BUT ASSUMES A Z80! (remove)
3850   EA00             ;
3851   EA00             ;MSIZE	.EQU	20			;CP/M VERSION MEMORY SIZE IN KILOBYTES
3852   EA00             ;MSIZE	.EQU	62			;CP/M VERSION MEMORY SIZE IN KILOBYTES
3853   EA00             ; MEM defined in CPM22 above, line 0015
3854   EA00             MSIZE:	.EQU MEM		; CP/M VERSION MEMORY SIZE IN KILOBYTES
3855   EA00             
3856   EA00             ;
3857   EA00             ;	"BIAS" IS ADDRESS OFFSET FROM 3400H FOR MEMORY SYSTEMS
3858   EA00             ;	THAN 16K (REFERRED TO AS "B" THROUGHOUT THE TEXT).
3859   EA00             ;
3860   EA00             BIAS:	.EQU (MSIZE-20)*1024
3861   EA00             CCP:	.EQU 3400H+BIAS		; BASE OF CCP
3862   EA00             BDOS:	.EQU CCP+806H		; BASE OF BDOS
3863   EA00             BIOS:	.EQU CCP+1600H		; BASE OF BIOS
3864   EA00             CDISK:	.EQU 0004H		; CURRENT DISK NUMBER 0=A,...,15=P
3865   EA00             ; IOBYTE already defined in CPM22 above, line 0017
3866   EA00             ;IOBYTE	.EQU	0003H			;INTEL I/O BYTE
3867   EA00             ;
3868   EA00             ;	CONSTANTS
3869   EA00             
3870   EA00             END:	.EQU $FF
3871   EA00             ;CR		.EQU	$0D
3872   EA00             ;LF		.EQU	$0A
3873   EA00             
3874   EA00             ; TEST PROTOTYPE SPECIFIC HARDWARE IO PORT ADDRESSES AND MEMORY LOCATIONS
3875   EA00             
3876   EA00             UART:		.EQU $68		; BASE IO ADDRESS OF UART
3877   EA00             MPCL_RAM:	.EQU $78		; BASE IO ADDRESS OF RAM MEMORY PAGER CONFIGURATION LATCH
3878   EA00             MPCL_ROM:	.EQU $7C		; BASE IO ADDRESS OF ROM MEMORY PAGER CONFIGURATION LATCH
3879   EA00             
3880   EA00             ROMSTART_MON:	.EQU $0100		; WHERE THE MONITOR IS STORED IN ROM
3881   EA00             RAMTARG_MON:	.EQU $F800		; WHERE THE MONITOR STARTS IN RAM (ENTRY POINT)
3882   EA00             MOVSIZ_MON:	.EQU $0800		; MONITOR IS 2KB IN LENGTH
3883   EA00             
3884   EA00             ROMSTART_CPM:	.EQU $0900		; WHERE THE CCP+BDOS+BIOS IS STORED IN ROM
3885   EA00             RAMTARG_CPM:	.EQU $D400		; WHERE THE CCP+BDOS+BIOS STARTS IN RAM (ENTRY POINT)
3886   EA00             MOVSIZ_CPM:	.EQU $2100		; CCP, BDOS, + BIOS IS 6-7KB IN LENGTH
3887   EA00             
3888   EA00             ; IDE REGISTER		IO PORT		; FUNCTION
3889   EA00             IDELO:	.EQU $20		; DATA PORT (LOW BYTE)
3890   EA00             IDEERR:	.EQU $21		; READ: ERROR REGISTER; WRITE: PRECOMP
3891   EA00             IDESECTC:	.EQU $22		; SECTOR COUNT
3892   EA00             IDESECTN:	.EQU $23		; SECTOR NUMBER
3893   EA00             IDECYLLO:	.EQU $24		; CYLINDER LOW
3894   EA00             IDECYLHI:	.EQU $25		; CYLINDER HIGH
3895   EA00             IDEHEAD:	.EQU $26		; DRIVE/HEAD
3896   EA00             IDESTTS:	.EQU $27		; READ: STATUS; WRITE: COMMAND
3897   EA00             IDEHI:		.EQU $28		; DATA PORT (HIGH BYTE)
3898   EA00             IDECTRL:	.EQU $2E		; READ: ALTERNATIVE STATUS; WRITE; DEVICE CONTROL
3899   EA00             IDEADDR:	.EQU $2F		; DRIVE ADDRESS (READ ONLY)
3900   EA00             
3901   EA00             ;	.ORG	BIOS			;ORIGIN OF THIS PROGRAM
3902   EA00             NSECTS:	.EQU ($-CCP)/128	; WARM START SECTOR COUNT
3903   EA00             
3904   EA00             ;
3905   EA00             ;	JUMP VECTOR FOR INDIVIDUAL SUBROUTINES
3906   EA00 C3 CE EA    	JP	BOOT		; COLD START
3907   EA03 C3 E9 EA    WBOOTE:	JP	WBOOT		; WARM START
3908   EA06 C3 4B EB    	JP	CONST		; CONSOLE STATUS
3909   EA09 C3 55 EB    	JP	CONIN		; CONSOLE CHARACTER IN
3910   EA0C C3 60 EB    	JP	CONOUT		; CONSOLE CHARACTER OUT
3911   EA0F             ;	JMP	LIST			;LIST CHARACTER OUT (NULL ROUTINE)
3912   EA0F C9          LIST:	RET
3913   EA10 00          	NOP
3914   EA11 00          	NOP
3915   EA12             ;	JMP	PUNCH			;PUNCH CHARACTER OUT (NULL ROUTINE)
3916   EA12 C9          PUNCH:	RET
3917   EA13 00          	NOP
3918   EA14 00          	NOP
3919   EA15             ;	JMP	READER			;READER CHARACTER OUT (NULL ROUTINE)
3920   EA15 C9          READER:	RET
3921   EA16 00          	NOP
3922   EA17 00          	NOP
3923   EA18 C3 87 EB    	JP	HOME		; MOVE HEAD TO HOME POSITION
3924   EA1B C3 6E EB    	JP	SELDSK		; SELECT DISK
3925   EA1E C3 8A EB    	JP	SETTRK		; SET TRACK NUMBER
3926   EA21 C3 90 EB    	JP	SETSEC		; SET SECTOR NUMBER
3927   EA24 C3 99 EB    	JP	SETDMA		; SET DMA ADDRESS
3928   EA27 C3 9F EB    	JP	READ		; READ DISK
3929   EA2A C3 72 EC    	JP	WRITE		; WRITE DISK
3930   EA2D             ;	JMP	LISTST			;RETURN LIST STATUS (NULL ROUTINE)
3931   EA2D C9          LISTST:	RET
3932   EA2E 00          	NOP
3933   EA2F 00          	NOP
3934   EA30 C3 96 EB    	JP	SECTRN		; SECTOR TRANSLATE
3935   EA33             ;
3936   EA33             ;   FIXED DATA TABLES FOR ALL DRIVES
3937   EA33             ;   0= RAMDISK, 1=ROMDISK, 2=HDPART2, 3=HDPART3, AND 4=HDPART4
3938   EA33             
3939   EA33             ;disk parameter for disk 00 - swapped 00 and 01 N8VEM Oct 2008
3940   EA33 00 00 00 00 DPBASE:	.DW 0000,0000H
3941   EA37 00 00 00 00 	.DW 0000H,0000H
3942   EA3B 90 F0 92 EA 	.DW DIRBF,DPBLK1
3943   EA3F F4 F1 14 F1 	.DW CHK01,ALL01
3944   EA43             
3945   EA43             ; disk parameter for disk 01
3946   EA43 00 00 00 00 	.DW 00000,0000H
3947   EA47 00 00 00 00 	.DW 0000H,0000H
3948   EA4B 90 F0 83 EA 	.DW DIRBF,DPBLK0
3949   EA4F F4 F1 10 F1 	.DW CHK00,ALL00
3950   EA53             
3951   EA53             ;   DISK PARAMETER HEADER FOR DISK 02
3952   EA53 00 00 00 00 	.DW 0000,0000H
3953   EA57 00 00 00 00 	.DW 0000H,0000H
3954   EA5B 90 F0 A1 EA 	.DW DIRBF,DPBLK2
3955   EA5F F4 F1 34 F1 	.DW CHK02,ALL02
3956   EA63             ;   DISK PARAMETER HEADER FOR DISK 03
3957   EA63 00 00 00 00 	.DW 0000,0000H
3958   EA67 00 00 00 00 	.DW 0000H,0000H
3959   EA6B 90 F0 B0 EA 	.DW DIRBF,DPBLK3
3960   EA6F F4 F1 74 F1 	.DW CHK03,ALL03
3961   EA73             ;   DISK PARAMETER HEADER FOR DISK 04
3962   EA73 00 00 00 00 	.DW 0000,0000H
3963   EA77 00 00 00 00 	.DW 0000H,0000H
3964   EA7B 90 F0 BF EA 	.DW DIRBF,DPBLK4
3965   EA7F F4 F1 B4 F1 	.DW CHK04,ALL04
3966   EA83             ;
3967   EA83             ;DPBLK0:	;DISK PARAMETER BLOCK (ROMDISK 1MB) ** RESERVED FOR FUTURE EXPANSION *
3968   EA83             ;	SPT	.DW 	256		; 256 SECTORS OF 128 BYTES PER 32K TRACK
3969   EA83             ;	BSH	.DB 	2 		; BLOCK SHIFT FACTOR (SIZE OF ALLOCATION BLOCK)
3970   EA83             ;	BLM 	.DB 	15 		; PART OF THE ALLOCATION BLOCK SIZE MATH
3971   EA83             ;	EXM 	.DB 	1 		; DEFINES SIZE OF EXTENT (DIRECTORY INFO)
3972   EA83             ;	DSM 	.DW 	495 		; BLOCKSIZE [2048] * NUMBER OF BLOCKS +1 =DRIVE SIZE
3973   EA83             ;	DRM 	.DW 	255 		; NUMBER OF DIRECTORY ENTRIES
3974   EA83             ;	AL0 	.DB 	11110000  	; BIT MAP OF SPACE ALLOCATED TO DIRECTORY
3975   EA83             ;	AL1 	.DB 	00000000  	; DIRECTORY CAN HAVE UP TO 16 BLOCKS ALLOCATED
3976   EA83             ;	CKS 	.DW 	0 	  	; SIZE OF DIRECTORY CHECK [0 IF NON REMOVEABLE]
3977   EA83             ;	OFF 	.DW 	1 	  	; 1 TRACK RESERVED [FIRST 32K OF ROM]
3978   EA83             
3979   EA83             
3980   EA83             DPBLK0:				; DISK PARAMETER BLOCK (ROMDISK 32KB WITH 16 2K TRACKS, 22K usable)
3981   EA83 10 00       SPT_0:	.DW  16			; 16 SECTORS OF 128 BYTES PER 2K TRACK
3982   EA85 03          BSH_0:	.DB  3			; BLOCK SHIFT FACTOR (SIZE OF ALLOCATION BLOCK)
3983   EA86 07          BLM_0:	.DB  7			; PART OF THE ALLOCATION BLOCK SIZE MATH
3984   EA87 00          EXM_0:	.DB  0			; DEFINES SIZE OF EXTENT (DIRECTORY INFO)
3985   EA88 1F 00       DSM_0:	.DW  31			; BLOCKSIZE [1024] * NUMBER OF BLOCKS + 1 = DRIVE SIZE
3986   EA8A 1F 00       DRM_0:	.DW  31			; NUMBER OF DIRECTORY ENTRIES
3987   EA8C 80          AL0_0:	.DB  10000000		; BIT MAP OF SPACE ALLOCATED TO DIRECTORY
3988   EA8D 00          AL1_0:	.DB  00000000		; DIRECTORY CAN HAVE UP TO 16 BLOCKS ALLOCATED
3989   EA8E 00 00       CKS_0:	.DW  0			; SIZE OF DIRECTORY CHECK [0 IF NON REMOVEABLE]
3990   EA90 05 00       OFF_0:	.DW  5			; FIRST 5 TRACKS TRACKS RESERVED (10K FOR SYSTEM)
3991   EA92             				; SYSTEM IS ROM LOADER, CCP, BDOS, CBIOS, AND MONITOR
3992   EA92             				; 
3993   EA92             				; IMPORTANT NOTE: TRACKS $00 - $04 OF 2K BYTES
3994   EA92             				; EACH ARE MARKED WITH THE OFF_0 SET TO 5 AS 
3995   EA92             				; SYSTEM TRACKS. USABLE ROM DRIVE SPACE
3996   EA92             				; STARTING AFTER THE FIFTH TRACK (IE, TRACK $05)
3997   EA92             				; MOST LIKELY FIX TO THIS IS PLACING A DUMMY
3998   EA92             				; FIRST 10K ROM CONTAINS THE ROM LOADER, MONITOR,
3999   EA92             				; CCP, BDOS, BIOS, ETC (5 TRACKS * 2K EACH)
4000   EA92             
4001   EA92             DPBLK1:				; DISK PARAMETER BLOCK (RAMDISK 512K, 448K usable)
4002   EA92 00 01       SPT_1:	.DW  256		; 256 SECTORS OF 128 BYTES PER 32K TRACK
4003   EA94 04          BSH_1:	.DB  4			; BLOCK SHIFT FACTOR (SIZE OF ALLOCATION BLOCK)
4004   EA95 0F          BLM_1:	.DB  15			; PART OF THE ALLOCATION BLOCK SIZE MATH
4005   EA96 01          EXM_1:	.DB  1			; DEFINES SIZE OF EXTENT (DIRECTORY INFO)
4006   EA97 E1 00       DSM_1:	.DW  225		; BLOCKSIZE [2048] * NUMBER OF BLOCKS + 1 = DRIVE SIZE
4007   EA99 FF 00       DRM_1:	.DW  255		; NUMBER OF DIRECTORY ENTRIES
4008   EA9B 70          AL0_1:	.DB  11110000		; BIT MAP OF SPACE ALLOCATED TO DIRECTORY
4009   EA9C 00          AL1_1:	.DB  00000000		; DIRECTORY CAN HAVE UP TO 16 BLOCKS ALLOCATED
4010   EA9D 00 00       CKS_1:	.DW  0			; SIZE OF DIRECTORY CHECK [0 IF NON REMOVEABLE]
4011   EA9F 01 00       OFF_1:	.DW  1			; 1 TRACK RESERVED [FIRST 32K OF RAM]
4012   EAA1             
4013   EAA1             DPBLK2:				; DISK PARAMETER BLOCK (IDE HARD DISK 8MB)
4014   EAA1 00 01       SPT_2:	.DW  256		; 256 SECTORS OF 128 BYTES PER 32K TRACK
4015   EAA3 05          BSH_2:	.DB  5			; BLOCK SHIFT FACTOR (SIZE OF ALLOCATION BLOCK)
4016   EAA4 1F          BLM_2:	.DB  31			; PART OF THE ALLOCATION BLOCK SIZE MATH
4017   EAA5 01          EXM_2:	.DB  1			; DEFINES SIZE OF EXTENT (DIRECTORY INFO)
4018   EAA6 E1 07       DSM_2:	.DW  2017		; BLOCKSIZE [4096] * NUMBER OF BLOCKS + 1 = DRIVE SIZE
4019   EAA8             				; HD PARTITION 2 IS 16128 SECTORS LONG
4020   EAA8             				; AT 512 BYTES EACH WHICH IS 
4021   EAA8             				; 2016 BLOCKS AT 4096 BYTES A PIECE.
4022   EAA8 FF 01       DRM_2:	.DW  511		; NUMBER OF DIRECTORY ENTRIES
4023   EAAA 70          AL0_2:	.DB  11110000		; BIT MAP OF SPACE ALLOCATED TO DIRECTORY
4024   EAAB 00          AL1_2:	.DB  00000000		; DIRECTORY CAN HAVE UP TO 16 BLOCKS ALLOCATED
4025   EAAC 00 00       CKS_2:	.DW  0			; SIZE OF DIRECTORY CHECK [0 IF NON REMOVEABLE]
4026   EAAE 01 00       OFF_2:	.DW  1			; 1 TRACK (32K) RESERVED FOR SYSTEM
4027   EAB0             
4028   EAB0             DPBLK3:				; DISK PARAMETER BLOCK (IDE HARD DISK 8MB)
4029   EAB0 00 01       SPT_3:	.DW  256		; 256 SECTORS OF 128 BYTES PER 32K TRACK
4030   EAB2 05          BSH_3:	.DB  5			; BLOCK SHIFT FACTOR (SIZE OF ALLOCATION BLOCK)
4031   EAB3 1F          BLM_3:	.DB  31			; PART OF THE ALLOCATION BLOCK SIZE MATH
4032   EAB4 01          EXM_3:	.DB  1			; DEFINES SIZE OF EXTENT (DIRECTORY INFO)
4033   EAB5 E1 07       DSM_3:	.DW  2017		; BLOCKSIZE [4096] * NUMBER OF BLOCKS + 1 = DRIVE SIZE
4034   EAB7             				; HD PARTITION 3 IS 16128 SECTORS LONG
4035   EAB7             				; AT 512 BYTES EACH WHICH IS 
4036   EAB7             				; 2016 BLOCKS AT 4096 BYTES A PIECE.
4037   EAB7 FF 01       DRM_3:	.DW  511		; NUMBER OF DIRECTORY ENTRIES
4038   EAB9 70          AL0_3:	.DB  11110000		; BIT MAP OF SPACE ALLOCATED TO DIRECTORY
4039   EABA 00          AL1_3:	.DB  00000000		; DIRECTORY CAN HAVE UP TO 16 BLOCKS ALLOCATED
4040   EABB 00 00       CKS_3:	.DW  0			; SIZE OF DIRECTORY CHECK [0 IF NON REMOVEABLE]
4041   EABD 01 00       OFF_3:	.DW  1			; 1 TRACK (32K) RESERVED FOR SYSTEM
4042   EABF             
4043   EABF             DPBLK4:				; DISK PARAMETER BLOCK (IDE HARD DISK 1024K)
4044   EABF 00 01       SPT_4:	.DW  256		; 256 SECTORS OF 128 BYTES PER 32K TRACK
4045   EAC1 04          BSH_4:	.DB  4			; BLOCK SHIFT FACTOR (SIZE OF ALLOCATION BLOCK)
4046   EAC2 0F          BLM_4:	.DB  15			; PART OF THE ALLOCATION BLOCK SIZE MATH
4047   EAC3 00          EXM_4:	.DB  0			; DEFINES SIZE OF EXTENT (DIRECTORY INFO)
4048   EAC4 F1 01       DSM_4:	.DW  497		; BLOCKSIZE [2048] * NUMBER OF BLOCKS + 1 = DRIVE SIZE
4049   EAC6             				; HD PARTITION 4 IS 4032 SECTORS LONG
4050   EAC6             				; AT 512 BYTES EACH WHICH IS 
4051   EAC6             				; 1008 BLOCKS AT 2048 BYTES A PIECE.
4052   EAC6             				; NOT USING ALL OF THE AVAILABLE SECTORS SINCE THIS
4053   EAC6             				; DRIVE IS INTENDED TO EMULATE A ROM DRIVE AND COPIED
4054   EAC6             				; INTO A ROM IN THE FUTURE.
4055   EAC6 FF 00       DRM_4:	.DW  255		; NUMBER OF DIRECTORY ENTRIES
4056   EAC8 70          AL0_4:	.DB  11110000		; BIT MAP OF SPACE ALLOCATED TO DIRECTORY
4057   EAC9 00          AL1_4:	.DB  00000000		; DIRECTORY CAN HAVE UP TO 16 BLOCKS ALLOCATED
4058   EACA 00 00       CKS_4:	.DW  0			; SIZE OF DIRECTORY CHECK [0 IF NON REMOVEABLE]
4059   EACC 01 00       OFF_4:	.DW  1			; 1 TRACK RESERVED [FIRST 32K OF PARTITION]
4060   EACE             
4061   EACE             ;
4062   EACE             ;	END OF FIXED TABLES
4063   EACE             ;
4064   EACE             ;	INDIVIDUAL SUBROUTINES TO PERFORM EACH FUNCTION
4065   EACE             
4066   EACE             BOOT:				; SIMPLEST CASE IS TO JUST PERFORM PARAMETER INITIALIZATION
4067   EACE 3E 80       	LD	A,$80		; LOAD VALUE TO SWITCH OUT ROM
4068   EAD0 D3 7C       	OUT	(MPCL_ROM),A	; SWITCH OUT ROM, BRING IN LOWER 32K RAM PAGE
4069   EAD2             
4070   EAD2 3E 00       	LD	A,$00		; ENSURE LOWEST RAM PAGE SELECTED
4071   EAD4 D3 78       	OUT	(MPCL_RAM),A	; BRING IN LOWEST 32K RAM PAGE
4072   EAD6             
4073   EAD6 AF          	XOR	A		; ZERO IN THE ACCUM
4074   EAD7 32 03 00    	LD	(IOBYTE),A	; CLEAR THE IOBYTE
4075   EADA 32 04 00    	LD	(CDISK),A	; SELECT DISK ZERO
4076   EADD             	
4077   EADD CD E1 ED    	CALL	IDE_SOFT_RESET	; RESET THE IDE HARD DISK
4078   EAE0             
4079   EAE0 21 25 F2    	LD	HL,TXT_COLD	; PRINT STARTUP MESSAGE
4080   EAE3 CD 25 ED    	CALL	PRTMSG
4081   EAE6 C3 1F EB    	JP	GOCPM		; INITIALIZE AND GO TO CP/M
4082   EAE9             
4083   EAE9             ;
4084   EAE9             WBOOT:				; SIMPLEST CASE IS TO READ THE DISK UNTIL ALL SECTORS LOADED
4085   EAE9             				; WITH A ROMDISK WE SELECT THE ROM AND THE CORRECT PAGE [0]
4086   EAE9             				; THEN COPY THE CP/M IMAGE (CCP, BDOS, BIOS, MONITOR) TO HIGH RAM
4087   EAE9             				; LOAD ADDRESS.
4088   EAE9             				; FOR Z80 IT LOOKS LIKE THIS... USING 8080 NEMONICS
4089   EAE9             
4090   EAE9 F3          	DI			; DISABLE INTERRUPT
4091   EAEA 31 80 00    	LD	SP,80H		; USE SPACE BELOW BUFFER FOR STACK
4092   EAED             ;	IM	1			; SET INTERRUPT MODE 1
4093   EAED ED 56       IM_1:	.DB $ED,$56		; Z80 "IM 1" INSTRUCTION
4094   EAEF             
4095   EAEF AF          	XOR	A		; CHEAP ZERO IN ACC
4096   EAF0 D3 7C       	OUT	(MPCL_ROM),A	; SEND 0 TO ROM MAP PORT (SWITCH IN LOWER 32K ROM PAGE)
4097   EAF2             
4098   EAF2 AF          	XOR	A		; CHEAP ZERO IN ACC
4099   EAF3 D3 78       	OUT	(MPCL_RAM),A	; SEND 0 TO RAM MAP PORT (SELECT LOWEST RAM PAGE)
4100   EAF5             
4101   EAF5 21 00 01    	LD	HL,ROMSTART_MON	; WHERE IN ROM MONITOR IS STORED (FIRST BYTE)
4102   EAF8 11 00 F8    	LD	DE,RAMTARG_MON	; WHERE IN RAM TO MOVE MONITOR TO (FIRST BYTE)
4103   EAFB 01 00 08    	LD	BC,MOVSIZ_MON	; NUMBER OF BYTES TO MOVE FROM ROM TO RAM
4104   EAFE ED B0       LDIR1:	.DB $ED,$B0		; Z80 "LDIR" INSTRUCTION (REMOVE)
4105   EB00             ;	CALL	LDIR			; LDIR REPLACEMENT SUBROUTINE
4106   EB00             
4107   EB00 21 00 09    	LD	HL,ROMSTART_CPM	; WHERE IN ROM CP/M IS STORED (FIRST BYTE)
4108   EB03 11 00 D4    	LD	DE,RAMTARG_CPM	; WHERE IN RAM TO MOVE MONITOR TO (FIRST BYTE)
4109   EB06 01 00 21    	LD	BC,MOVSIZ_CPM	; NUMBER OF BYTES TO MOVE FROM ROM TO RAM
4110   EB09 ED B0       LDIR2:	.DB $ED,$B0		; Z80 "LDIR" INSTRUCTION (REMOVE)
4111   EB0B             ;	CALL	LDIR			; LDIR REPLACEMENT SUBROUTINE
4112   EB0B             
4113   EB0B FB          	EI			; ENABLE INTERRUPTS (ACCESS TO MONITOR WHILE
4114   EB0C             				; CP/M RUNNING)
4115   EB0C 3E 80       	LD	A,$80		; LOAD VALUE TO SWITCH OUT ROM
4116   EB0E D3 7C       	OUT	(MPCL_ROM),A	; SWITCH OUT ROM, BRING IN LOWER 32K RAM PAGE
4117   EB10             
4118   EB10 AF          	XOR	A		; CHEAP ZERO IN ACC
4119   EB11 D3 78       	OUT	(MPCL_RAM),A	; SEND 0 TO RAM MAP PORT (SELECT LOWEST RAM PAGE)
4120   EB13             
4121   EB13 CD E1 ED    	CALL	IDE_SOFT_RESET	; RESET THE IDE HARD DISK
4122   EB16 CD 72 EE    	CALL	CLEAR_AUTOEXEC	; N8VEM reset the autorun counter to zero so only runs on
4123   EB19 21 16 F2    	LD	HL,TXT_STARTUP_MSG ; PRINT STARTUP MESSAGE
4124   EB1C CD 25 ED    	CALL	PRTMSG
4125   EB1F             				; FALL THROUGH TO GOCPM ROUTINE
4126   EB1F             
4127   EB1F             ;	END OF LOAD OPERATION, SET PARAMETERS AND GO TO CP/M
4128   EB1F             GOCPM:
4129   EB1F             				; CPU RESET HANDLER
4130   EB1F 3E C3       	LD	A,0C3H		; C3 IS A JMP INSTRUCTION
4131   EB21 32 00 00    	LD	($0000),A	; FOR JMP TO WBOOT
4132   EB24 21 03 EA    	LD	HL,WBOOTE	; WBOOT ENTRY POINT
4133   EB27 22 01 00    	LD	(1),HL		; SET ADDRESS FIELD FOR JMP AT 0
4134   EB2A             ;
4135   EB2A             				; CPU INTERRUPT HANDLER
4136   EB2A 3E C3       	LD	A,0C3H		; C3 IS A JMP INSTRUCTION
4137   EB2C 32 38 00    	LD	($0038),A	; FOR JMP TO WBOOT
4138   EB2F 21 03 EA    	LD	HL,WBOOTE	; WBOOT ENTRY POINT
4139   EB32 22 01 00    	LD	(1),HL		; SET ADDRESS FIELD FOR JMP AT 0
4140   EB35             ;
4141   EB35 32 05 00    	LD	(5),A		; FOR JMP TO BDOS
4142   EB38 21 06 DC    	LD	HL,BDOS		; BDOS ENTRY POINT
4143   EB3B 22 06 00    	LD	(6),HL		; ADDRESS FIELD OF JUMP AT 5 TO BDOS
4144   EB3E             ;
4145   EB3E 01 80 00    	LD	BC,80H		; DEFAULT DMA ADDRESS IS 80H
4146   EB41 CD 99 EB    	CALL	SETDMA
4147   EB44             ;
4148   EB44 3A 04 00    	LD	A,(CDISK)	; GET CURRENT DISK NUMBER
4149   EB47 4F          	LD	C,A		; SEND TO THE CCP
4150   EB48 C3 00 D4    	JP	CCP		; GO TO CP/M FOR FURTHER PROCESSING
4151   EB4B             ;
4152   EB4B             ;
4153   EB4B             ;	SIMPLE I/O HANDLERS (MUST BE FILLED IN BY USER)
4154   EB4B             ;	IN EACH CASE, THE ENTRY POINT IS PROVIDED, WITH SPACE RESERVED
4155   EB4B             ;	TO INSERT YOUR OWN CODE
4156   EB4B             ;
4157   EB4B             CONST:				; CONSOLE STATUS, RETURN 0FFH IF CHARACTER READY, 00H IF NOT
4158   EB4B DB 6D       	IN	A,(UART + $05)	; READ LINE STATUS REGISTER (UART5 = $68 + $05)
4159   EB4D E6 01       	AND	$01		; TEST IF DATA IN RECEIVE BUFFER
4160   EB4F             				; IS THERE A CHAR READY? 0=NO, 1=YES
4161   EB4F CA 54 EB    	JP	Z,NOT_READY
4162   EB52 3E FF       	LD	A,$FF		; YES, PUT $FF IN A AND RETURN
4163   EB54             NOT_READY:
4164   EB54             				; NO, LEAVE $00 IN A AND RETURN
4165   EB54 C9          	RET
4166   EB55             ;
4167   EB55             CONIN:				; CONSOLE CHARACTER INTO REGISTER A
4168   EB55             
4169   EB55 CD 4B EB    	CALL	CONST		; IS A CHAR READY TO BE READ FROM UART?
4170   EB58 FE 00       	CP	$00		; 
4171   EB5A CA 55 EB    	JP	Z,CONIN		; NO?  TRY AGAIN   
4172   EB5D DB 68       	IN	A,(UART)	; YES? READ THE CHAR FROM THE UART (UART0 = $68 + $00)
4173   EB5F             				; REGISTER AND PASS BACK TO USER
4174   EB5F             ;	ANI	7FH			;STRIP PARITY BIT
4175   EB5F C9          	RET
4176   EB60             ;
4177   EB60             CONOUT:				; CONSOLE CHARACTER OUTPUT FROM REGISTER C
4178   EB60             
4179   EB60             CONOUT1:
4180   EB60 DB 6D       	IN	A,(UART + $05)	; READ LINE STATUS REGISTER
4181   EB62 E6 20       	AND	$20		; TEST IF UART IS READY TO SEND
4182   EB64 CA 60 EB    	JP	Z,CONOUT1	; IF NOT REPEAT
4183   EB67             
4184   EB67 79          	LD	A,C		; GET TO ACCUMULATOR
4185   EB68 D3 68       	OUT	(UART),A	; THEN WRITE THE CHAR TO UART (UART0 = $68 + $00)
4186   EB6A             	
4187   EB6A CD 36 F2    	CALL	PACKET		; n8vem packet delay for Hope modules - every 30th byte
4188   EB6D C9          	RET
4189   EB6E             ;
4190   EB6E             ;LIST:	;LIST CHARACTER FROM REGISTER C
4191   EB6E             ;	MOV	A,C			;CHARACTER TO REGISTER A
4192   EB6E             ;	RET				;NULL SUBROUTINE
4193   EB6E             ;
4194   EB6E             ;LISTST:	;RETURN LIST STATUS (0 IF NOT READY, 1 IF READY)
4195   EB6E             ;	XRA	A			;0 IS ALWAYS OK TO RETURN
4196   EB6E             ;	RET
4197   EB6E             ;
4198   EB6E             ;PUNCH:	;PUNCH CHARACTER FROM REGISTER C
4199   EB6E             				; I NEVER USE THESE SO THEY ARE NUL DEVICES.
4200   EB6E             ;	MOV	A,C			;CHARACTER TO REGISTER A
4201   EB6E             ;	RET				;NULL SUBROUTINE
4202   EB6E             ;
4203   EB6E             ;
4204   EB6E             ;READER:	;READ CHARACTER INTO REGISTER A FROM READER DEVICE
4205   EB6E             				; I NEVER USE THESE SO THEY ARE NUL DEVICES.
4206   EB6E             ;	MVI	A,1AH			;ENTER END OF FILE FOR NOW (REPLACE LATER)
4207   EB6E             ;	ANI	7FH			;REMEMBER TO STRIP PARITY BIT
4208   EB6E             ;	RET
4209   EB6E             ;
4210   EB6E             ;	I/O DRIVERS FOR THE DISK FOLLOW
4211   EB6E             ;	FOR NOW, WE WILL SIMPLY STORE THE PARAMETERS AWAY FOR USE
4212   EB6E             ;	IN THE READ AND WRITE SUBROUTINES
4213   EB6E             ;
4214   EB6E             
4215   EB6E             ;
4216   EB6E             ;   SELECT DISK GIVEN BY REGISTER C
4217   EB6E             ;
4218   EB6E 21 00 00    SELDSK:	LD	HL,0000H	; ERROR RETURN CODE
4219   EB71 79          	LD	A,C
4220   EB72 32 82 EE    	LD	(DISKNO),A
4221   EB75 FE 05       	CP	5		; MUST BE BETWEEN 0 AND 4
4222   EB77 D0          	RET	NC		; NO CARRY IF 5,6...
4223   EB78             ;   DISK NUMBER IS IN THE PROPER RANGE
4224   EB78             ;   COMPUTE PROPER DISK PARAMETER HEADER ADDRESS
4225   EB78 3A 82 EE    	LD	A,(DISKNO)
4226   EB7B 6F          	LD	L,A		; L=DISK NUMBER 0,1,2,3,4
4227   EB7C 26 00       	LD	H,0		; HIGH ORDER ZERO
4228   EB7E 29          	ADD	HL,HL		; *2
4229   EB7F 29          	ADD	HL,HL		; *4
4230   EB80 29          	ADD	HL,HL		; *8
4231   EB81 29          	ADD	HL,HL		; *16 (SIZE OF EACH HEADER)
4232   EB82 11 33 EA    	LD	DE,DPBASE
4233   EB85 19          	ADD	HL,DE		; HL=.DPBASE(DISKNO*16)
4234   EB86 C9          	RET
4235   EB87             ;
4236   EB87             HOME:				; MOVE TO THE TRACK 00 POSITION OF CURRENT DRIVE
4237   EB87             				; TRANSLATE THIS CALL INTO A SETTRK CALL WITH PARAMETER 00
4238   EB87 01 00 00    	LD	BC,0		; SELECT TRACK 0000
4239   EB8A             ;	CALL	SETTRK
4240   EB8A             ;	RET				;WE WILL MOVE TO 00 ON FIRST READ/WRITE
4241   EB8A             				; FALL THROUGH TO SETTRK TO STORE VALUE
4242   EB8A             	
4243   EB8A             
4244   EB8A             SETTRK:				; SET TRACK GIVEN BY REGISTER BC
4245   EB8A 60          	LD	H,B
4246   EB8B 69          	LD	L,C
4247   EB8C 22 77 EE    	LD	(TRACK),HL
4248   EB8F C9          	RET
4249   EB90             ;
4250   EB90             SETSEC:				; SET SECTOR GIVEN BY REGISTER BC
4251   EB90 60          	LD	H,B
4252   EB91 69          	LD	L,C
4253   EB92 22 7A EE    	LD	(SECTOR),HL
4254   EB95 C9          	RET
4255   EB96             ;
4256   EB96             ;   TRANSLATE THE SECTOR GIVEN BY BC USING THE
4257   EB96             ;   TRANSLATE TABLE GIVEN BY DE
4258   EB96             ; ONLY USED FOR FLOPPIES! FOR ROMDISK/RAMDISK IT'S 1:1
4259   EB96             ; DO THE NEXT ROUTINE IS A NULL (RETURNS THE SAME)
4260   EB96             SECTRN:	
4261   EB96 60          	LD	H,B
4262   EB97 69          	LD	L,C
4263   EB98 C9          	RET
4264   EB99             ;
4265   EB99             SETDMA:				; SET DMA ADDRESS GIVEN BY REGISTERS B AND C
4266   EB99 69          	LD	L,C		; LOW ORDER ADDRESS
4267   EB9A 60          	LD	H,B		; HIGH ORDER ADDRESS
4268   EB9B 22 80 EE    	LD	(DMAAD),HL	; SAVE THE ADDRESS
4269   EB9E C9          	RET
4270   EB9F             ;
4271   EB9F             ;  DISK DRIVERS...
4272   EB9F             ;
4273   EB9F             ; DRIVER NEED TO DO SEVERAL THINGS FOR ROM AND RAM DISKS.
4274   EB9F             ;   - INTERRUPTS ARE NOT ALLOWED DURING LOW RAM/ROM ACCESS (DISABLE!)
4275   EB9F             ;   -TRANSLATE TRACK AND SECTOR INTO A POINTER TO WHERE THE 128 BYTE 
4276   EB9F             ;     SECTOR BEGINS IN THE RAM/ROM
4277   EB9F             ;   -TRANSLATE THE DRIVE INTO A RAM/ROM SELECT, COMBINE WITH TRACK ADDRESS
4278   EB9F             ;     AND SEND TO THE MAP PORT.
4279   EB9F             ;   -COPY 128 BYTE FROM OR TO THE ROM/RAMDISK AND MEMORY POINTED TO BY THE DMA 
4280   EB9F             ;     ADDRESS PREVIOUSLY STORED.
4281   EB9F             ;   -RESTORE MAP PORT TO PRIOR CONDITION BEFOR READ/WRITE
4282   EB9F             ;
4283   EB9F             ;   - FIRST TRICK IS THAT WE MADE SECTORS 256 AS 256*128=32768.  SO WE COPY 
4284   EB9F             ;     THE LOW SECTOR ADDRESS TO THE LOW BYTE OF THE HL REGISTER AND THEN 
4285   EB9F             ;     MULTIPLY BY 128. THIS RESULTS IN THE STARTING ADDRESS IN THE RAM OR ROM
4286   EB9F             ;     (0000 -> 7F80H) 32K PAGE.
4287   EB9F             ;
4288   EB9F             ;    - TRICK TWO IS THE TRACK ADDRESS EQUALS THE 32K PAGE ADDRESS AND IS A 
4289   EB9F             ;      DIRECT SELECT THAT CAN BE COPIED TO THE MAP PORT D0 THROUGH D5.  D7
4290   EB9F             ;      SELECTS THE DRIVE (ROM OR RAM).
4291   EB9F             ;      THAT MEANS THE LOW BYTE OF TRACK CONTAINS THE D0-D5 VALUE AND 
4292   EB9F             ;      DISKNO HAS THE DRIVE SELECTED.  WE FIRST COPY DISKNO TO ACC
4293   EB9F             ;      AND RIGHTSHIFT IT TO PLACE THAT IN BIT 7, WE THEN ADD THE LOW BYTE OF 
4294   EB9F             ;      TRACK TO ACC AND THEN SEND THAT TO THE MAP PORT.
4295   EB9F             ;
4296   EB9F             ;      NOTE 1: A WRITE TO ROM SHOULD BE FLAGGED AS AN ERROR.
4297   EB9F             ;      NOTE 2: RAM MUST START AS A "FORMATTED DISK"  IF BATTERY BACKED UP
4298   EB9F             ;                   IT'S A DO ONCE AT COLD COLD START.  IF NOT BATTERY BACKED U
4299   EB9F             ;                   IT WILL HAVE TO BE DONE EVERY TIME THE SYSTEM IS POWERED.
4300   EB9F             ;                   FORMATTING THE RAM IS SIMPLE AS CLEARING THE DIRECTORY AREA
4301   EB9F             ;                   TO A VALUE OF E5H (THE FIRST 8K OF TRACK 1 OR THE RAMDISK).
4302   EB9F             ;                   IT COULD BE DONE AS A SIMPLE UTILITY PROGRAM STORED IN ROMD
4303   EB9F             ;                   OR ANYTIME COLBOOT IS CALLED(LESS DESIREABLE).
4304   EB9F             ;
4305   EB9F             ;     -WE NOW CAN COPY TO OR FROM AS CORRECT FOR THE DEVICE 128 BYTES (SECTOR)
4306   EB9F             ;      TO OR FROM THE DMA ADDRESS. ALMOST!  SINCE ROM OR RAM IS BEING PAGED
4307   EB9F             ;      WE HAVE TO COPY ANYTHING DETINED FOR BELOW 8000H TO A TEMP BUFFER THEN
4308   EB9F             ;      HANDLE THE PAGING.
4309   EB9F             ;        
4310   EB9F             ;
4311   EB9F             ;     - LAST STEP IS TO RESTORE THE MAP PORT TO POINT TO THE RAM (TRACK 0) SO T
4312   EB9F             ;       MEMORY MAP IS ALL RAM AGAIN AND NOT POINTING INTO THE DATA AREAS OR THE
4313   EB9F             ;       SINCE THE RAM 0TH PAGE IS NOMINALLY THE LOW 32K OF RAM IN THE SYSTEM WE
4314   EB9F             ;       SEND A SIMPLE MVI A,80H ; OUT MPCL_ROM; MVI A,00H ; OUT MPCL_RAM.
4315   EB9F             ;
4316   EB9F             ;      - THE READ OR WRITE OPERATION IS DONE.
4317   EB9F             ;
4318   EB9F             ;   READ DISK
4319   EB9F             ;    USES DE,DL, BC,  ACC FLAGS
4320   EB9F             ;      Z80 COULD USE BLOCK MOVE [LDIR] BUT WRITTEN IN 8080 
4321   EB9F             ;
4322   EB9F             ;
4323   EB9F             
4324   EB9F             
4325   EB9F             READ:
4326   EB9F F3          	DI			; DISABLE INTERRUPTS
4327   EBA0 3A 82 EE    	LD	A,(DISKNO)	; GET DRIVE
4328   EBA3             ; swapped 00 and 01 Oct 14 2008 N8VEM 
4329   EBA3 FE 01       	CP	$01		; FIND OUT WHICH DRIVE IS BEING REQUESTED
4330   EBA5 CA BC EB    	JP	Z,READ_EEPROM_DISK ; ARE WE READING RAM OR ROM?
4331   EBA8             				; READ FROM 22K EEPROM DISK
4332   EBA8 FE 00       	CP	$00		; 
4333   EBAA CA FD EB    	JP	Z,READ_RAM_DISK	; READ FROM 448K RAM DISK
4334   EBAD             
4335   EBAD FE 02       	CP	$02
4336   EBAF CA 20 EC    	JP	Z,READ_HDPART2	; READ FROM 8 MB IDE HARD DISK, PARTITION 2
4337   EBB2             
4338   EBB2 FE 03       	CP	$03
4339   EBB4 CA 70 EC    	JP	Z,READ_HDPART3	; READ FROM 8 MB IDE HARD DISK, PARTITION 3
4340   EBB7             
4341   EBB7 FE 04       	CP	$04
4342   EBB9 CA 71 EC    	JP	Z,READ_HDPART4	; READ FROM 1 MB IDE HARD DISK, PARTITION 4
4343   EBBC             
4344   EBBC             				; IF NONE OF THE OTHER DISKS, IT MUST BE
4345   EBBC             				; THE EEPROM DISK, SO FALL THROUGH
4346   EBBC             
4347   EBBC             
4348   EBBC             READ_EEPROM_DISK:
4349   EBBC             				; 
4350   EBBC             				; IF ROM, MAP TRACK/SECTOR TO VIRTUAL TRACK/SECTOR
4351   EBBC             				; HANDLE READING FROM ROM HERE
4352   EBBC             				; 
4353   EBBC             				; PURPOSE OF THIS ROUTINE IS TO MAP 32K ROM PART
4354   EBBC             				; TRACK/SECTOR MAP (2K TRACK SIZE MADE OF 16 128
4355   EBBC             				; BYTE SECTORS EACH) ONTO WHAT THE RAM/ROM SECTOR
4356   EBBC             				; READ ROUTINES ARE EXPECTING (32K TRACK SIZE MADE
4357   EBBC             				; OF 256 128 BYTE SECTORS EACH).  THE ROUTINE 
4358   EBBC             				; CONVERTS 4 BIT TRACK # AND 4 BIT SECTOR #
4359   EBBC             				; INTO A VIRTUAL 1 TRACK, 256 SECTOR ACCESS
4360   EBBC 2A 77 EE    	LD	HL,(TRACK)	; TRACK # IS UPPER 4 BITS OF SECTOR ADDRESS
4361   EBBF 29          	ADD	HL,HL		; SHIFT BITS LEFT 1 (*2)
4362   EBC0 29          	ADD	HL,HL		; SHIFT BITS LEFT 1 (*4)
4363   EBC1 29          	ADD	HL,HL		; SHIFT BITS LEFT 1 (*8)
4364   EBC2 29          	ADD	HL,HL		; SHIFT BITS LEFT 1 (*16)
4365   EBC3 44          	LD	B,H		; PUT UPPER 4 BITS OF SECTOR ADDRESS IN BC
4366   EBC4 4D          	LD	C,L		; (B IS UPPER BYTE AND C IS LOWER BYTE)
4367   EBC5             				; BC NOW CONTAINS THE UPDATED TRACK #
4368   EBC5 2A 7A EE    	LD	HL,(SECTOR)	; SECTOR # IS LOWER 4 BITS OF SECTOR ADDRESS
4369   EBC8 09          	ADD	HL,BC		; VIRTUAL SECTOR = (UPDATED TRACK #) + SECTOR #
4370   EBC9 22 7C EE    	LD	(V_SECTOR),HL	; STORE VIRTUAL SECTOR #
4371   EBCC             				; NOW CONTINUE READING ROM WITH REGULAR RAM
4372   EBCC             				; SETUP FOR READ OF RAM OR ROM DISK
4373   EBCC 2A 7C EE    	LD	HL,(V_SECTOR)
4374   EBCF 29          	ADD	HL,HL
4375   EBD0 29          	ADD	HL,HL
4376   EBD1 29          	ADD	HL,HL
4377   EBD2 29          	ADD	HL,HL
4378   EBD3 29          	ADD	HL,HL
4379   EBD4 29          	ADD	HL,HL
4380   EBD5 29          	ADD	HL,HL		; *128
4381   EBD6 22 7E EE    	LD	(SECST),HL	; SAVE SECTOR STARTING ADDRESS
4382   EBD9             
4383   EBD9             				; SET PAGER WITH DRIVE (0) AND TRACK (0)
4384   EBD9 3E 00       	LD	A,$00		; SWITCH IN ROM PAGE 
4385   EBDB D3 7C       	OUT	(MPCL_ROM),A	; SEND TO PORT MAPPER
4386   EBDD 32 79 EE    	LD	(PAGER),A	; SAVE COPY (JUST BECAUSE)
4387   EBE0             	
4388   EBE0 2A 7E EE    	LD	HL,(SECST)	; GET ROM/RAM ADDRESS
4389   EBE3 5D          	LD	E,L
4390   EBE4 54          	LD	D,H		; GET IT INTO DE
4391   EBE5 21 90 EE    	LD	HL,TMPBUF	; LOAD HL WITH TEMP BUF ADDRESS
4392   EBE8             
4393   EBE8             ;	MVI	C,128			; C IS COUNTER FOR TRANSFER
4394   EBE8             ;RLOOPROM:
4395   EBE8             ;	LDAX	D			; GET DATA FROM RAM/ROM VIA DE
4396   EBE8             ;	MOV	M,A			; MOVE TO TEMP ADDRESS
4397   EBE8             ;	DCR	C			; COUNTER -1
4398   EBE8             ;	INX	D			; GET NEXT BYTE OF DATA FROM SECST+DE
4399   EBE8             ;	INX	H			; PUT NEXT BYTE OF DATA AT TMPBUF+HL
4400   EBE8             ;	JNZ	RLOOPROM		; LOOP TILL DONE
4401   EBE8             
4402   EBE8 CD 5E ED    	CALL	COPY_CPM_SECTOR
4403   EBEB             
4404   EBEB             ;
4405   EBEB             ; NO WITH THE ROM/RAM DATA IN THE BUFFER WE CAN NOW MOVE IT TO THE 
4406   EBEB             ;  DMA ADDRESS (IN RAM)
4407   EBEB             ;
4408   EBEB CD 52 ED    	CALL	RPAGE		; SET PAGE TO CP/M RAM
4409   EBEE 21 90 EE    	LD	HL,TMPBUF	; GET ROM/RAM ADDRESS
4410   EBF1 5D          	LD	E,L
4411   EBF2 54          	LD	D,H		; GET IT INTO DE
4412   EBF3 2A 80 EE    	LD	HL,(DMAAD)	; LOAD HL WITH DMA ADDRESS
4413   EBF6             
4414   EBF6             ;	MVI	C,128			; C IS COUNTER FOR TRANSFER
4415   EBF6             ;R2LOOPROM:	
4416   EBF6             ;	LDAX	D			; GET DATA FROM RAM/ROM VIA DE
4417   EBF6             ;	MOV	M,A			; MOVE TO DMA ADDRESS
4418   EBF6             ;	DCR	C			; COUNTER -1
4419   EBF6             ;	INX	D			; GET NEXT BYTE OF DATA AT TMPBUF + DE
4420   EBF6             ;	INX	H			; PUT NEXT BYTE OF DATA FROM DMAAD + HL
4421   EBF6             ;	JNZ	R2LOOPROM		; LOOP TILL DONE
4422   EBF6             
4423   EBF6 CD 5E ED    	CALL	COPY_CPM_SECTOR
4424   EBF9             
4425   EBF9 3E 00       	LD	A,$00
4426   EBFB FB          	EI			; RE-ENABLE INTERRUPTS
4427   EBFC C9          	RET
4428   EBFD             				; ACCESS ALGORITHM (ONLY APPLICABLE TO 32K ROM PART!)
4429   EBFD             
4430   EBFD             READ_RAM_DISK:
4431   EBFD             				; IF RAM, PROCEED WITH NORMAL TRACK/SECTOR READ
4432   EBFD CD 34 ED    	CALL	SECPAGE		; SETUP FOR READ OF RAM OR ROM DISK
4433   EC00 CD 42 ED    	CALL	PAGERB		; SET PAGER WITH DRIVE AND TRACK
4434   EC03 2A 7E EE    	LD	HL,(SECST)	; GET ROM/RAM ADDRESS
4435   EC06 5D          	LD	E,L
4436   EC07 54          	LD	D,H		; GET IT INTO DE
4437   EC08 21 90 EE    	LD	HL,TMPBUF	; LOAD HL WITH TEMP BUF ADDRESS
4438   EC0B             
4439   EC0B             ;	MVI	C,128			; C IS COUNTER FOR TRANSFER
4440   EC0B             ;RLOOP:
4441   EC0B             ;	LDAX	D			; GET DATA FROM RAM/ROM VIA DE
4442   EC0B             ;	MOV	M,A			; MOVE TO TEMP ADDRESS
4443   EC0B             ;	DCR	C			; COUNTER -1
4444   EC0B             ;	INX	D			; GET NEXT BYTE OF DATA FROM SECST+DE
4445   EC0B             ;	INX	H			; PUT NEXT BYTE OF DATA AT TMPBUF+HL
4446   EC0B             ;	JNZ	RLOOP			; LOOP TILL DONE
4447   EC0B             
4448   EC0B CD 5E ED    	CALL	COPY_CPM_SECTOR
4449   EC0E             
4450   EC0E             ;
4451   EC0E             ; NO WITH THE ROM/RAM DATA IN THE BUFFER WE CAN NOW MOVE IT TO THE 
4452   EC0E             ;  DMA ADDRESS (IN RAM)
4453   EC0E             ;
4454   EC0E CD 52 ED    	CALL	RPAGE		; SET PAGE TO CP/M RAM
4455   EC11 21 90 EE    	LD	HL,TMPBUF	; GET ROM/RAM ADDRESS
4456   EC14 5D          	LD	E,L
4457   EC15 54          	LD	D,H		; GET IT INTO DE
4458   EC16 2A 80 EE    	LD	HL,(DMAAD)	; LOAD HL WITH DMA ADDRESS
4459   EC19             
4460   EC19             ;	MVI	C,128			; C IS COUNTER FOR TRANSFER
4461   EC19             ;R2LOOP:	
4462   EC19             ;	LDAX	D			; GET DATA FROM RAM/ROM VIA DE
4463   EC19             ;	MOV	M,A			; MOVE TO DMA ADDRESS
4464   EC19             ;	DCR	C			; COUNTER -1
4465   EC19             ;	INX	D			; GET NEXT BYTE OF DATA FROM TMPBUF + DE
4466   EC19             ;	INX	H			; PUT NEXT BYTE OF DATA AT DMAAD + HL
4467   EC19             ;	JNZ	R2LOOP			; LOOP TILL DONE
4468   EC19             
4469   EC19 CD 5E ED    	CALL	COPY_CPM_SECTOR
4470   EC1C             
4471   EC1C 3E 00       	LD	A,$00
4472   EC1E FB          	EI			; RE-ENABLE INTERRUPTS
4473   EC1F C9          	RET
4474   EC20             
4475   EC20             READ_HDPART2:
4476   EC20             
4477   EC20 F3          	DI			; DISABLE INTERRUPTS
4478   EC21             
4479   EC21 21 00 FC    	LD	HL,$FC00	; INITIALIZE LBA OFFSET SECTOR LO WORD
4480   EC24 22 83 EE    	LD	(LBA_OFFSET_LO),HL
4481   EC27             
4482   EC27 21 00 00    	LD	HL,$0000	; INITIALIZE LBA OFFSET SECTOR HI WORD
4483   EC2A 22 85 EE    	LD	(LBA_OFFSET_HI),HL
4484   EC2D             
4485   EC2D             				; BDOS TRACK PARAMETER (16 BITS)
4486   EC2D             				; BDOS SECTOR PARAMETER (16 BITS)
4487   EC2D             
4488   EC2D 2A 77 EE    	LD	HL,(TRACK)	; LOAD TRACK # (WORD)
4489   EC30 45          	LD	B,L		; SAVE LOWER 8 BITS (TRACK # 0-255)
4490   EC31 2A 7A EE    	LD	HL,(SECTOR)	; LOAD SECTOR # (WORD)
4491   EC34 60          	LD	H,B		; HL IS 8 BIT TRACK IN H, 8 BIT SECTOR IN L
4492   EC35             
4493   EC35 CD 69 ED    	CALL	CONVERT_IDE_SECTOR_CPM ; COMPUTE WHERE THE CP/M SECTOR IS ON THE
4494   EC38             				; IDE PARTITION
4495   EC38             
4496   EC38             				; MAP COMPUTED IDE HD SECTOR TO LBA REGISTERS
4497   EC38             
4498   EC38             				; LBA REGISTERS STORE 28 BIT VALUE OF IDE HD SECTOR ADDRESS
4499   EC38             
4500   EC38 3A 87 EE    	LD	A,(LBA_TARGET_LO) ; LOAD LBA REGISTER 0 WITH SECTOR ADDRESS TO READ
4501   EC3B 32 8B EE    	LD	(IDE_LBA0),A
4502   EC3E 3A 88 EE    	LD	A,(LBA_TARGET_LO+1) ; LOAD LBA REGISTER 1 WITH SECTOR ADDRESS TO READ
4503   EC41 32 8C EE    	LD	(IDE_LBA1),A
4504   EC44 3A 89 EE    	LD	A,(LBA_TARGET_HI) ; LOAD LBA REGISTER 2 WITH SECTOR ADDRESS TO READ
4505   EC47 32 8D EE    	LD	(IDE_LBA2),A
4506   EC4A 3A 8A EE    	LD	A,(LBA_TARGET_HI+1) ; LOAD LBA REGISTER 3 WITH SECTOR ADDRESS TO READ
4507   EC4D E6 0F       	AND	%00001111	; ONLY LOWER FOUR BITS ARE VALID
4508   EC4F C6 E0       	ADD	A,%11100000	; ENABLE LBA BITS 5:7=111 IN IDE_LBA3
4509   EC51 32 8E EE    	LD	(IDE_LBA3),A
4510   EC54             
4511   EC54             				; READ IDE HD SECTOR
4512   EC54             
4513   EC54 CD A1 ED    	CALL	IDE_READ_SECTOR	; READ THE IDE HARD DISK SECTOR
4514   EC57             
4515   EC57             ; NEED TO ADD ERROR CHECKING HERE, CARRY FLAG IS SET IF IDE_READ_SECTOR SUCCESS
4516   EC57             
4517   EC57             				; COMPUTE STARTING ADDRESS OF CP/M SECTOR IN READ IDE HD SECTOR BUFFER
4518   EC57             
4519   EC57 21 90 EE    	LD	HL,SECTOR_BUFFER ; LOAD HL WITH SECTOR BUFFER ADDRESS
4520   EC5A 3A 8F EE    	LD	A,(SECTOR_INDEX) ; GET THE SECTOR INDEX (CP/M SECTOR OFFSET IN BUFFER)
4521   EC5D 0F          	RRCA			; MOVE BIT 0 TO BIT 7
4522   EC5E 0F          	RRCA			; DO AGAIN - IN EFFECT MULTIPLY BY 64
4523   EC5F 16 00       	LD	D,$00		; PUT RESULT AS 16 VALUE IN DE, UPPER BYTE IN D IS $00
4524   EC61 5F          	LD	E,A		; PUT ADDRESS OFFSET IN E
4525   EC62 19          	ADD	HL,DE		; MULTIPLY BY 2, TOTAL MULTIPLICATION IS X 128
4526   EC63 19          	ADD	HL,DE		; CP/M SECTOR STARTING ADDRESS IN IDE HD SECTOR BUFFER
4527   EC64             
4528   EC64             				; COPY CP/M SECTOR TO BDOS DMA ADDRESS BUFFER
4529   EC64             
4530   EC64 54          	LD	D,H		; TRANSFER HL REGISTERS TO DE
4531   EC65 5D          	LD	E,L
4532   EC66 2A 80 EE    	LD	HL,(DMAAD)	; LOAD HL WITH DMA ADDRESS
4533   EC69             
4534   EC69             ;	MVI	C,128			; C IS COUNTER FOR TRANSFER (128 BYTES)
4535   EC69             ;P2LOOP:	
4536   EC69             ;	LDAX	D			; GET DATA FROM RAM/ROM VIA DE
4537   EC69             ;	MOV	M,A			; MOVE TO DMA ADDRESS
4538   EC69             ;	DCR	C			; COUNTER -1
4539   EC69             ;	INX	D			; GET NEXT BYTE OF DATA FROM 
4540   EC69             ;					; IDE BUFFER + OFFSET ADDRESS + DE
4541   EC69             ;	INX	H			; PUT NEXT BYTE OF DATA AT DMAAD + HL
4542   EC69             ;	JNZ	P2LOOP			; LOOP TILL DONE
4543   EC69             
4544   EC69 CD 5E ED    	CALL	COPY_CPM_SECTOR
4545   EC6C             
4546   EC6C FB          	EI			; RE-ENABLE INTERRUPTS
4547   EC6D             
4548   EC6D 3E 00       	LD	A,$00		; RETURN ERROR CODE READ SUCCESSFUL A=0
4549   EC6F             
4550   EC6F C9          	RET
4551   EC70             
4552   EC70             READ_HDPART3:
4553   EC70             				; STUB
4554   EC70 C9          	RET
4555   EC71             READ_HDPART4:
4556   EC71             				; STUB
4557   EC71 C9          	RET
4558   EC72             
4559   EC72             
4560   EC72             ;
4561   EC72             ;   WRITE DISK
4562   EC72             ;
4563   EC72             WRITE:
4564   EC72 F3          	DI			; DISABLE INTERRUPTS
4565   EC73             
4566   EC73 3A 82 EE    	LD	A,(DISKNO)	; GET DRIVE
4567   EC76             ;	ORA	A			; SET FLAGS
4568   EC76             ; N8VEM swapped 01 and 00 Oct 14 2008
4569   EC76 FE 01       	CP	$01		; FIND OUT WHICH DRIVE IS BEING REQUESTED
4570   EC78 CA 8F EC    	JP	Z,RDONLY	; JUMP TO READ ONLY ROUTINE (CANT WRITE TO ROM)
4571   EC7B             				; READ ONLY, FROM 22K EEPROM DISK, ERROR ON WRITE
4572   EC7B FE 00       	CP	$00		; 
4573   EC7D CA 98 EC    	JP	Z,WRITE_RAM_DISK ; WRITE TO 448K RAM DISK
4574   EC80             
4575   EC80 FE 02       	CP	$02
4576   EC82 CA BB EC    	JP	Z,WRITE_HDPART2	; WRITE TO 8 MB IDE HARD DISK, PARTITION 2
4577   EC85             
4578   EC85 FE 03       	CP	$03
4579   EC87 CA 14 ED    	JP	Z,WRITE_HDPART3	; WRITE TO 8 MB IDE HARD DISK, PARTITION 3
4580   EC8A             
4581   EC8A FE 04       	CP	$04
4582   EC8C CA 15 ED    	JP	Z,WRITE_HDPART4	; WRITE TO 1 MB IDE HARD DISK, PARTITION 4
4583   EC8F             
4584   EC8F             				; IF NONE OF THE OTHER DISKS, IT MUST BE
4585   EC8F             				; THE RAM DISK, SO FALL THROUGH
4586   EC8F             
4587   EC8F             RDONLY:
4588   EC8F             
4589   EC8F             ;
4590   EC8F             ;   HANDLE WRITE TO READ ONLY
4591   EC8F             ;
4592   EC8F             ;   SENDS A MESSAGE TO TERMINAL THAT ROM DRIVE IS NOT WRITEABLE
4593   EC8F             ;   DOES A PAUSE THEN RETURNS TO CPM WITH ERROR FLAGGED. THIS IS
4594   EC8F             ;   DONE TO ALLOW A POSSIBLE GRACEFUL EXIT (SOME APPS MAY PUKE).
4595   EC8F             ;
4596   EC8F             
4597   EC8F             				; CODE TBD, PRINT A HEY WRONG DISK AND PAUSE 5SEC AND
4598   EC8F             				; CONTINUE.
4599   EC8F             
4600   EC8F 21 F5 F1    	LD	HL,TXT_RO_ERROR	; SET HL TO START OF ERROR MESSAGE
4601   EC92             
4602   EC92 CD 25 ED    	CALL	PRTMSG		; PRINT ERROR MESSAGE
4603   EC95             
4604   EC95 3E 01       	LD	A,$01		; SEND BAD SECTOR ERROR BACK
4605   EC97             				; BDOS WILL ALSO PRINT ITS OWN ERROR MESSAGE
4606   EC97             ; ADD 5 SECOND PAUSE ROUTINE HERE
4607   EC97 C9          	RET
4608   EC98             
4609   EC98             
4610   EC98             WRITE_RAM_DISK:
4611   EC98             
4612   EC98 2A 80 EE    	LD	HL,(DMAAD)	; GET DMA ADDRESS
4613   EC9B 5D          	LD	E,L
4614   EC9C 54          	LD	D,H		; GET IT INTO DE
4615   EC9D 21 90 EE    	LD	HL,TMPBUF	; LOAD HL WITH TEMP BUF ADDRESS
4616   ECA0             
4617   ECA0             ;	MVI	C,128			; C IS COUNTER FOR TRANSFER
4618   ECA0             ;WLOOP:
4619   ECA0             ;	LDAX	D			; GET DATA FROM RAM/ROM VIA DE
4620   ECA0             ;	MOV	M,A			; MOVE TO TEMP ADDRESS
4621   ECA0             ;	DCR	C			; COUNTER -1
4622   ECA0             ;	INX	D			; GET NEXT BYTE OF DATA FROM DMAAD + DE
4623   ECA0             ;	INX	H			; PUT NEXT BYTE OF DATA AT TMPBUF + HL
4624   ECA0             ;	JNZ	WLOOP			; LOOP TILL DONE
4625   ECA0             
4626   ECA0 CD 5E ED    	CALL	COPY_CPM_SECTOR
4627   ECA3             
4628   ECA3             ;
4629   ECA3             ;  NOW THAT DATA IS IN THE TEMP BUF WE SET TO RAM PAGE
4630   ECA3             ;   FOR WRITE.
4631   ECA3             ;
4632   ECA3 CD 34 ED    	CALL	SECPAGE		; GET RAM PAGE WRITE ADDRESS
4633   ECA6 CD 42 ED    	CALL	PAGERB		; SET PAGER WITH DRIVE AND TRACK
4634   ECA9 21 90 EE    	LD	HL,TMPBUF	; GET TEMP BUFFER ADDRESS
4635   ECAC 5D          	LD	E,L
4636   ECAD 54          	LD	D,H		; GET IT INTO DE
4637   ECAE 2A 7E EE    	LD	HL,(SECST)	; LOAD HL WITH DMA ADDRESS (WHERE TO WRITE TO)
4638   ECB1             
4639   ECB1             ;	MVI	C,128			; C IS COUNTER FOR TRANSFER
4640   ECB1             ;W2LOOP:
4641   ECB1             ;	LDAX	D			; GET DATA FROM RAM/ROM VIA DE
4642   ECB1             ;	MOV	M,A			; MOVE TO RAMDRIVE ADDRESS
4643   ECB1             ;	DCR	C			; COUNTER -1
4644   ECB1             ;	INX	D			; PUT NEXT BYTE OF DATA AT TMPBUF+DE
4645   ECB1             ;	INX	H			; GET NEXT BYTE OF DATA FROM SECST+HL
4646   ECB1             ;	JNZ	W2LOOP			; LOOP TILL DONE
4647   ECB1             
4648   ECB1 CD 5E ED    	CALL	COPY_CPM_SECTOR
4649   ECB4             
4650   ECB4 CD 52 ED    	CALL	RPAGE		; SET BACK TO RAM
4651   ECB7 3E 00       	LD	A,$00
4652   ECB9 FB          	EI			; RE-ENABLE INTERRUPTS
4653   ECBA C9          	RET
4654   ECBB             
4655   ECBB             WRITE_HDPART2:
4656   ECBB             
4657   ECBB F3          	DI			; DISABLE INTERRUPTS
4658   ECBC             
4659   ECBC 21 00 FC    	LD	HL,$FC00	; INITIALIZE LBA OFFSET SECTOR LO WORD
4660   ECBF 22 83 EE    	LD	(LBA_OFFSET_LO),HL
4661   ECC2             
4662   ECC2 21 00 00    	LD	HL,$0000	; INITIALIZE LBA OFFSET SECTOR HI WORD
4663   ECC5 22 85 EE    	LD	(LBA_OFFSET_HI),HL
4664   ECC8             
4665   ECC8             				; BDOS TRACK PARAMETER (16 BITS)
4666   ECC8             				; BDOS SECTOR PARAMETER (16 BITS)
4667   ECC8             
4668   ECC8 2A 77 EE    	LD	HL,(TRACK)	; LOAD TRACK # (WORD)
4669   ECCB 45          	LD	B,L		; SAVE LOWER 8 BITS (TRACK # 0-255)
4670   ECCC 2A 7A EE    	LD	HL,(SECTOR)	; LOAD SECTOR # (WORD)
4671   ECCF 60          	LD	H,B		; HL IS 8 BIT TRACK IN H, 8 BIT SECTOR IN L
4672   ECD0             
4673   ECD0 CD 69 ED    	CALL	CONVERT_IDE_SECTOR_CPM ; COMPUTE WHERE THE CP/M SECTOR IS ON THE
4674   ECD3             				; IDE PARTITION
4675   ECD3             
4676   ECD3             				; MAP COMPUTED IDE HD SECTOR TO LBA REGISTERS
4677   ECD3             
4678   ECD3             				; LBA REGISTERS STORE 28 BIT VALUE OF IDE HD SECTOR ADDRESS
4679   ECD3             
4680   ECD3 3A 87 EE    	LD	A,(LBA_TARGET_LO) ; LOAD LBA REGISTER 0 WITH SECTOR ADDRESS TO READ
4681   ECD6 32 8B EE    	LD	(IDE_LBA0),A
4682   ECD9 3A 88 EE    	LD	A,(LBA_TARGET_LO+1) ; LOAD LBA REGISTER 1 WITH SECTOR ADDRESS TO READ
4683   ECDC 32 8C EE    	LD	(IDE_LBA1),A
4684   ECDF 3A 89 EE    	LD	A,(LBA_TARGET_HI) ; LOAD LBA REGISTER 2 WITH SECTOR ADDRESS TO READ
4685   ECE2 32 8D EE    	LD	(IDE_LBA2),A
4686   ECE5 3A 8A EE    	LD	A,(LBA_TARGET_HI+1) ; LOAD LBA REGISTER 3 WITH SECTOR ADDRESS TO READ
4687   ECE8 E6 0F       	AND	%00001111	; ONLY LOWER FOUR BITS ARE VALID
4688   ECEA C6 E0       	ADD	A,%11100000	; ENABLE LBA BITS 5:7=111 IN IDE_LBA3
4689   ECEC 32 8E EE    	LD	(IDE_LBA3),A
4690   ECEF             
4691   ECEF             				; READ IDE HD SECTOR
4692   ECEF             
4693   ECEF CD A1 ED    	CALL	IDE_READ_SECTOR	; READ THE IDE HARD DISK SECTOR
4694   ECF2             
4695   ECF2             ; NEED TO ADD ERROR CHECKING HERE, CARRY FLAG IS SET IF IDE_READ_SECTOR SUCCESS
4696   ECF2             
4697   ECF2             				; COMPUTE STARTING ADDRESS OF CP/M SECTOR IN READ IDE HD SECTOR BUFFER
4698   ECF2             
4699   ECF2 21 90 EE    	LD	HL,SECTOR_BUFFER ; LOAD HL WITH SECTOR BUFFER ADDRESS
4700   ECF5 3A 8F EE    	LD	A,(SECTOR_INDEX) ; GET THE SECTOR INDEX (CP/M SECTOR OFFSET IN BUFFER)
4701   ECF8 0F          	RRCA			; MOVE BIT 0 TO BIT 7
4702   ECF9 0F          	RRCA			; DO AGAIN - IN EFFECT MULTIPLY BY 64
4703   ECFA 16 00       	LD	D,$00		; PUT RESULT AS 16 VALUE IN DE, UPPER BYTE IN D IS $00
4704   ECFC 5F          	LD	E,A		; PUT ADDRESS OFFSET IN E
4705   ECFD 19          	ADD	HL,DE		; CP/M SECTOR STARTING ADDRESS IN IDE HD SECTOR BUFFER
4706   ECFE 19          	ADD	HL,DE		; MULTIPLY BY 2, TOTAL MULTIPLICATION IS X 128
4707   ECFF             
4708   ECFF 22 7E EE    	LD	(SECST),HL	; KEEP CP/M SECTOR ADDRESS FOR LATER USE
4709   ED02             
4710   ED02             				; COPY CP/M SECTOR FROM BDOS DMA ADDRESS BUFFER
4711   ED02             
4712   ED02 2A 80 EE    	LD	HL,(DMAAD)	; LOAD HL WITH DMA ADDRESS (WHERE THE DATA TO BE WRITTEN IS)
4713   ED05 54          	LD	D,H		; TRANSFER HL REGISTERS TO DE
4714   ED06 5D          	LD	E,L
4715   ED07 2A 7E EE    	LD	HL,(SECST)	; LOAD CP/M SECTOR ADDRESS (WHERE THE DATA IS TO BE WRITTEN)
4716   ED0A             
4717   ED0A             ;	MVI	C,128			; C IS COUNTER FOR TRANSFER (128 BYTES)
4718   ED0A             ;WP2LOOP:	
4719   ED0A             ;	LDAX	D			; GET DATA FROM RAM/ROM VIA DE
4720   ED0A             ;	MOV	M,A			; MOVE TO DMA ADDRESS
4721   ED0A             ;	DCR	C			; COUNTER -1
4722   ED0A             ;	INX	D			; GET NEXT BYTE OF DATA FROM 
4723   ED0A             ;					; IDE BUFFER + OFFSET ADDRESS + DE
4724   ED0A             ;	INX	H			; PUT NEXT BYTE OF DATA AT DMAAD + HL
4725   ED0A             ;	JNZ	WP2LOOP			; LOOP TILL DONE
4726   ED0A             
4727   ED0A CD 5E ED    	CALL	COPY_CPM_SECTOR
4728   ED0D             
4729   ED0D             				; IDE HD SECTOR IS NOW UPDATED WITH CURRENT CP/M SECTOR DATA SO WRITE TO DISK
4730   ED0D             
4731   ED0D CD BD ED    	CALL	IDE_WRITE_SECTOR ; WRITE THE UPDATED IDE HARD DISK SECTOR
4732   ED10             
4733   ED10             ; NEED TO ADD ERROR CHECKING HERE, CARRY FLAG IS SET IF IDE_WRITE_SECTOR SUCCES
4734   ED10             
4735   ED10 FB          	EI			; RE-ENABLE INTERRUPTS
4736   ED11             
4737   ED11 3E 00       	LD	A,$00		; RETURN ERROR CODE WRITE SUCCESSFUL A=0
4738   ED13             
4739   ED13 C9          	RET
4740   ED14             
4741   ED14             WRITE_HDPART3:
4742   ED14             				; STUB
4743   ED14 C9          	RET
4744   ED15             WRITE_HDPART4:
4745   ED15             				; STUB
4746   ED15 C9          	RET
4747   ED16             
4748   ED16             LDIR:				; 8080 SIMULATED Z80 LDIR ROUTINE
4749   ED16             ; INPUTS
4750   ED16             ;  - HL OF SOURCE DATA ADDRESS
4751   ED16             ;  - DE OF TARGET DATE ADDRESS
4752   ED16             ;  - BC NUMBER OF BYTES TO MOVE
4753   ED16             	
4754   ED16             ;	MOV A,M
4755   ED16             ;	STAX D
4756   ED16             ;	INX D
4757   ED16             ;	INX H
4758   ED16             ;	DCX B
4759   ED16             ;	MOV A,B
4760   ED16             ;	ORA C
4761   ED16             ;	JNZ LDIR
4762   ED16             ;	RET
4763   ED16             
4764   ED16             ; ABOVE CODE MAKES TEST PROTOTYPE COLD START DURING CP/M WARM BOOT (WBOOT)
4765   ED16             
4766   ED16 F5          	PUSH	AF
4767   ED17             LDIR_LOOP:
4768   ED17             	
4769   ED17 7E          	LD	A,(HL)
4770   ED18 12          	LD	(DE),A
4771   ED19 13          	INC	DE
4772   ED1A 23          	INC	HL
4773   ED1B 0D          	DEC	C
4774   ED1C C2 17 ED    	JP	NZ,LDIR_LOOP
4775   ED1F 05          	DEC	B
4776   ED20 C2 17 ED    	JP	NZ,LDIR_LOOP
4777   ED23 F1          	POP	AF
4778   ED24             
4779   ED24 C9          	RET
4780   ED25             
4781   ED25             
4782   ED25             PRTMSG:
4783   ED25 7E          	LD	A,(HL)		; GET CHARACTER TO A
4784   ED26 FE FF       	CP	END		; TEST FOR END BYTE
4785   ED28 CA 33 ED    	JP	Z,PRTMSG1	; JUMP IF END BYTE IS FOUND
4786   ED2B 4F          	LD	C,A		; PUT CHAR TO PRINT VALUE IN REG C FOR CONOUT
4787   ED2C CD 60 EB    	CALL	CONOUT		; SEND CHARACTER TO CONSOLE FROM REG C
4788   ED2F 23          	INC	HL		; INC POINTER, TO NEXT CHAR
4789   ED30 C3 25 ED    	JP	PRTMSG		; TRANSMIT LOOP
4790   ED33             
4791   ED33             PRTMSG1:
4792   ED33 C9          	RET
4793   ED34             
4794   ED34             
4795   ED34             ;
4796   ED34             ; UTILITY ROUTINE FOR SECTOR TO PAGE ADDRESS
4797   ED34             ;   USES HL AND CARRY
4798   ED34             ;SECPAG:	LHLD	SECTOR
4799   ED34             SECPAGE:
4800   ED34 2A 7A EE    	LD	HL,(SECTOR)
4801   ED37 29          	ADD	HL,HL
4802   ED38 29          	ADD	HL,HL
4803   ED39 29          	ADD	HL,HL
4804   ED3A 29          	ADD	HL,HL
4805   ED3B 29          	ADD	HL,HL
4806   ED3C 29          	ADD	HL,HL
4807   ED3D 29          	ADD	HL,HL		; *128
4808   ED3E 22 7E EE    	LD	(SECST),HL	; SAVE SECTOR STARTING ADDRESS
4809   ED41 C9          	RET
4810   ED42             ;
4811   ED42             ;  PAGER BYTE CREATION
4812   ED42             ;    ASSEMBLES DRIVE AND TRACK AND SENDS IT TO PAGER PORT
4813   ED42             ;
4814   ED42 2A 77 EE    PAGERB:	LD	HL,(TRACK)
4815   ED45 3A 82 EE    	LD	A,(DISKNO)
4816   ED48 E6 01       	AND	1		; MASK FOR 1 BIT OF DRIVE SELECT 
4817   ED4A 0F          	RRCA			; MOVE BIT 0 TO BIT 7
4818   ED4B B5          	OR	L		; OR L WITH ACC TO COMBINE TRACK AND DRIVE
4819   ED4C D3 78       	OUT	(MPCL_RAM),A	; SEND TO PORT MAPPER
4820   ED4E 32 79 EE    	LD	(PAGER),A	; SAVE COPY (JUST BECAUSE)
4821   ED51 C9          	RET
4822   ED52             ;
4823   ED52             ;   RESET PAGER BACK TO RAM.  
4824   ED52             ;
4825   ED52             RPAGE:
4826   ED52 3E 80       	LD	A,$80		; DESELECT ROM PAGE
4827   ED54 D3 7C       	OUT	(MPCL_ROM),A	; SELECT RAM
4828   ED56 3E 00       	LD	A,$00		; SET TO RAM, TRACK 0
4829   ED58 D3 78       	OUT	(MPCL_RAM),A	; SELECT RAM
4830   ED5A 32 79 EE    	LD	(PAGER),A	; SAVE COPY OF PAGER BYTE
4831   ED5D C9          	RET
4832   ED5E             
4833   ED5E             
4834   ED5E             COPY_CPM_SECTOR:
4835   ED5E             				; COPIES ONE CPM SECTOR FROM ONE MEMORY ADDRESS TO ANOTHER
4836   ED5E             
4837   ED5E             				; INPUT
4838   ED5E             				;  - DE SOURCE ADDRESS
4839   ED5E             				;  - HL TARGET ADDRESS
4840   ED5E             				; USES C REGISTER
4841   ED5E             
4842   ED5E 0E 80       	LD	C,128		; C IS COUNTER FOR FIXED SIZE TRANSFER (128 BYTES)
4843   ED60             COPYLOOP:
4844   ED60             	
4845   ED60 1A          	LD	A,(DE)		; GET DATA FROM RAM/ROM VIA DE (SOURCE)
4846   ED61 77          	LD	(HL),A		; MOVE TO HL ADDRESS (TARGET)
4847   ED62 0D          	DEC	C		; COUNTER -1
4848   ED63 13          	INC	DE		; GET NEXT BYTE OF DATA FROM SOURCE
4849   ED64 23          	INC	HL		; PUT NEXT BYTE OF DATA AT TARGET
4850   ED65 C2 60 ED    	JP	NZ,COPYLOOP	; LOOP TILL DONE
4851   ED68             
4852   ED68 C9          	RET
4853   ED69             
4854   ED69             
4855   ED69             CONVERT_IDE_SECTOR_CPM:
4856   ED69             
4857   ED69             				; COMPUTES WHERE THE CP/M SECTOR IS IN THE IDE PARTITION
4858   ED69             				; IDE HD SECTORS ARE 512 BYTES EACH, CP/M SECTORS ARE 128 BYTES EACH
4859   ED69             				; MAXIMUM SIZE OF CP/M DISK IS 8 MB = 65536 (16 BITS) X 128 BYTES PER SECTOR
4860   ED69             				; IDE HD PARTITION CAN HAVE AT MOST 16384 IDE SECTORS -> 65536 CP/M SECTORS
4861   ED69             				; EACH IDE HD SECTOR CONTAINS 4 ADJACENT CP/M SECTORS
4862   ED69             				; 
4863   ED69             				; 
4864   ED69             				; INPUT:
4865   ED69             				; IDE HD PARTITION STARTING SECTOR NUMBER (FROM PARTITION TABLE)
4866   ED69             				;  - LOWER 16 BITS STORED IN LBA_OFFSET_LO
4867   ED69             				;  - UPPER 16 BITS STORED IN LBA_OFFSET_HI
4868   ED69             				; PARTITION OFFSET IN HL (16 BITS)
4869   ED69             				;  - A UNIQUELY COMPUTED FUNCTION BASED ON GEOMETRY OF DISKS NUMBER OF
4870   ED69             				;    CP/M TRACKS AND SECTORS SPECIFIED IN DPB
4871   ED69             				; 
4872   ED69             				; 
4873   ED69             				; OUTPUT:
4874   ED69             				; IDE TARGET SECTOR (SENT TO IDE HD CONTROLLER FOR READ OPERATION)
4875   ED69             				;  - LOWER 16 BITS STORED IN LBA_TARGET_LO
4876   ED69             				;  - UPPER 16 BITS STORED IN LBA_TARGET_HI
4877   ED69             				; CP/M TO IDE HD SECTOR MAPPING PARAMETER STORED IN SECTOR_INDEX
4878   ED69             				;  - 8 BIT VALUE WITH 4 LEGAL STATES (00, 01, 02, 04) WHICH IS
4879   ED69             				;    TO BE USED TO COMPUTE STARTING ADDRESS OF 128 BYTE CP/M SECTOR ONCE
4880   ED69             				;    512 BYTE IDE HD SECTOR READ INTO MEMORY BUFFER
4881   ED69             				; 
4882   ED69             
4883   ED69             				; ROTATE WITH CARRY 16 BIT TRACK,SECTOR VALUE IN HL TO GET 14 BIT IDE HD
4884   ED69             				; TARGET SECTOR IN PARTITION
4885   ED69             				; KEEP LAST TWO BITS IN B FOR IDE HD SECTOR TO CP/M SECTOR TRANSLATION
4886   ED69             
4887   ED69             				; COMPUTE SECTOR_INDEX 
4888   ED69             
4889   ED69 AF          	XOR	A		; ZERO ACCUMULATOR
4890   ED6A 7D          	LD	A,L		; STORE LAST 2 BITS OF L IN B
4891   ED6B E6 03       	AND	%00000011	; 
4892   ED6D 47          	LD	B,A
4893   ED6E 32 8F EE    	LD	(SECTOR_INDEX),A ; LOCATES WHERE THE 128 BYTE CP/M SECTOR
4894   ED71             				; IS WITHIN THE 512 BYTE IDE HD SECTOR
4895   ED71             
4896   ED71             				; COMPUTE WHICH IDE HD SECTOR TO READ TO WITHIN 4 CP/M SECTORS 
4897   ED71             				; SHIFTS 16 BIT PARTITION OFFSET TO THE RIGHT 2 BITS AND ADDS RESULT TO
4898   ED71             				; IDE HD PARTITION STARTING SECTOR
4899   ED71             
4900   ED71             				; SHIFT PARTITION OFFSET RIGHT 1 BIT
4901   ED71             
4902   ED71 37          	SCF
4903   ED72 3F          	CCF			; CLEAR CARRY FLAG
4904   ED73 7C          	LD	A,H		; 16 BIT ROTATE HL WITH CARRY
4905   ED74 1F          	RRA
4906   ED75 67          	LD	H,A		; ROTATE HL RIGHT 1 BIT (DIVIDE BY 2)
4907   ED76 7D          	LD	A,L
4908   ED77 1F          	RRA
4909   ED78 6F          	LD	L,A
4910   ED79             
4911   ED79             				; SHIFT PARTITION OFFSET RIGHT 1 BIT
4912   ED79             
4913   ED79 37          	SCF
4914   ED7A 3F          	CCF			; CLEAR CARRY FLAG
4915   ED7B 7C          	LD	A,H		; 16 BIT ROTATE HL WITH CARRY
4916   ED7C 1F          	RRA
4917   ED7D 67          	LD	H,A		; ROTATE HL RIGHT 1 BIT (DIVIDE BY 2)
4918   ED7E 7D          	LD	A,L
4919   ED7F 1F          	RRA
4920   ED80 6F          	LD	L,A
4921   ED81             
4922   ED81             				; ADD RESULTING 14 BIT VALUE TO IDE HD PARTITION STARTING SECTOR
4923   ED81             				; STORE RESULT IN IDE HD TARGET SECTOR PARAMETER
4924   ED81             
4925   ED81 3A 83 EE    	LD	A,(LBA_OFFSET_LO) ; 16 BIT ADD OF LBA_OFFSET_LO WITH HL
4926   ED84 85          	ADD	A,L
4927   ED85 32 87 EE    	LD	(LBA_TARGET_LO),A
4928   ED88 3A 84 EE    	LD	A,(LBA_OFFSET_LO+1)
4929   ED8B 8C          	ADC	A,H
4930   ED8C 32 88 EE    	LD	(LBA_TARGET_LO+1),A ; STORE OVERFLOW BIT IN CARRY
4931   ED8F             
4932   ED8F 21 00 00    	LD	HL,$0000
4933   ED92 3A 85 EE    	LD	A,(LBA_OFFSET_HI) ; 16 BIT ADD WITH CARRY OF LBA_OFFSET_HI WITH $0000
4934   ED95 8D          	ADC	A,L
4935   ED96 32 89 EE    	LD	(LBA_TARGET_HI),A
4936   ED99 3A 86 EE    	LD	A,(LBA_OFFSET_HI+1)
4937   ED9C 8C          	ADC	A,H
4938   ED9D 32 8A EE    	LD	(LBA_TARGET_HI+1),A
4939   EDA0             
4940   EDA0 C9          	RET
4941   EDA1             
4942   EDA1             IDE_READ_SECTOR:
4943   EDA1             
4944   EDA1 CD E2 ED    	CALL	IDE_WAIT_BUSY_READY ; MAKE SURE DRIVE IS READY TO PROCEED
4945   EDA4 D0          	RET	NC
4946   EDA5 CD 55 EE    	CALL	IDE_SETUP_LBA	; TELL DRIVE WHAT SECTOR IS REQUIRED
4947   EDA8 3E 20       	LD	A,$20
4948   EDAA D3 27       	OUT	(IDESTTS),A	; $20 = IDE 'READ SECTOR' COMMAND 
4949   EDAC             
4950   EDAC             IDE_SREX:
4951   EDAC CD E2 ED    	CALL	IDE_WAIT_BUSY_READY ; MAKE SURE DRIVE IS READY TO PROCEED
4952   EDAF D0          	RET	NC
4953   EDB0 CD FE ED    	CALL	IDE_TEST_ERROR	; ENSURE NO ERROR WAS REPORTED
4954   EDB3 D0          	RET	NC
4955   EDB4 CD 11 EE    	CALL	IDE_WAIT_BUFFER	; WAIT FOR FULL BUFFER SIGNAL FROM DRIVE
4956   EDB7 D0          	RET	NC
4957   EDB8             
4958   EDB8 CD 2B EE    	CALL	IDE_READ_BUFFER	; GRAB THE 256 WORDS FROM THE BUFFER
4959   EDBB 37          	SCF			; CARRY = 1 ON RETURN = OPERATION OK
4960   EDBC C9          	RET
4961   EDBD             	
4962   EDBD             ;-----------------------------------------------------------------------------
4963   EDBD             
4964   EDBD             IDE_WRITE_SECTOR:
4965   EDBD             
4966   EDBD CD E2 ED    	CALL	IDE_WAIT_BUSY_READY ; MAKE SURE DRIVE IS READY TO PROCEED
4967   EDC0 D0          	RET	NC
4968   EDC1 CD 55 EE    	CALL	IDE_SETUP_LBA	; TELL DRIVE WHAT SECTOR IS REQUIRED
4969   EDC4 3E 30       	LD	A,$30
4970   EDC6 D3 27       	OUT	(IDESTTS),A	; $30 = IDE 'WRITE SECTOR' COMMAND 
4971   EDC8 CD E2 ED    	CALL	IDE_WAIT_BUSY_READY
4972   EDCB D0          	RET	NC
4973   EDCC CD FE ED    	CALL	IDE_TEST_ERROR	; ENSURE NO ERROR WAS REPORTED
4974   EDCF D0          	RET	NC
4975   EDD0 CD 11 EE    	CALL	IDE_WAIT_BUFFER	; WAIT FOR BUFFER READY SIGNAL FROM DRIVE
4976   EDD3 D0          	RET	NC
4977   EDD4 CD 3F EE    	CALL	IDE_WRITE_BUFFER ; SEND 256 WORDS TO DRIVE'S BUFFER
4978   EDD7 CD E2 ED    	CALL	IDE_WAIT_BUSY_READY ; MAKE SURE DRIVE IS READY TO PROCEED
4979   EDDA D0          	RET	NC
4980   EDDB CD FE ED    	CALL	IDE_TEST_ERROR	; ENSURE NO ERROR WAS REPORTED
4981   EDDE D0          	RET	NC
4982   EDDF 37          	SCF			; CARRY = 1 ON RETURN = OPERATION OK
4983   EDE0 C9          	RET
4984   EDE1             
4985   EDE1             ;-----------------------------------------------------------------------------
4986   EDE1             
4987   EDE1             IDE_SOFT_RESET:
4988   EDE1             ;N8VEM deleted this for the moment as delaying warm boot
4989   EDE1             ;	MVI	A,%00000110		;NO INTERRUPTS, RESET DRIVE = 1
4990   EDE1             ;	OUT	IDECTRL
4991   EDE1             ;	MVI	A,%00000010		;NO INTERRUPTS, RESET DRIVE = 0
4992   EDE1             ;	OUT	IDECTRL
4993   EDE1             ;	CALL	IDE_WAIT_BUSY_READY
4994   EDE1 C9          	RET
4995   EDE2             
4996   EDE2             ;------------------------------------------------------------------------------
4997   EDE2             ; IDE INTERNAL SUBROUTINES 
4998   EDE2             ;------------------------------------------------------------------------------
4999   EDE2             
5000   EDE2             IDE_WAIT_BUSY_READY:
5001   EDE2             	
5002   EDE2 11 00 00    	LD	DE,0
5003   EDE5             
5004   EDE5             IDE_WBSY:
5005   EDE5             
5006   EDE5 06 05       	LD	B,5
5007   EDE7             
5008   EDE7             IDE_DLP:
5009   EDE7             
5010   EDE7 05          	DEC	B
5011   EDE8 C2 E7 ED    	JP	NZ,IDE_DLP
5012   EDEB             
5013   EDEB 13          	INC	DE
5014   EDEC 7A          	LD	A,D
5015   EDED B3          	OR	E
5016   EDEE             
5017   EDEE CA FC ED    	JP	Z,IDE_TO
5018   EDF1             
5019   EDF1 DB 27       	IN	A,(IDESTTS)	; READ ERROR REG
5020   EDF3 E6 C0       	AND	%11000000	; MASK OFF BUSY AND RDY BITS
5021   EDF5 EE 40       	XOR	%01000000	; WE WANT BUSY(7) TO BE 0 AND RDY(6) TO BE 1
5022   EDF7             
5023   EDF7 C2 E5 ED    	JP	NZ,IDE_WBSY
5024   EDFA             
5025   EDFA 37          	SCF			; CARRY 1 = OK
5026   EDFB C9          	RET
5027   EDFC             
5028   EDFC             IDE_TO:
5029   EDFC AF          	XOR	A		; CARRY 0 = TIMED OUT
5030   EDFD C9          	RET
5031   EDFE             	
5032   EDFE             ;----------------------------------------------------------------------------
5033   EDFE             
5034   EDFE             IDE_TEST_ERROR:
5035   EDFE             	
5036   EDFE 37          	SCF
5037   EDFF DB 27       	IN	A,(IDESTTS)
5038   EE01 47          	LD	B,A		; NEW
5039   EE02 E6 01       	AND	%00000001	; TEST ERROR BIT
5040   EE04 37          	SCF			; NEW
5041   EE05 C8          	RET	Z
5042   EE06             
5043   EE06 78          	LD	A,B		; NEW
5044   EE07 E6 20       	AND	%00100000
5045   EE09 37          	SCF
5046   EE0A C2 0F EE    	JP	NZ,IDE_ERR	; TEST WRITE ERROR BIT
5047   EE0D             	
5048   EE0D DB 21       	IN	A,(IDEERR)	; READ ERROR FLAGS
5049   EE0F             
5050   EE0F             IDE_ERR:
5051   EE0F B7          	OR	A		; CARRY 0 = ERROR
5052   EE10 C9          	RET			; IF A = 0, IDE BUSY TIMED OUT
5053   EE11             
5054   EE11             ;-----------------------------------------------------------------------------
5055   EE11             	
5056   EE11             IDE_WAIT_BUFFER:
5057   EE11             	
5058   EE11 11 00 00    	LD	DE,0
5059   EE14             
5060   EE14             IDE_WDRQ:
5061   EE14 06 05       	LD	B,5
5062   EE16             
5063   EE16             IDE_BLP:
5064   EE16 05          	DEC	B
5065   EE17 C2 16 EE    	JP	NZ,IDE_BLP
5066   EE1A             
5067   EE1A 13          	INC	DE
5068   EE1B 7A          	LD	A,D
5069   EE1C B3          	OR	E
5070   EE1D CA 29 EE    	JP	Z,IDE_TO2
5071   EE20             
5072   EE20 DB 27       	IN	A,(IDESTTS)	; WAIT FOR DRIVE'S 512 BYTE READ BUFFER 
5073   EE22 E6 08       	AND	%00001000	; TO FILL (OR READY TO FILL)
5074   EE24 CA 14 EE    	JP	Z,IDE_WDRQ
5075   EE27             
5076   EE27 37          	SCF			; CARRY 1 = OK
5077   EE28 C9          	RET
5078   EE29             
5079   EE29             IDE_TO2:
5080   EE29 AF          	XOR	A		; CARRY 0 = TIMED OUT
5081   EE2A C9          	RET
5082   EE2B             
5083   EE2B             ;------------------------------------------------------------------------------
5084   EE2B             
5085   EE2B             IDE_READ_BUFFER:
5086   EE2B             
5087   EE2B E5          	PUSH	HL
5088   EE2C 21 90 EE    	LD	HL,SECTOR_BUFFER
5089   EE2F 06 00       	LD	B,0		; 256 WORDS (512 BYTES PER SECTOR)
5090   EE31             
5091   EE31             IDEBUFRD:
5092   EE31 DB 20       	IN	A,(IDELO)	; LOW BYTE OF WORD FIRST	
5093   EE33 77          	LD	(HL),A
5094   EE34 DB 28       	IN	A,(IDEHI)	; THEN HIGH BYTE OF WORD
5095   EE36 23          	INC	HL
5096   EE37 77          	LD	(HL),A
5097   EE38 23          	INC	HL
5098   EE39 05          	DEC	B
5099   EE3A C2 31 EE    	JP	NZ,IDEBUFRD
5100   EE3D             
5101   EE3D E1          	POP	HL
5102   EE3E C9          	RET
5103   EE3F             
5104   EE3F             ;-----------------------------------------------------------------------------
5105   EE3F             
5106   EE3F             IDE_WRITE_BUFFER:
5107   EE3F             
5108   EE3F E5          	PUSH	HL
5109   EE40 21 90 EE    	LD	HL,SECTOR_BUFFER
5110   EE43 06 00       	LD	B,0		; 256 WORDS (512 BYTES PER SECTOR)
5111   EE45             
5112   EE45             IDEBUFWT:
5113   EE45             
5114   EE45 23          	INC	HL
5115   EE46 7E          	LD	A,(HL)
5116   EE47 2B          	DEC	HL
5117   EE48 D3 28       	OUT	(IDEHI),A	; SET UP HIGH LATCHED BYTE BEFORE
5118   EE4A 7E          	LD	A,(HL)
5119   EE4B D3 20       	OUT	(IDELO),A	; WRITING WORD WITH WRITE TO LOW BYTE
5120   EE4D 23          	INC	HL
5121   EE4E 23          	INC	HL
5122   EE4F 05          	DEC	B
5123   EE50 C2 45 EE    	JP	NZ,IDEBUFWT
5124   EE53             
5125   EE53 E1          	POP	HL
5126   EE54 C9          	RET
5127   EE55             	
5128   EE55             ;-----------------------------------------------------------------------------
5129   EE55             
5130   EE55             IDE_SETUP_LBA:
5131   EE55             	
5132   EE55 3E 01       	LD	A,1
5133   EE57 D3 22       	OUT	(IDESECTC),A	; SET SECTOR COUNT = 1	
5134   EE59             
5135   EE59 3A 8B EE    	LD	A,(IDE_LBA0)
5136   EE5C D3 23       	OUT	(IDESECTN),A	; SET LBA 0:7
5137   EE5E             
5138   EE5E 3A 8C EE    	LD	A,(IDE_LBA1)
5139   EE61 D3 24       	OUT	(IDECYLLO),A	; SET LBA 8:15
5140   EE63             
5141   EE63 3A 8D EE    	LD	A,(IDE_LBA2)
5142   EE66 D3 25       	OUT	(IDECYLHI),A	; SET LBA 16:23
5143   EE68             
5144   EE68 3A 8E EE    	LD	A,(IDE_LBA3)
5145   EE6B E6 0F       	AND	%00001111	; LOWEST 4 BITS USED ONLY
5146   EE6D F6 E0       	OR	%11100000	; TO ENABLE LBA MODE
5147   EE6F D3 26       	OUT	(IDEHEAD),A	; SET LBA 24:27 + BITS 5:7=111
5148   EE71 C9          	RET
5149   EE72             
5150   EE72             ; -----------------------------------------------------------------------------
5151   EE72             CLEAR_AUTOEXEC:
5152   EE72             				; clear the autosub buffer, do on a warm boot
5153   EE72 AF          	XOR	A
5154   EE73 32 07 D4    	LD	(INBUFF+1),A	; SECOND BYTE IS ACTUAL LENGTH.
5155   EE76 C9          	RET
5156   EE77             
5157   EE77             
5158   EE77             ;
5159   EE77             ;	THE REMAINDER OF THE CBIOS IS RESERVED UNINITIALIZED
5160   EE77             ;	DATA AREA, AND DOES NOT NEED TO BE A PART OF THE
5161   EE77             ;	SYSTEM MEMORY IMAGE (THE SPACE MUST BE AVAILABLE,
5162   EE77             ;	HOWEVER, BETWEEN "BEGDAT" AND "ENDDAT").
5163   EE77             ;
5164   EE77             TRACK:	.DS 2			; TWO BYTES FOR TRACK #
5165   EE79 01          PAGER:	.DB 1			; COPY OF PAGER BYTE
5166   EE7A             SECTOR:	.DS 2			; TWO BYTES FOR SECTOR #
5167   EE7C             V_SECTOR:
5168   EE7C             	.DS 2			; TWO BYTES FOR VIRTUAL SECTOR #
5169   EE7E             SECST:	.DS 2			; SECTOR IN ROM/RAM START ADDRESS
5170   EE80             DMAAD:	.DS 2			; DIRECT MEMORY ADDRESS
5171   EE82             DISKNO:	.DS 1			; DISK NUMBER 0-15
5172   EE83             LBA_OFFSET_LO:
5173   EE83 00 00       	.DW			; IDE HD PARTITION STARTING SECTOR (LOW 16 BITS)
5174   EE85             LBA_OFFSET_HI:
5175   EE85 00 00       	.DW			; IDE HD PARTITION STARTING SECTOR (HI 16 BITS, 12 USED)
5176   EE87             LBA_TARGET_LO:
5177   EE87 00 00       	.DW			; IDE HD PARTITION TARGET SECTOR (LOW 16 BITS)
5178   EE89             LBA_TARGET_HI:
5179   EE89 00 00       	.DW			; IDE HD PARTITION TARGET SECTOR (HI 16 BITS, 12 USED)
5180   EE8B             IDE_LBA0:
5181   EE8B             	.DS $01			; SET LBA 0:7
5182   EE8C             IDE_LBA1:
5183   EE8C             	.DS $01			; SET LBA 8:15
5184   EE8D             IDE_LBA2:
5185   EE8D             	.DS $01			; SET LBA 16:23
5186   EE8E             IDE_LBA3:
5187   EE8E             	.DS $01			; LOWEST 4 BITS USED ONLY TO ENABLE LBA MODE 
5188   EE8F             SECTOR_INDEX:
5189   EE8F 00          	.DB			; WHERE 128 BYTE CP/M SECTOR IS IN 512 BYTE IDE HD SECTOR
5190   EE90             SECTOR_BUFFER:
5191   EE90             	.DS 512			; STORAGE FOR 512 BYTE IDE HD SECTOR
5192   F090             ;TMPBUF: 	.DS	128		; TEMPORARY BUFFER FOR DISK TRANSFERS
5193   F090             
5194   F090             TMPBUF:	.EQU SECTOR_BUFFER
5195   F090             
5196   F090             ;
5197   F090             ;	SCRATCH RAM AREA FOR BDOS USE
5198   F090             BEGDAT:	.EQU $			; BEGINNING OF DATA AREA
5199   F090             DIRBF:	.DS 128			; SCRATCH DIRECTORY AREA
5200   F110             ALL00:	.DS 4			; ALLOCATION VECTOR 0  (DSM/8 = 1 BIT PER BLOCK)
5201   F114             ALL01:	.DS 32			; ALLOCATION VECTOR 1 (225/8)
5202   F134             ALL02:	.DS 64			; ALLOCATION VECTOR 2 (511/8)
5203   F174             ALL03:	.DS 64			; ALLOCATION VECTOR 3 (511/8)
5204   F1B4             ALL04:	.DS 64			; ALLOCATION VECTOR 4 (497/8)
5205   F1F4             CHK00:	.DS 0			; NOT USED FOR FIXED MEDIA
5206   F1F4             CHK01:	.DS 0			; NOT USED FOR FIXED MEDIA
5207   F1F4             CHK02:	.DS 0			; NOT USED FOR FIXED MEDIA
5208   F1F4             CHK03:	.DS 0			; NOT USED FOR FIXED MEDIA
5209   F1F4             CHK04:	.DS 0			; NOT USED FOR FIXED MEDIA
5210   F1F4             ;
5211   F1F4             ENDDAT:	.EQU $			; END OF DATA AREA
5212   F1F4             DATSIZ:	.EQU $-BEGDAT		; SIZE OF DATA AREA
5213   F1F4             
5214   F1F4             OUTCNTL:.EQU $			; N8vem COUNTER for wireless hope modules
5215   F1F4 01          OUTCNT:	.DB 1			; reserve one byte for counter
5216   F1F5             
5217   F1F5             
5218   F1F5             ;	TEXT STRINGS
5219   F1F5             
5220   F1F5             TXT_RO_ERROR:
5221   F1F5 0D 0A       	.BYTE CR,LF
5222   F1F7 45 52 52 4F 	.BYTE "ERROR: WRITE TO READ ONLY DISK"
5222   F1FB 52 3A 20 57 
5222   F1FF 52 49 54 45 
5222   F203 20 54 4F 20 
5222   F207 52 45 41 44 
5222   F20B 20 4F 4E 4C 
5222   F20F 59 20 44 49 
5222   F213 53 4B 
5223   F215 FF          	.BYTE END
5224   F216             
5225   F216             TXT_STARTUP_MSG:
5226   F216 0D 0A       	.BYTE CR,LF
5227   F218 43 50 2F 4D 	.BYTE "CP/M V2.2C"
5227   F21C 20 56 32 2E 
5227   F220 32 43 
5228   F222 0D 0A       	.BYTE CR,LF
5229   F224 FF          	.BYTE END
5230   F225             
5231   F225             TXT_COLD:
5232   F225             				; N8VEM
5233   F225 43 4F 4C 44 	.BYTE "COLD BOOT CP/M"
5233   F229 20 42 4F 4F 
5233   F22D 54 20 43 50 
5233   F231 2F 4D 
5234   F233 0D 0A       	.BYTE CR,LF
5235   F235 FF          	.BYTE END
5236   F236             
5237   F236             ; ********************* extra code for wireless comms - send out in packets of 
5238   F236             ;
5239   F236             PACKET:
5240   F236 E5          	PUSH	HL		; store previous value for HL
5241   F237 21 F4 F1    	LD	HL,OUTCNT	; count how many times have sent out the data - into HL
5242   F23A 7E          	LD	A,(HL)		; put the value in A
5243   F23B 3C          	INC	A		; a=a+1
5244   F23C 77          	LD	(HL),A		; put it back
5245   F23D D6 1E       	SUB	30		; subtract 30
5246   F23F C2 4A F2    	JP	NZ,PACKET1	; if not zero then no delay
5247   F242 3E 00       	LD	A,0		; reset counter back to 0
5248   F244 77          	LD	(HL),A		; and store it to memory
5249   F245 0E 32       	LD	C,50		; delay variable try 50
5250   F247 CD 4C F2    	CALL	DELAY
5251   F24A             
5252   F24A E1          PACKET1:POP	HL		; restore HL
5253   F24B C9          	RET
5254   F24C             
5255   F24C             DELAY:				; delay routine, pass value in C
5256   F24C             				; now need to add similar packet delay to xmodem					
5257   F24C             DELCON1:
5258   F24C             
5259   F24C 3E FF       	LD	A,255		; 255 small loop
5260   F24E             DELCON2:
5261   F24E D6 01       	SUB	1		; subtract 1
5262   F250 FE 00       	CP	0		; DECREMENT
5263   F252 C2 4E F2    	JP	NZ,DELCON2
5264   F255 79          	LD	A,C		; get the next C
5265   F256 D6 01       	SUB	1		; subtract 1	
5266   F258 4F          	LD	C,A		; store it back to C
5267   F259 FE 00       	CP	0		; is it 0?
5268   F25B C2 4C F2    	JP	NZ,DELCON1
5269   F25E C9          	RET
5270   F25F             
5271   F25F             
5272   F25F             
5273   F2FF             	.ORG $F2FF
5274   F2FF             LASTBYTE:
5275   F2FF 00          	.DB $00
5276   F300             
5277   F300             	.END
tasm: Number of errors = 0
