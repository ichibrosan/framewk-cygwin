0001   0000             ;
0002   0000             ;	XMODEM.ASM V5.0, by Keith Petersen, W8SDZ
0003   0000             ;		   (revised 6/8/82)
0004   0000             ;
0005   0000             ;	REMOTE CP/M - CP/M FILE TRANSFER PROGRAM
0006   0000             ;  see below DEFDRV	.EQU	'A'	;DRIVE TO REC TO
0007   0000             ;
0008   0000             ;Based on MODEM.ASM V2.0, by Ward Christensen.
0009   0000             ;This program is intended for use on remote CP/M
0010   0000             ;systems where it is important that the initialization
0011   0000             ;of the modem not be changed, such as when using
0012   0000             ;the PMMIBYE program. The baud rate and number of bits
0013   0000             ;remains the same as whatever was set previously.
0014   0000             ;There is no disconnect, terminal or echo option.
0015   0000             ;
0016   0000             ;Updates/fixes (in reverse order to minimize reading time):
0017   0000             ;
0018   0000             ;6/8/82    Added file transfer logging  feature. Enabled  with
0019   0000             ;		 the  equate  variable LOGCAL,  it uses  caller 
0020   0000             ;		info   provided  by  the  RCPM  file   LASTCALR 
0021   0000             ;		together with transferred file name,  size  and 
0022   0000             ;		direction of transfer to append each successful 
0023   0000             ;		transfer to new special file LOG.SYS.  The user 
0024   0000             ;		area designation for LASTCALR must be specified 
0025   0000             ; 		by the variable LASTUSR and file is expected to 
0026   0000             ;		reside on the DEFDRV drive. The support library 
0027   0000             ;		SEQIO.LIB(vrs >=2.2) and the MAC assembler  are 
0028   0000             ;		needed   ONLY if LOGCAL is true.  If logging is 
0029   0000             ;		not desired,  or you don't have MAC then LOGCAL 
0030   0000             ;		may  be  set false and the ASM  assembler  will 
0031   0000             ;		work.  See  SEQIO.LIB for documentation on  the 
0032   0000             ;		support  code.  Also made mods to  file  length 
0033   0000             ;		printout  to  give  times for  600  baud  (PMMI 
0034   0000             ;		only). This is optional with the LSPEED equate. 
0035   0000             ;		If  used,  the baud rate of caller must be made 
0036   0000             ;		available  thru  location  MSPEED(by  the   BYE 
0037   0000             ;		program).		     Jack Riley
0038   0000             ;04/18/82 Corrected transfer time calculations. Added optional
0039   0000             ;	  equate, VOUT for sector count display to
0040   0000             ;	  console output. (Must be CRT type device)
0041   0000             ;	  Changed modem data port equates into 2 distinct
0042   0000             ;	  booleans to accomodate a wider variety of customized
0043   0000             ;	  EXTMOD equated modems.
0044   0000             ;	  Changed NOCOMR option on receive to  automatic
0045   0000             ;	  renaming of  .COM extents to .OBJ. (Howard Booker)
0046   0000             ;
0047   0000             ;04/01/82 Added routine to ERASE any file not properly received
0048   0000             ;	  (gets rid of all those damn 0K files) - thanks
0049   0000             ;	  to Skip Hansen for this one. - BHK
0050   0000             ;
0051   0000             ;03/28/82 Added cancel facility - if first char received 
0052   0000             ;	  when waiting for initial nak is control-X it will
0053   0000             ;	  cancel sending (useful for when the time estimate
0054   0000             ;	  is longer than you want to wait). - BHK
0055   0000             ;
0056   0000             ;03/22/82 Added calculation of estimated transmission time
0057   0000             ;	  when sending a file - divide # sectors by ~ 8 sectors
0058   0000             ;	  per minute transmission speed (at 300 baud) - BHK
0059   0000             ;
0060   0000             ;03/08/82 Added Bruce Wood's designated user and drive area
0061   0000             ;         routines to the original ver. 46 which contained
0062   0000             ;         the DCH modem updates which were first included
0063   0000             ;         on 10/19/81.  Then renamed to ver. 48A to distinguish
0064   0000             ;         from the first ver. 48.  (Bill Aten)
0065   0000             ;
0066   0000             ;01/06/82 Added code to implement designated user and drive
0067   0000             ; 	  area to receive files on.  This was put in to
0068   0000             ;	  make it easier to locate new programs and for drives
0069   0000             ;	  that are write protected. This change will put the file
0070   0000             ;	  being sent into the designated area and when done return
0071   0000             ;	  to the orginal area.
0072   0000             ;	  SEE SETAREA LABEL IN THE CONDITIONAL SECTION  (Bruce Wood)
0073   0000             ;
0074   0000             ;10/19/81 Corrected numerous 'IN MODCTL2' errors for the DC
0075   0000             ;	  Hayes modem.  Added DC Hayes detection of framing
0076   0000             ;	  errors, overrun errors, and parity errors (if
0077   0000             ;	  parity is used) for the receive file routine.
0078   0000             ;	  (Bill Aten)
0079   0000             ;
0080   0000             ;10/12/81 Added code to implement Cyclic Redundancy
0081   0000             ;	  Checking for both receiving and sending files.
0082   0000             ;	  The CRC can only be specified by the operator
0083   0000             ;	  on the receive file option as a secondary
0084   0000             ;	  option of 'C' (XMODEM RC FN.FT).  When CRC is
0085   0000             ;	  in effect, an initial 'C' instead of a NAK will
0086   0000             ;	  be sent to the sender to start things off.
0087   0000             ;	  The 'C' will be the signal to the sender
0088   0000             ;	  (hopefully a version of MODEM that implements
0089   0000             ;	  this CRC convention) that CRC is in effect.
0090   0000             ;	  CRC will then take the place of the checksum
0091   0000             ;	  checking for data validity.  The CRC should
0092   0000             ;	  make file transfers as far as data integrity is
0093   0000             ;	  concerned better than 99.99% error free.  The
0094   0000             ;	  crc macro, CRC120, was used to implement CRC
0095   0000             ;	  in this program and its equivalent version of
0096   0000             ;	  MODEM.  Acknowledgements and thanks to Paul
0097   0000             ;	  Hansknecht who designed and wrote CRC120.
0098   0000             ;
0099   0000             ;07/01/81 REDID H8/H89 EQUATES TESTED PROGRAM USING BOTH
0100   0000             ;	  SYSTEMS AND CHANGED VER TO 4.4    (AL OLANDER)
0101   0000             ;
0102   0000             ;06/28/81 INSTALL H8/H89 EQUATES AND CHANGE EXTERNAL
0103   0000             ;	  MODEM EQUATES TO "EXTMOD". (L. SHIPINSKI)
0104   0000             ;
0105   0000             ;05/30/81 Added IF PMMI/ENDIF to RCVERR routine to eliminate
0106   0000             ;	  'undefined symbol' error when set for DCH modem.
0107   0000             ;	  (Dave Hardy)
0108   0000             ;
0109   0000             ;05/07/81 Changed signon revision number.
0110   0000             ;	  Cleaned up file. (KBP)
0111   0000             ;
0112   0000             ;05/01/81 Added detection of framing errors, overrun
0113   0000             ;	  errors, and parity errors (if parity is used)
0114   0000             ;	  for the receive file routine.  This feature
0115   0000             ;	  is only active for the PMMI modem, since I
0116   0000             ;	  do not know what the modem status bits are
0117   0000             ;	  for IDS and D.C. Hayes modems.  If there
0118   0000             ;	  is one of the above errors, the line will
0119   0000             ;	  be purged for that block and a NAK will be
0120   0000             ;	  sent to the sender for that block.  This was
0121   0000             ;	  added to help catch those transmission errors
0122   0000             ;	  that are not always caught by the checksum.
0123   0000             ;	  This error checking is in addition to the
0124   0000             ;	  checksum routine. (John Mahr)
0125   0000             ;
0126   0000             ;02/17/81 Added test for "f2" tagged files in OPENOK
0127   0000             ;	  for MP/M version 1.1 compatiblity, which
0128   0000             ;	  doesn't allow Ctl-C or Ctl-S in "f1" tagged
0129   0000             ;	  files. (Tim Nicholas)
0130   0000             ;
0131   0000             ;02/16/81 Added hex to file size display. Now reports
0132   0000             ;	  size in both decimal and (xxxxH) hex. Thanks
0133   0000             ;	  to Ben Bronson for the idea. (Tim Nicholas)
0134   0000             ;
0135   0000             ;02/15/81 Added a software timer to the carrier test
0136   0000             ;	  added in SEND and RECV routines. This will
0137   0000             ;	  now abort only if carrier is lost for a 
0138   0000             ;	  period of 15 seconds. This is only essential
0139   0000             ;	  for those using external modems with certain
0140   0000             ;	  SIO's, but will provide the PMMI/DCH user
0141   0000             ;	  faster recovery in a lost carrier situation
0142   0000             ;	  as well. Approx 15 seconds plus 15 seconds
0143   0000             ;	  in BYE.COM, compared to 3 minutes at 300
0144   0000             ;	  baud with earlier revisions. Thanks to Ben
0145   0000             ;	  Bronson for his aid in developing this
0146   0000             ;	  revision. (Tim Nicholas)
0147   0000             ;
0148   0000             ;02/14/81 Corrected error in last update which read
0149   0000             ;	  the incorrect port for PMMI in the added
0150   0000             ;	  carrier test. (Tim Nicholas)
0151   0000             ;	
0152   0000             ;01/31/81 Added equates and code for a carrier test.
0153   0000             ;	  Test performed in modem I/O routines. This
0154   0000             ;	  is required since loss of carrier will go
0155   0000             ;	  undetected by BYE.COM, if the loss occurs
0156   0000             ;	  after a sucessful XMODEM signon, when using
0157   0000             ;	  an external modem and SIO. (Tim Nicholas)
0158   0000             ;
0159   0000             ;01/17/81 Re-wrote routine to calculate file size so
0160   0000             ;         that it works correctly on v2.X systems with
0161   0000             ;         extent folding (non-zero extent mask). (BRR)
0162   0000             ;
0163   0000             ;12/06/80 Re-wrote routine to calculate file size,
0164   0000             ;	  added decimal print of file size. (KBP)
0165   0000             ;
0166   0000             ;12/05/80 Corrected error in use of ext byte that pre-
0167   0000             ;	  vented files greater than one extent from 
0168   0000             ;	  being sent.     Ron Fowler
0169   0000             ;
0170   0000             ;12/03/80 Corrected file extent length display. Now
0171   0000             ;	  reports correct number of records for files
0172   0000             ;	  longer than one extent. Display is now
0173   0000             ;	  double precision (xxxxH). Also made some
0174   0000             ;	  cosmetic changes by re-arranging the equates.
0175   0000             ;	  By Tim Nicholas
0176   0000             ;
0177   0000             ;10/28/80 Cleaned up file. (KBP)
0178   0000             ;
0179   0000             ;10/23/80 Expanded conditional assembly of NOCOM routines
0180   0000             ;	  into NOCOMS, NOLBS, and NOCOMR equates, to allow
0181   0000             ;	  separate conditional assembly of tests for sending
0182   0000             ;	  .COM files, sending .??# files, and receiving .COM
0183   0000             ;	  files, respectively.	(Dave Hardy)
0184   0000             ;
0185   0000             ;10/15/80 Added traps for ambiguous file name or
0186   0000             ;	  none at all. (KBP)
0187   0000             ;
0188   0000             ;09/09/80 Added conditional assembly to prevent filetypes
0189   0000             ;	  '.COM' or '.??#' from being sent to distant end
0190   0000             ;	  and added conditional assembly of test for '.COM'
0191   0000             ;	  filetype on receive as well. See 'NOCOM' below.
0192   0000             ;	  Any filetype ending in '#' will not be sent by
0193   0000             ;	  this program if 'NOCOM' is set to TRUE.  J.SEYMOUR
0194   0000             ;29 Oct 2008 
0195   0000             ;	Added packet send for wireless links - short delay after
0196   0000             ;	30 bytes have been sent.  Search for N8VEM to find changes
0197   0000             ;	fastclock disabled as using 3.68Mhz. ERRLIM changed 10 to 4 retries
0198   0000             ;	 (either it works or it doesn't, and if it is unreliable then fix it!)
0199   0000             ;        J Moxham 
0200   0000             ;
0201   0000             ;
0202   0000             ;NOTE: If you add improvements or otherwise update
0203   0000             ;this program, please modem a copy of the new file
0204   0000             ;to "TECHNICAL CBBS" in Dearborn, Michigan - phone
0205   0000             ;313-846-6127 (110, 300, 450 or 600 baud).  Use the
0206   0000             ;filename XMODEM.NEW.	(KBP)
0207   0000             ;
0208   0000             FALSE:	.EQU 0
0209   0000             TRUE:	.EQU ~FALSE
0210   0000             ;
0211   0000             ;-----------------------------------------------------
0212   0000             ;	 --- Conditional Assembly Options ---	      ;
0213   0000             ;------------------------------------------------------
0214   0000             ;
0215   0000             STDCPM:	.EQU TRUE		; TRUE, IS STANDARD CP/M
0216   0000             ALTCPM:	.EQU FALSE		; TRUE, IS TRS-80 OR H8 W/O 0-ORG
0217   0000             ;
0218   0000             PMMI:	.EQU FALSE		; TRUE, IS PMMI
0219   0000             DCH:	.EQU FALSE		; TRUE, IS D.C. HAYES
0220   0000             H8:	.EQU FALSE		; TRUE, IS H8/H89 W/INS8250 MODEM CHIP
0221   0000             EXTMOD:	.EQU TRUE		; TRUE, IS NONE OF THE ABOVE!
0222   0000             ;
0223   0000             NOCOMS:	.EQU FALSE		; TRUE, NO .COM FILES SENT
0224   0000             NOLBS:	.EQU FALSE		; TRUE, NO .??# FILES SENT
0225   0000             NOCOMR:	.EQU FALSE		; TRUE, CHANGE.COM TO.OBJ ON RECEIVE
0226   0000             ;
0227   0000             ;FASTCLK .EQU	TRUE	;PUT TRUE HERE FOR 4 MHZ CLOCK
0228   0000             FASTCLK:.EQU FALSE		; false for the 3.68Mhz N8VEM
0229   0000             ;
0230   0000             FRNTPNL:.EQU FALSE		; TO DISPLAY STATUS ON FRONT PANEL
0231   0000             PANEL:	.EQU 0FFH		; DEFAULT ADDRESS OF FRONT PANEL
0232   0000             ;
0233   0000             SETAREA:.EQU TRUE		; TRUE, IF USING DESIGNATED AREA TO RECEIVE 
0234   0000             RECU:	.EQU 0			; USER AREA TO REC IN (NOT GREATER THAN 9)
0235   0000             DEFDRV:	.EQU 'A'		; DRIVE TO REC TO
0236   0000             ;
0237   0000             ;	FILE TRANSFER LOGGING OPTIONS	(J. Riley)
0238   0000             LOGCAL:	.EQU FALSE		; IF USING LOGGING OF XMODEM TRANSFERS
0239   0000             LASTUSR:.EQU 15			; USER AREA OF 'LASTCALR' FILE (IF 'LOGCAL' ONLY)
0240   0000             ;
0241   0000             LSPEED:	.EQU FALSE		; REPORT DIFFERENCES IN BAUD RATES IN PRINTOUT
0242   0000             MSPEED:	.EQU 3EH		; LOCATION OF CURRENT BAUD RATE FACTOR(set by BYE)
0243   0000             ;
0244   0000             VOUT:	.EQU 00000H		; ADR OF VIDEO DRIVER IF OPTIONAL SECTOR
0245   0000             				; COUNT TO CONSOLE, ELSE LEAVE AS 0000H
0246   0000             ;
0247   0000             ;
0248   0000             ;------------------------------------------------------
0249   0000             ;	     --- Modem Port Equates --- 	      ;
0250   0000             ;------------------------------------------------------
0251   0000             ;
0252   0000~            	.IF PMMI
0253   0000~            MODCTLP:.EQU 0C0H		; PMMI VALUES(base port addr)
0254   0000~            MODSNDB:.EQU 1			; BIT TO TEST FOR SEND
0255   0000~            MODSNDR:.EQU 1			; VALUE WHEN READY
0256   0000~            MODRCVB:.EQU 2			; BIT TO TEST FOR RECEIVE
0257   0000~            MODRCVR:.EQU 2			; VALUE WHEN READY
0258   0000~            MODDCDB:.EQU 4			; CARRIER DETECT BIT
0259   0000~            MODDCDA:.EQU 0			; VALUE WHEN ACTIVE
0260   0000~            MODPARE:.EQU 08H		; VALUE FOR PARITY ERROR
0261   0000~            MODOVRE:.EQU 10H		; VALUE FOR OVERRUN ERROR
0262   0000~            MODFRME:.EQU 20H		; VALUE FOR FRAMING ERROR
0263   0000~            MODDATP:.EQU MODCTLP+1		; DATA PORT, RECEIVE
0264   0000~            MODDATO:.EQU MODCTLP+1		; DATA PORT, SEND
0265   0000~            BAUDRP:	.EQU MODCTLP+2		; BAUD RATE OUTPUT/MODEM STATUS
0266   0000~            B600:	.EQU 1AH		; FACTOR FOR B600 BAUD
0267   0000~            MODCTL2:.EQU MODCTLP+3		; SECOND CTL PORT
0268   0000             	.ENDIF
0269   0000             ;
0270   0000~            	.IF H8
0271   0000~            MODCTLP:.EQU 0DDH		; H8/H89 VALUES (LSR-LINE STATUS REG.)
0272   0000~            MODSNDB:.EQU 20H		; TEST FOR SEND (LSR-THRE)
0273   0000~            MODSNDR:.EQU 20H		; VALUE WHEN READY
0274   0000~            MODRCVB:.EQU 01H		; TEST FOR RECIEVE (LSR-DR)
0275   0000~            MODRCVR:.EQU 01H		; VALUE WHEN READY
0276   0000~            MODDCDB:.EQU 20H		; CARRIER DETECT BIT (MSR-CTS)
0277   0000~            MODDCDA:.EQU 20H		; VALUE WHEN ACTIVE
0278   0000~            MODPARE:.EQU 04H		; VALUE FOR PARITY ERROR (LSR-PE)
0279   0000~            MODOVRE:.EQU 02H		; VALUE FOR OVERRUN ERROR (LSR-OR)
0280   0000~            MODFRME:.EQU 08H		; VALUE FOR FRAMING ERROE (LSR-FE)
0281   0000~            MODDATP:.EQU 0D8H		; DATA PORT, RECIEVE
0282   0000~            MODDATO:.EQU 0D8H		; DATA PORT, SEND
0283   0000~            BAUDRP:	.EQU 0DDH		; BAUD RATE PORT (DALB IN LCR MUST=1)
0284   0000~            MODCTL2:.EQU 0DEH		; MODEM STATUS REGISTER (MSR)
0285   0000~            MODCTL1:.EQU 0DBH		; LINE CONTROL REGISTER (LCR)
0286   0000             	.ENDIF
0287   0000             ;
0288   0000~            	.IF DCH
0289   0000~            MODCTLP:.EQU 82H		; D. C. HAYES VALUES
0290   0000~            MODSNDB:.EQU 2			; BIT TO TEST FOR SEND
0291   0000~            MODSNDR:.EQU 2			; VALUE WHEN READY
0292   0000~            MODRCVB:.EQU 1			; BIT TO TEST FOR RECEIVE
0293   0000~            MODRCVR:.EQU 1			; VALUE WHEN READY
0294   0000~            MODDCDB:.EQU 40H		; CARRIER DETECT BIT
0295   0000~            MODDCDA:.EQU 40H		; VALUE WHEN ACTIVE
0296   0000~            MODPARE:.EQU 04H		; VALUE FOR PARITY ERROR
0297   0000~            MODOVRE:.EQU 10H		; VALUE FOR OVERRUN ERROR
0298   0000~            MODFRME:.EQU 08H		; VALUE FOR FRAMING ERROR
0299   0000~            MODDATP:.EQU 80H		; DATA PORT IN PORT
0300   0000~            MODDATO:.EQU 80H		; DATA OUT PORT
0301   0000~            MODCTL2:.EQU 81H		; SECOND CTL PORT
0302   0000             	.ENDIF
0303   0000             ;
0304   0000             ;If you are using an external modem (not S-100 plug-in)
0305   0000             ;change these equates for your modem port requirements
0306   0000             ;
0307   0000             	.IF EXTMOD
0308   0000             MODCTLP:.EQU 06DH		; PUT YOUR MODEM STATUS PORT HERE
0309   0000             MODSNDB:.EQU 20H		; YOUR BIT TO TEST FOR SEND
0310   0000             MODSNDR:.EQU 20H		; YOUR VALUE WHEN READY
0311   0000             MODRCVB:.EQU 01H		; YOUR BIT TO TEST FOR RECEIVE
0312   0000             MODRCVR:.EQU 01H		; YOUR VALUE WHEN READY
0313   0000             MODDCDB:.EQU 02H		; CARRIER DETECT BIT		              *** DSR change status bit 
0314   0000             MODDCDA:.EQU 00H		; VALUE WHEN ACTIVE                    *** 0 = no change since 
0315   0000             MODDATP:.EQU 068H		; YOUR MODEM DATA IN PORT
0316   0000             MODDATO:.EQU 068H		; YOUR MODEM DATA OUT PORT
0317   0000             MODCTL2:.EQU 0C1H		; SECOND CONTROL/STATUS PORT.
0318   0000             	.ENDIF			; END OF EXTERNAL MODEM .EQUATES
0319   0000             ;
0320   0000             ;		--- End of Options ---
0321   0000             ;------------------------------------------------------
0322   0000             ;
0323   0000             ERRLIM:	.EQU 10			; MAX ALLOWABLE ERRORS (10 STANDARD)
0324   0000             ;
0325   0000             ;Define ASCII characters used
0326   0000             ;
0327   0000             SOH:	.EQU 1			; START OF HEADER
0328   0000             EOT:	.EQU 4			; END OF TRANSMISSION
0329   0000             ACK:	.EQU 6			; ACKNOWLEDGE
0330   0000             NAK:	.EQU 15H		; NEG ACKNOWLEDGE
0331   0000             CRC:	.EQU 'C'		; CRC REQUEST CHARACTER
0332   0000             CAN:	.EQU 18H		; CONTROL-X FOR CANCEL
0333   0000             LF:	.EQU 10			; LINEFEED
0334   0000             CR:	.EQU 13			; CARRIAGE RETURN
0335   0000             ; 
0336   0000             	.IF STDCPM
0337   0000             BASE:	.EQU 0			; CP/M BASE ADDRESS
0338   0000             	.ENDIF
0339   0000             ;
0340   0000~            	.IF ALTCPM
0341   0000~            BASE:	.EQU 4200H		; ALTERNATE CP/M BASE ADDRESS
0342   0000             	.ENDIF
0343   0000             ;
0344   0100             	.ORG BASE+100H
0345   0100             ;
0346   0100             ;
0347   0100             ;Init private stack
0348   0100 21 00 00    BEGIN:	LD	HL,0		; HL=0
0349   0103 39          	ADD	HL,SP		; HL=STACK FROM CP/M
0350   0104 22 6E 0A    	LD	(STACK),HL	; ..SAVE IT
0351   0107 31 6E 0A    	LD	SP,STACK	; SP=MY STACK
0352   010A             ;
0353   010A             	.IF SETAREA
0354   010A 1E FF       	LD	E,0FFH		; Get the current user area	 a 01/06/82
0355   010C 0E 20       	LD	C,USER		; A 01/06/82
0356   010E CD 05 00    	CALL	BDOS		; A 01/06/82
0357   0111 32 29 0A    	LD	(OLDUSER),A	; Save user number here		 a 01/06/82
0358   0114 0E 19       	LD	C,CURDRV	; Get the current drive		 a 01/06/82
0359   0116 CD 05 00    	CALL	BDOS		; A 01/06/82
0360   0119 32 2A 0A    	LD	(OLDDRV),A	; Save drive here		 a 01/06/82
0361   011C             	.ENDIF
0362   011C             ;
0363   011C CD 57 09    	CALL	ILPRT		; PRINT:
0364   011F 0D 0A       	.DB CR,LF
0365   0121 58 4D 4F 44 	.DB "XMODEM48 VER 5.0V"
0365   0125 45 4D 34 38 
0365   0129 20 56 45 52 
0365   012D 20 35 2E 30 
0365   0131 56 
0366   0132 20 5B 43 52 	.DB " [CRC CAPABLE]",CR,LF,0
0366   0136 43 20 43 41 
0366   013A 50 41 42 4C 
0366   013E 45 5D 0D 0A 
0366   0142 00 
0367   0143             ;
0368   0143             ;GET OPTION
0369   0143             ;
0370   0143 3A 5E 00    	LD	A,(FCB+2)	; SECONDARY OPTION?
0371   0146 FE 43       	CP	'C'		; CRC CHECKING REQUESTED?
0372   0148 C2 57 01    	JP	NZ,CHKOPTN	; NO, GO CHECK PRIMARY
0373   014B 3A 5D 00    	LD	A,(FCB+1)	; GET PRIMARY OPTION
0374   014E FE 52       	CP	'R'		; CRC VALID ONLY FOR RECEIVE
0375   0150 C2 6D 01    	JP	NZ,OPTNERR	; PRT MSG, ABORT
0376   0153 AF          	XOR	A		; ZERO ACCUM
0377   0154 32 2C 0A    	LD	(CRCFLG),A	; TURN ON CRC FLAG
0378   0157             ;
0379   0157 3A 5D 00    CHKOPTN:LD	A,(FCB+1)	; GET OPTION (S or R)
0380   015A F5          	PUSH	AF		; SAVE OPTION
0381   015B             ;
0382   015B             ;Move the filename from FCB2 to FCB1
0383   015B             ;
0384   015B CD 20 09    	CALL	MOVEFCB
0385   015E             ;
0386   015E             ;Gobble up garbage chars from the line
0387   015E             ;prior to receive or send
0388   015E             ;
0389   015E DB 68       	IN	A,(MODDATP)
0390   0160 DB 68       	IN	A,(MODDATP)
0391   0162             ;
0392   0162             ;Jump to appropriate function
0393   0162             ;
0394   0162 F1          	POP	AF		; GET OPTION
0395   0163~            	.IF LOGCAL
0396   0163~            	PUSH	AF		; BUT SAVE IT
0397   0163             	.ENDIF
0398   0163             ;
0399   0163 FE 53       	CP	'S'		; SEND..
0400   0165 CA C1 01    	JP	Z,SENDFIL	; ..A FILE?
0401   0168             ;
0402   0168 FE 52       	CP	'R'		; RECEIVE..
0403   016A CA 03 02    	JP	Z,RCVFIL	; ..A FILE?
0404   016D             ;
0405   016D             ;Invalid option
0406   016D             ;
0407   016D CD 69 09    OPTNERR:CALL	ERXIT		; EXIT W/ERROR
0408   0170 2B 2B 49 4E 	.DB "++INVALID OPTION ON XMODEM "
0408   0174 56 41 4C 49 
0408   0178 44 20 4F 50 
0408   017C 54 49 4F 4E 
0408   0180 20 4F 4E 20 
0408   0184 58 4D 4F 44 
0408   0188 45 4D 20 
0409   018B 43 4F 4D 4D 	.DB "COMMAND++",CR,LF
0409   018F 41 4E 44 2B 
0409   0193 2B 0D 0A 
0410   0196 4D 55 53 54 	.DB "MUST BE S FOR SEND	; R or RC "
0410   019A 20 42 45 20 
0410   019E 53 20 46 4F 
0410   01A2 52 20 53 45 
0410   01A6 4E 44 09 3B 
0410   01AA 20 52 20 6F 
0410   01AE 72 20 52 43 
0410   01B2 20 
0411   01B3 46 4F 52 20 	.DB "FOR RECEIVE",CR,LF,'$'
0411   01B7 52 45 43 45 
0411   01BB 49 56 45 0D 
0411   01BF 0A 24 
0412   01C1             
0413   01C1~            	.IF LOGCAL
0414   01C1~            	MACLIB SEQIO22
0415   01C1~            
0416   01C1~            BSIZE:	.EQU 80H
0417   01C1~            FILERR:	.SET EXIT
0418   01C1~            BUFFERS:.SET DBUF
0419   01C1~            
0420   01C1~            ;		THE FOLLOWING ALLOCATIONS ARE USED BY THE 'FILE' MACROS
0421   01C1~            DEFAULT$USER:
0422   01C1~            	.DB LASTUSR
0423   01C1~            CUR$USER:
0424   01C1~            	.DB 0FFH
0425   01C1~            DEFAULT$DISK:
0426   01C1~            	.DB DEFDRV-'A'
0427   01C1~            CUR$DISK:
0428   01C1~            	.DB 0FFH
0429   01C1~            PGSIZE:	.DW 0
0430   01C1~            
0431   01C1~            LOGCALL:FILE INFILE,CALLER,,LASTCALR,,BSIZE,,PUBLIC,TRUE
0432   01C1~            	LD	A,RECU
0433   01C1~            	LD	(DEFAULT$USER),A
0434   01C1~            	FILE APPEND,LOG,,LOG,SYS,BSIZE,,PUBLIC,TRUE
0435   01C1~            
0436   01C1~            	POP	AF		; GET OPTION
0437   01C1~            	PUT LOG			; PUT IT OUT TO LOG
0438   01C1~            
0439   01C1~            	LD	A,(MSPEED)	; GET SPEED FACTOR
0440   01C1~            	CPL
0441   01C1~            	ADD	A,7EH		; MAGIC NUMBER FOR PMMI MODEM SO WE CAN
0442   01C1~            	PUT LOG			; PUT OUT A SINGLE LETTER CODE
0443   01C1~            	LD	A,(PGSIZE)	; NOW THE PROGRAM SIZE(IN MINUTES TRANSFER TIME)
0444   01C1~            	CALL	PNDEC
0445   01C1~            	LD	A,' '		; BLANK
0446   01C1~            	PUT LOG
0447   01C1~            
0448   01C1~            ;			LOG THE DRIVE AND USER AREA AS A PROMPT
0449   01C1~            	LD	A,(FCB)
0450   01C1~            	OR	A
0451   01C1~            	JP	NZ,WDRV
0452   01C1~            	LD	C,25
0453   01C1~            	CALL	@BDOS
0454   01C1~            	INC	A
0455   01C1~            WDRV:	ADD	A,'A'-1
0456   01C1~            	PUT LOG
0457   01C1~            
0458   01C1~            	LD	C,32		; NOW THE USER AREA(AS DECIMAL NUMBER)
0459   01C1~            	LD	E,0FFH
0460   01C1~            	CALL	@BDOS
0461   01C1~            	CALL	PNDEC
0462   01C1~            	LD	A,'>'		; MAKE IT LOOK LIKE A PROMPT
0463   01C1~            	PUT LOG
0464   01C1~            
0465   01C1~            	LD	HL,FCB+1	; NOW THE NAME OF THE FILE
0466   01C1~            	LD	B,11
0467   01C1~            	CALL	PUTSTR
0468   01C1~            
0469   01C1~            	LD	A,' '		; BLANK
0470   01C1~            	PUT LOG
0471   01C1~            
0472   01C1~            CLOOP:	GET CALLER		; AND THE CALLER
0473   01C1~            	CP	EOF
0474   01C1~            	JP	Z,QUIT
0475   01C1~            	PUT LOG
0476   01C1~            	JP	CLOOP
0477   01C1~            
0478   01C1~            PNDEC:	CP	10		; TWO COLUMN DECIMAL FORMAT ROUTINE
0479   01C1~            	JP	C,ONE		; ONE OR TWO DIGITS TO AREA #?
0480   01C1~            	JP	TWO
0481   01C1~            ONE:	PUSH	AF
0482   01C1~            	LD	A,'0'
0483   01C1~            	PUT LOG
0484   01C1~            	POP	AF
0485   01C1~            TWO:	LD	H,0
0486   01C1~            	LD	L,A
0487   01C1~            	CALL	DECOT
0488   01C1~            	RET
0489   01C1~            
0490   01C1~            DECOT:	PUSH	BC
0491   01C1~            	PUSH	DE
0492   01C1~            	PUSH	HL
0493   01C1~            	LD	BC,-10
0494   01C1~            	LD	DE,-1
0495   01C1~            ;
0496   01C1~            DECOT2:	ADD	HL,BC
0497   01C1~            	INC	DE
0498   01C1~            	JP	C,DECOT2
0499   01C1~            	LD	BC,10
0500   01C1~            	ADD	HL,BC
0501   01C1~            	EX	DE,HL
0502   01C1~            	LD	A,H
0503   01C1~            	OR	L
0504   01C1~            	CALL	NZ,DECOT
0505   01C1~            	LD	A,E
0506   01C1~            	ADD	A,'0'
0507   01C1~            	PUT LOG
0508   01C1~            	POP	HL
0509   01C1~            	POP	DE
0510   01C1~            	POP	BC
0511   01C1~            	RET
0512   01C1~            
0513   01C1~            PUTSTR:	LD	A,(HL)
0514   01C1~            	PUSH	HL
0515   01C1~            	PUSH	BC
0516   01C1~            	PUT LOG
0517   01C1~            	POP	BC
0518   01C1~            	POP	HL
0519   01C1~            	INC	HL
0520   01C1~            	DEC	B
0521   01C1~            	JP	NZ,PUTSTR
0522   01C1~            	RET
0523   01C1~            
0524   01C1~            QUIT:	FINIS LOG
0525   01C1~            	JP	EXIT
0526   01C1             	.ENDIF			; LOGCAL
0527   01C1             ;
0528   01C1             ;* * * * * * * * * * * * * * * * * * * * *
0529   01C1             ;*					*
0530   01C1             ;*	SENDFIL: SENDS A CP/M FILE	*
0531   01C1             ;*					*
0532   01C1             ;* * * * * * * * * * * * * * * * * * * * *
0533   01C1             ;
0534   01C1             ;The CP/M file specified in the XMODEM command
0535   01C1             ;is transferred over the phone to another
0536   01C1             ;computer running MODEM with the "R" (receive)
0537   01C1             ;option.  The data is sent one sector at a
0538   01C1             ;time with headers and checksums, and re-
0539   01C1             ;transmission on errors.  
0540   01C1             ;
0541   01C1 CD 7E 02    SENDFIL:CALL	TRAP		; CHECK FOR NO NAME OR AMBIG. NAME
0542   01C4 CD AB 05    	CALL	CNREC		; COMPUTE # OF RECORDS.
0543   01C7 CD 23 06    	CALL	OPENFIL		; OPEN THE FILE
0544   01CA 1E 50       	LD	E,80		; WAIT 80 SEC..
0545   01CC CD 02 09    	CALL	WAITNAK		; ..FOR INITIAL NAK
0546   01CF             ;
0547   01CF CD 94 07    SENDLP:	CALL	RDSECT		; READ A SECTOR
0548   01D2 DA F5 01    	JP	C,SENDEOF	; SEND EOF IF DONE
0549   01D5 CD E2 04    	CALL	INCRSNO		; BUMP SECTOR #
0550   01D8 AF          	XOR	A		; ZERO ERROR..
0551   01D9 32 28 0A    	LD	(ERRCT),A	; ..COUNT
0552   01DC             ;
0553   01DC CD 32 04    SENDRPT:CALL	SENDHDR		; SEND A HEADER
0554   01DF CD 45 04    	CALL	SENDSEC		; SEND DATA SECTOR
0555   01E2 3A 2C 0A    	LD	A,(CRCFLG)	; GET CRC FLAG
0556   01E5 B7          	OR	A		; CRC IN EFFECT?
0557   01E6 CC 5B 04    	CALL	Z,SENDCRC	; YES, SEND CRC
0558   01E9 C4 56 04    	CALL	NZ,SENDCKS	; NO, SEND CKSUM
0559   01EC CD 68 04    	CALL	GETACK		; GET THE ACK
0560   01EF DA DC 01    	JP	C,SENDRPT	; REPEAT IF NO ACK
0561   01F2 C3 CF 01    	JP	SENDLP		; LOOP UNTIL EOF
0562   01F5             ;
0563   01F5             ;File sent, send EOT's
0564   01F5             ;
0565   01F5 3E 04       SENDEOF:LD	A,EOT		; SEND..
0566   01F7 CD DE 08    	CALL	SEND		; ..AN EOT	
0567   01FA CD 68 04    	CALL	GETACK		; GET THE ACK       	
0568   01FD DA F5 01    	JP	C,SENDEOF	; LOOP IF NO ACK
0569   0200 C3 66 09    	JP	EXITLG		; ALL DONE
0570   0203             ;
0571   0203             ;* * * * * * * * * * * * * * * * * * * * *
0572   0203             ;*					*
0573   0203             ;*	RCVFIL: RECEIVE A FILE		*
0574   0203             ;*					*
0575   0203             ;* * * * * * * * * * * * * * * * * * * * *
0576   0203             ;
0577   0203             ;Receives a file in block format as sent
0578   0203             ;by another person doing "MODEM S FN.FT".
0579   0203             ;Can be invoked by 'XMODEM R FN.FT' or
0580   0203             ;by 'XMODEM RC FN.FT' if CRC is to be used.
0581   0203             ;
0582   0203 CD 7E 02    RCVFIL:	CALL	TRAP		; CHECK FOR NO NAME OR AMBIG. NAME
0583   0206             ;
0584   0206~            	.IF NOCOMR
0585   0206~            	LD	HL,FCB+9	; POINT TO FILETYPE
0586   0206~            	LD	A,'C'		; 1ST LETTER
0587   0206~            	CP	(HL)		; IS IT C ?
0588   0206~            	JP	NZ,CONTINU	; IF NOT, CONTINUE NORMALLY
0589   0206~            	INC	HL		; GET 2ND LETTER
0590   0206~            	LD	A,'O'		; 2ND LETTER
0591   0206~            	CP	(HL)		; IS IT O ?
0592   0206~            	JP	NZ,CONTINU	; IF NOT, CONTINUE NORMALLY
0593   0206~            	INC	HL		; GET 3RD LETTER
0594   0206~            	LD	A,'M'		; 3RD LETTER
0595   0206~            	CP	(HL)		; IS IT M ?
0596   0206~            	JP	NZ,CONTINU	; IF NOT, CONTINUE NORMALLY
0597   0206~            
0598   0206~            	CALL	ILPRT		; PRINT RENAMING MESSAGE
0599   0206~            	.DB "AUTO RENAMING FILETYPE TO '.OBJ' "
0600   0206~            	.DB CR,LF,CR,LF,0
0601   0206~            ;
0602   0206~            	LD	HL,OBJEXT
0603   0206~            	LD	DE,FCB+9
0604   0206~            	LD	B,3
0605   0206~            ALTEXT:	LD	A,(HL)
0606   0206~            	LD	(DE),A
0607   0206~            	INC	HL
0608   0206~            	INC	DE
0609   0206~            	DEC	B
0610   0206~            	JP	NZ,ALTEXT
0611   0206~            	JP	CONTINU
0612   0206~            
0613   0206~            OBJEXT:	.DB "OBJ"
0614   0206             	.ENDIF
0615   0206             ;
0616   0206 CD 27 05    CONTINU:CALL	CHEKFIL		; SEE IF FILE EXISTS
0617   0209 CD 60 05    	CALL	MAKEFIL		; ..THEN MAKE NEW
0618   020C CD 57 09    	CALL	ILPRT		; PRINT:
0619   020F             ;
0620   020F             	.IF SETAREA
0621   020F 4E 4F 54 45 	.DB "NOTE: FILE WILL BE "
0621   0213 3A 20 46 49 
0621   0217 4C 45 20 57 
0621   021B 49 4C 4C 20 
0621   021F 42 45 20 
0622   0222 52 45 43 45 	.DB "RECEIVED ON",CR,LF	; 	     a 01/06/81
0622   0226 49 56 45 44 
0622   022A 20 4F 4E 0D 
0622   022E 0A 
0623   022F 44 52 49 56 	.DB "DRIVE ",DEFDRV," USER ",RECU+30H,CR,LF ; tell this .a 01/06/81
0623   0233 45 20 41 20 
0623   0237 55 53 45 52 
0623   023B 20 30 0D 0A 
0624   023F             	.ENDIF
0625   023F             ;
0626   023F 46 49 4C 45 	.DB "FILE OPEN - READY TO RECEIVE",CR,LF,0
0626   0243 20 4F 50 45 
0626   0247 4E 20 2D 20 
0626   024B 52 45 41 44 
0626   024F 59 20 54 4F 
0626   0253 20 52 45 43 
0626   0257 45 49 56 45 
0626   025B 0D 0A 00 
0627   025E             ;
0628   025E CD DB 02    RCVLP:	CALL	RCVSECT		; GET A SECTOR
0629   0261 DA 72 02    	JP	C,RCVEOT	; GOT EOT
0630   0264 CD 12 08    	CALL	WRSECT		; WRITE THE SECTOR
0631   0267 CD E2 04    	CALL	INCRSNO		; BUMP SECTOR #
0632   026A CD 2C 04    	CALL	SENDACK		; ACK THE SECTOR
0633   026D             
0634   026D             				; debug code
0635   026D F5          	PUSH	AF
0636   026E F1          	POP	AF
0637   026F             				; debug code
0638   026F             
0639   026F C3 5E 02    	JP	RCVLP		; LOOP UNTIL EOF
0640   0272             ;
0641   0272             ;Got EOT on sector - flush buffers, end
0642   0272             ;
0643   0272 CD 2A 08    RCVEOT:	CALL	WRBLOCK		; WRITE THE LAST BLOCK
0644   0275 CD 2C 04    	CALL	SENDACK		; ACK THE SECTOR
0645   0278 CD 40 07    	CALL	CLOSFIL		; CLOSE THE FILE
0646   027B C3 66 09    	JP	EXITLG		; ALL DONE
0647   027E             ;
0648   027E             ;* * * * * * * * * * * * * * * * * * * * *
0649   027E             ;*					*
0650   027E             ;*		SUBROUTINES		*
0651   027E             ;*					*
0652   027E             ;* * * * * * * * * * * * * * * * * * * * *
0653   027E             ;
0654   027E             ;---->	TRAP: Check for no file name or ambiguous name
0655   027E             ;
0656   027E 21 5D 00    TRAP:	LD	HL,FCB+1	; POINT TO FILE NAME
0657   0281 7E          	LD	A,(HL)		; GET FIRST CHAR OF FILE NAME
0658   0282 FE 20       	CP	' '		; ANY THERE?
0659   0284 C2 A7 02    	JP	NZ,ATRAP	; YES, CHECK FOR AMBIGOUS FILE NAME
0660   0287 CD 69 09    	CALL	ERXIT		; PRINT MSG, EXIT
0661   028A 2B 2B 4E 4F 	.DB "++NO FILE NAME SPECIFIED++",CR,LF,'$'
0661   028E 20 46 49 4C 
0661   0292 45 20 4E 41 
0661   0296 4D 45 20 53 
0661   029A 50 45 43 49 
0661   029E 46 49 45 44 
0661   02A2 2B 2B 0D 0A 
0661   02A6 24 
0662   02A7             ;
0663   02A7 06 0B       ATRAP:	LD	B,11		; 11 CHARS TO CHECK
0664   02A9             ;
0665   02A9 7E          TRLOOP:	LD	A,(HL)		; GET CHAR FROM FCB
0666   02AA FE 3F       	CP	'?'		; AMBIGUOUS?
0667   02AC CA B5 02    	JP	Z,TRERR		; YES, EXIT WITH ERROR MSG
0668   02AF 23          	INC	HL		; POINT TO NEXT CHAR
0669   02B0 05          	DEC	B		; ONE LESS TO GO
0670   02B1 C2 A9 02    	JP	NZ,TRLOOP	; NOT DONE, CHECK SOME MORE
0671   02B4 C9          	RET			; NO AMBIGUOUS NAME, RETURN
0672   02B5             ;
0673   02B5 CD 69 09    TRERR:	CALL	ERXIT		; PRINT MSG, EXIT
0674   02B8 2B 2B 43 41 	.DB "++CAN''T USE WILD "
0674   02BC 4E 27 27 54 
0674   02C0 20 55 53 45 
0674   02C4 20 57 49 4C 
0674   02C8 44 20 
0675   02CA 43 41 52 44 	.DB "CARD OPTIONS++",CR,LF,'$'
0675   02CE 20 4F 50 54 
0675   02D2 49 4F 4E 53 
0675   02D6 2B 2B 0D 0A 
0675   02DA 24 
0676   02DB             ;
0677   02DB             ;---->	RCVSECT: Receive a sector
0678   02DB             ;
0679   02DB             ;Returns with carry set if EOT received.
0680   02DB             ;
0681   02DB AF          RCVSECT:XOR	A		; GET 0
0682   02DC 32 28 0A    	LD	(ERRCT),A	; INIT ERROR COUNT
0683   02DF             ;
0684   02DF             RCVRPT:
0685   02DF~            	.IF PMMI | H8 | DCH
0686   02DF~            	XOR	A		; GET 0
0687   02DF~            	LD	(ERRCDE),A	; CLEAR RECEIVE ERROR CODE
0688   02DF             	.ENDIF
0689   02DF             ;
0690   02DF 06 0A       	LD	B,10		; 10 SEC TIMEOUT
0691   02E1 CD 8E 08    	CALL	RECV		; GET SOH/EOT
0692   02E4 DA B0 03    	JP	C,RCVSTOT	; TIMEOUT
0693   02E7             ;
0694   02E7~            	.IF PMMI | H8 | DCH
0695   02E7~            	CALL	RCVERR		; TRANS ERROR?
0696   02E7~            	JP	C,RCVSERR	; CARRY SET IF ERROR
0697   02E7             	.ENDIF
0698   02E7             ;
0699   02E7 FE 01       	CP	SOH		; GET SOH?
0700   02E9 CA B3 03    	JP	Z,RCVSOH	; ..YES
0701   02EC             ;
0702   02EC             ;Earlier versions of MODEM program send some nulls -
0703   02EC             ;ignore them
0704   02EC             ;
0705   02EC B7          	OR	A		; 00 FROM SPEED CHECK?
0706   02ED CA DF 02    	JP	Z,RCVRPT	; YES, IGNORE IT
0707   02F0 FE 04       	CP	EOT		; END OF TRANSFER?
0708   02F2 37          	SCF			; RETURN WITH CARRY..
0709   02F3 C8          	RET	Z		; ..SET IF EOT
0710   02F4             ;
0711   02F4             ;Didn't get SOH or EOT - 
0712   02F4             ;	-or-
0713   02F4             ;Didn't get valid header - purge the line,
0714   02F4             ;then send NAK.
0715   02F4             ;
0716   02F4 06 01       RCVSERR:LD	B,1		; WAIT FOR 1 SEC..
0717   02F6 CD 8E 08    	CALL	RECV		; ..WITH NO CHARS
0718   02F9 D2 F4 02    	JP	NC,RCVSERR	; LOOP UNTIL SENDER DONE
0719   02FC 3A 2C 0A    	LD	A,(CRCFLG)	; GET CRC FLAG
0720   02FF B7          	OR	A		; CRC IN EFFECT?
0721   0300 3E 15       	LD	A,NAK		; PUT NAK IN ACCUM
0722   0302 C2 10 03    	JP	NZ,RCVSER2	; NO, SEND THE NAK
0723   0305 3A 2D 0A    	LD	A,(FIRSTIME)	; GET FIRST TIME SWITCH
0724   0308 B7          	OR	A		; HAS FIRST SOH BEEN RECEIVED?
0725   0309 3E 15       	LD	A,NAK		; PUT NAK IN ACCUM
0726   030B CA 10 03    	JP	Z,RCVSER2	; YES, THEN SEND NAK
0727   030E 3E 43       	LD	A,CRC		; TELL SENDER CRC IS IN EFFECT
0728   0310             ;
0729   0310 CD DE 08    RCVSER2:CALL	SEND		; ..THE NAK or CRC request
0730   0313 3A 28 0A    	LD	A,(ERRCT)	; ABORT IF..
0731   0316 3C          	INC	A		; ..WE HAVE REACHED..
0732   0317 32 28 0A    	LD	(ERRCT),A	; ..THE ERROR..
0733   031A FE 0A       	CP	ERRLIM		; ..LIMIT?
0734   031C DA DF 02    	JP	C,RCVRPT	; ..NO, TRY AGAIN
0735   031F             ;
0736   031F             ;10 errors in a row -
0737   031F             ;
0738   031F CD 40 07    RCVSABT:CALL	CLOSFIL		; KEEP WHATEVER WE GOT
0739   0322 CD 57 09    	CALL	ILPRT
0740   0325 2B 2B 55 4E 	.DB "++UNABLE TO RECEIVE BLOCK "
0740   0329 41 42 4C 45 
0740   032D 20 54 4F 20 
0740   0331 52 45 43 45 
0740   0335 49 56 45 20 
0740   0339 42 4C 4F 43 
0740   033D 4B 20 
0741   033F 2D 20 41 42 	.DB "- ABORTING++",CR,LF,0
0741   0343 4F 52 54 49 
0741   0347 4E 47 2B 2B 
0741   034B 0D 0A 00 
0742   034E CD 80 03    	CALL	DELFILE		; DELETE RECEIVED FILE			; v48c smh
0743   0351 CD 57 09    	CALL	ILPRT		; PRINT SECOND HALF OF MESSAGE
0744   0354 2B 2B 49 4E 	.DB "++INCOMPLETELY RECEIVED FILE "
0744   0358 43 4F 4D 50 
0744   035C 4C 45 54 45 
0744   0360 4C 59 20 52 
0744   0364 45 43 45 49 
0744   0368 56 45 44 20 
0744   036C 46 49 4C 45 
0744   0370 20 
0745   0371 44 45 4C 45 	.DB "DELETED++",CR,LF,0
0745   0375 54 45 44 2B 
0745   0379 2B 0D 0A 00 
0746   037D C3 6F 09    	JP	EXIT		; GIVE UP
0747   0380             ;
0748   0380             ;---->	DELFILE: Deletes the received file (used if receive aborts)
0749   0380             ;							; v48c smh
0750   0380 11 5C 00    DELFILE:LD	DE,FCB		; POINT TO FILE			; (whole routine)
0751   0383 0E 13       	LD	C,ERASEF	; GET FUNCTION
0752   0385 CD 05 00    	CALL	BDOS		; DELETE IT
0753   0388 3C          	INC	A		; DELETE OK?
0754   0389 C0          	RET	NZ		; ..YES, RETURN
0755   038A CD 69 09    	CALL	ERXIT		; ..NO, ABORT
0756   038D 2B 2B 43 41 	.DB "++CAN''T DELETE RECEIVED "
0756   0391 4E 27 27 54 
0756   0395 20 44 45 4C 
0756   0399 45 54 45 20 
0756   039D 52 45 43 45 
0756   03A1 49 56 45 44 
0756   03A5 20 
0757   03A6 46 49 4C 45 	.DB "FILE++",CR,LF,'$',0
0757   03AA 2B 2B 0D 0A 
0757   03AE 24 00 
0758   03B0             ;
0759   03B0             ;Timed out on receive
0760   03B0             ;
0761   03B0 C3 F4 02    RCVSTOT:JP	RCVSERR		; BUMP ERR CT, ETC.
0762   03B3             ;
0763   03B3             ;---->RCVERR: Checks to see if framing error, overrun, or
0764   03B3             ;		parity error occurred.
0765   03B3             ;	1. Error code (ERRCDE) was set in recv routine
0766   03B3             ;	2. ERRCDE=0 for no errors, ERRCDE<>0 for errors
0767   03B3             ;	3. If there has been an error, this routine sets
0768   03B3             ;		the carry bit on.
0769   03B3             ;
0770   03B3~            	.IF PMMI | H8 | DCH
0771   03B3~            RCVERR:	PUSH	AF		; SAVE CHAR TRANSMITTED
0772   03B3~            	LD	A,(ERRCDE)	; GET RECEIVE ERR CODE
0773   03B3~            	AND	A		; IS IT ZERO?
0774   03B3~            	JP	Z,RCVERR2	; YES, NO ERROR
0775   03B3~            	POP	AF		; RESTORE CHAR TRANSMITTED
0776   03B3~            	SCF			; SET CARRY ON FOR ERROR
0777   03B3~            	RET
0778   03B3~            ;
0779   03B3~            RCVERR2:POP	AF		; RESTORE CHAR TRANSMITTED
0780   03B3~            	OR	A		; CLEAR CARRY BIT
0781   03B3~            	RET
0782   03B3             	.ENDIF
0783   03B3             ;
0784   03B3             ;Got SOH - get block #, block # complemented
0785   03B3             ;
0786   03B3 AF          RCVSOH:	XOR	A		; ZERO ACCUM
0787   03B4 32 2D 0A    	LD	(FIRSTIME),A	; INDICATE FIRST SOH RECV'D
0788   03B7 06 01       	LD	B,1		; TIMEOUT = 1 SEC
0789   03B9 CD 8E 08    	CALL	RECV		; GET SECTOR
0790   03BC DA B0 03    	JP	C,RCVSTOT	; GOT TIMEOUT
0791   03BF             ;
0792   03BF~            	.IF PMMI | H8 | DCH
0793   03BF~            	CALL	RCVERR		; TRANS ERROR?
0794   03BF~            	JP	C,RCVSERR	; CARRY SET IF ERROR
0795   03BF             	.ENDIF
0796   03BF             ;
0797   03BF 57          	LD	D,A		; D=BLK #
0798   03C0 06 01       	LD	B,1		; TIMEOUT = 1 SEC
0799   03C2 CD 8E 08    	CALL	RECV		; GET CMA'D SECT #
0800   03C5 DA B0 03    	JP	C,RCVSTOT	; TIMEOUT
0801   03C8             ;
0802   03C8~            	.IF PMMI | H8 | DCH
0803   03C8~            	CALL	RCVERR		; TRANS ERROR?
0804   03C8~            	JP	C,RCVSERR	; CARRY SET IF ERROR
0805   03C8             	.ENDIF
0806   03C8             ;
0807   03C8 2F          	CPL			; CALC COMPLEMENT
0808   03C9 BA          	CP	D		; GOOD SECTOR #?
0809   03CA CA D0 03    	JP	Z,RCVDATA	; YES, GET DATA
0810   03CD             ;
0811   03CD             ;Got bad sector #
0812   03CD             ;
0813   03CD C3 F4 02    	JP	RCVSERR		; BUMP ERROR CT.
0814   03D0             ;
0815   03D0 7A          RCVDATA:LD	A,D		; GET SECTOR #
0816   03D1 32 24 0A    	LD	(RCVSNO),A	; SAVE IT
0817   03D4 0E 00       	LD	C,0		; INIT CKSUM
0818   03D6 CD A3 09    	CALL	CLRCRC		; CLEAR CRC COUNTER
0819   03D9 21 80 00    	LD	HL,BASE+80H	; POINT TO BUFFER
0820   03DC             ;
0821   03DC 06 01       RCVCHR:	LD	B,1		; 1 SEC TIMEOUT
0822   03DE CD 8E 08    	CALL	RECV		; GET CHAR
0823   03E1 DA B0 03    	JP	C,RCVSTOT	; TIMEOUT
0824   03E4             ;
0825   03E4~            	.IF PMMI | H8 | DCH
0826   03E4~            	CALL	RCVERR		; TRANS ERROR?
0827   03E4~            	JP	C,RCVSERR	; CARRY SET IF ERROR
0828   03E4             	.ENDIF
0829   03E4             ;
0830   03E4 77          	LD	(HL),A		; STORE CHAR
0831   03E5 2C          	INC	L		; DONE?
0832   03E6 C2 DC 03    	JP	NZ,RCVCHR	; NO, LOOP
0833   03E9 3A 2C 0A    	LD	A,(CRCFLG)	; GET CRC FLAG
0834   03EC B7          	OR	A		; CRC IN EFFECT?
0835   03ED CA 0E 04    	JP	Z,RCVCRC	; YES, TO RECEIVE CRC
0836   03F0             ;
0837   03F0             ;Verify checksum
0838   03F0             ;
0839   03F0 51          	LD	D,C		; SAVE CHECKSUM
0840   03F1 06 01       	LD	B,1		; TIMEOUT LEN.
0841   03F3 CD 8E 08    	CALL	RECV		; GET CHECKSUM
0842   03F6 DA B0 03    	JP	C,RCVSTOT	; TIMEOUT
0843   03F9             ;
0844   03F9~            	.IF PMMI | H8 | DCH
0845   03F9~            	CALL	RCVERR		; TRANS ERROR?
0846   03F9~            	JP	C,RCVSERR	; CARRY SET IF ERROR
0847   03F9             	.ENDIF
0848   03F9             ;
0849   03F9 BA          	CP	D		; CHECKSUM OK?
0850   03FA C2 F4 02    	JP	NZ,RCVSERR	; NO, ERROR
0851   03FD             ;
0852   03FD             ;Got a sector, it's a duplicate if = previous,
0853   03FD             ;	or OK if = 1 + previous sector
0854   03FD             ;
0855   03FD 3A 24 0A    CHKSNUM:LD	A,(RCVSNO)	; GET RECEIVED
0856   0400 47          	LD	B,A		; SAVE IT
0857   0401 3A 25 0A    	LD	A,(SECTNO)	; GET PREV
0858   0404 B8          	CP	B		; PREV REPEATED?
0859   0405 CA 26 04    	JP	Z,RECVACK	; ACK TO CATCH UP
0860   0408 3C          	INC	A		; CALC NEXT SECTOR #
0861   0409 B8          	CP	B		; MATCH?
0862   040A C2 A7 04    	JP	NZ,ABORT	; NO MATCH - STOP SENDER, EXIT
0863   040D C9          	RET			; CARRY OFF - NO ERRORS
0864   040E             ;
0865   040E             ;---->	RCVCRC:	Receive the cyclic redundancy check
0866   040E             ;		characters (2 bytes), and see if the crc
0867   040E             ;		received matches the one calculated.
0868   040E             ;		If they match, get next sector, else
0869   040E             ;		send a NAK requesting the sector be
0870   040E             ;		resent.
0871   040E             ;
0872   040E 1E 02       RCVCRC:	LD	E,2		; NUMBER OF BYTES TO RECEIVE
0873   0410             ;
0874   0410 06 01       RCVCRC2:LD	B,1		; 1 SEC TIMEOUT
0875   0412 CD 8E 08    	CALL	RECV		; GET CRC BYTE
0876   0415 DA B0 03    	JP	C,RCVSTOT	; TIMEOUT
0877   0418             ;
0878   0418~            	.IF PMMI | H8 | DCH
0879   0418~            	CALL	RCVERR		; TRANSMISSION ERROR?
0880   0418~            	JP	C,RCVSERR	; YES, IF CARRY IS ON
0881   0418             	.ENDIF
0882   0418             ;
0883   0418 1D          	DEC	E		; DECREMENT NUM OF BYTES
0884   0419 C2 10 04    	JP	NZ,RCVCRC2	; GET BOTH BYTES
0885   041C CD E5 09    	CALL	CHKCRC		; CHECK RCVD CRC AGAINST CALC'D CRC
0886   041F B7          	OR	A		; IS CRC OKAY?
0887   0420 CA FD 03    	JP	Z,CHKSNUM	; YES, GO CHECK SECTOR NUMBERS
0888   0423 C3 F4 02    	JP	RCVSERR		; GO CHECK ERROR LIMIT AND SEND NAK
0889   0426             ;
0890   0426             ;Previous sector repeated, due to the last ACK
0891   0426             ;being garbaged.  ACK it so sender will catch up 
0892   0426             ;
0893   0426 CD 2C 04    RECVACK:CALL	SENDACK		; SEND THE ACK,
0894   0429 C3 DB 02    	JP	RCVSECT		; GET NEXT BLOCK
0895   042C             ;
0896   042C             ;Send an ACK for the sector
0897   042C             ;
0898   042C 3E 06       SENDACK:LD	A,ACK		; GET ACK
0899   042E CD DE 08    	CALL	SEND		; ..AND SEND IT
0900   0431 C9          	RET
0901   0432             ;
0902   0432             ;---->	SENDHDR: Send the sector header
0903   0432             ;
0904   0432             ;SEND: (SOH) (block #) (complemented block #)
0905   0432             ;
0906   0432 3E 01       SENDHDR:LD	A,SOH		; SEND..
0907   0434 CD DE 08    	CALL	SEND		; ..SOH,
0908   0437 3A 25 0A    	LD	A,(SECTNO)	; THEN SEND..
0909   043A CD DE 08    	CALL	SEND		; ..SECTOR #
0910   043D 3A 25 0A    	LD	A,(SECTNO)	; THEN SECTOR #
0911   0440 2F          	CPL			; ..COMPLEMENTED..
0912   0441 CD DE 08    	CALL	SEND		; ..SECTOR #
0913   0444 C9          	RET			; FROM SENDHDR
0914   0445             ;
0915   0445             ;---->	SENDSEC: Send the data sector
0916   0445             ;
0917   0445 0E 00       SENDSEC:LD	C,0		; INIT CKSUM
0918   0447 CD A3 09    	CALL	CLRCRC		; CLEAR THE CRC COUNTER
0919   044A 21 80 00    	LD	HL,BASE+80H	; POINT TO BUFFER
0920   044D             ;
0921   044D 7E          SENDC:	LD	A,(HL)		; GET A CHAR
0922   044E CD DE 08    	CALL	SEND		; SEND IT
0923   0451 2C          	INC	L		; POINT TO NEXT CHAR
0924   0452 C2 4D 04    	JP	NZ,SENDC	; LOOP IF <100H
0925   0455 C9          	RET			; FROM SENDSEC
0926   0456             ;
0927   0456             ;---->	SENDCKS: Send the checksum
0928   0456             ;
0929   0456 79          SENDCKS:LD	A,C		; SEND THE..
0930   0457 CD DE 08    	CALL	SEND		; ..CHECKSUM
0931   045A C9          	RET			; FROM SENDCKS
0932   045B             ;
0933   045B             ;---->	SENDCRC: Send the two Cyclic Redundancy
0934   045B             ;		 Check characters.  Call FINCRC
0935   045B             ;		 to calc the CRC which will be in
0936   045B             ;		 d,e regs upon return.
0937   045B             ;
0938   045B CD D4 09    SENDCRC:CALL	FINCRC		; CALC THE CRC FOR THIS SECTOR
0939   045E 7A          	LD	A,D		; PUT FIRST CRC BYTE IN ACCUM
0940   045F CD DE 08    	CALL	SEND		; SEND IT
0941   0462 7B          	LD	A,E		; PUT SECOND CRC BYTE IN ACCUM
0942   0463 CD DE 08    	CALL	SEND		; SEND IT
0943   0466 AF          	XOR	A		; SET ZERO RETURN CODE
0944   0467 C9          	RET
0945   0468             ;
0946   0468             ;---->	GETACK: Get the ACK on the sector
0947   0468             ;
0948   0468             ;Returns with carry clear if ACK received.
0949   0468             ;If an ACK is not received, the error count
0950   0468             ;is incremented, and if less than "ERRLIM",
0951   0468             ;carry is set and control returns.  If the
0952   0468             ;error count is at "ERRLIM", the program
0953   0468             ;aborts.
0954   0468             ;
0955   0468 06 0A       GETACK:	LD	B,10		; WAIT 10 SECONDS MAX
0956   046A CD 8A 08    	CALL	RECVDG		; RECV W/GARBAGE COLLECT
0957   046D DA A4 04    	JP	C,GETATOT	; TIMED OUT
0958   0470 FE 06       	CP	ACK		; OK? (CARRY OFF IF =)
0959   0472 C8          	RET	Z		; YES, RET FROM GETACK
0960   0473             ;
0961   0473             ;Timeout or error on ACK - bump error count
0962   0473             ;
0963   0473 3A 28 0A    ACKERR:	LD	A,(ERRCT)	; GET COUNT
0964   0476 3C          	INC	A		; BUMP IT
0965   0477 32 28 0A    	LD	(ERRCT),A	; SAVE BACK
0966   047A FE 0A       	CP	ERRLIM		; AT LIMIT?
0967   047C D8          	RET	C		; NOT AT LIMIT
0968   047D             ;
0969   047D             ;Reached error limit
0970   047D             ;
0971   047D CD 69 09    CSABORT:CALL	ERXIT
0972   0480 2B 2B 43 41 	.DB "++CAN''T SEND SECTOR "
0972   0484 4E 27 27 54 
0972   0488 20 53 45 4E 
0972   048C 44 20 53 45 
0972   0490 43 54 4F 52 
0972   0494 20 
0973   0495 2D 20 41 42 	.DB "- ABORTING++",CR,LF,'$'
0973   0499 4F 52 54 49 
0973   049D 4E 47 2B 2B 
0973   04A1 0D 0A 24 
0974   04A4             ;
0975   04A4             ;Timeout getting ACK
0976   04A4             ;
0977   04A4 C3 73 04    GETATOT:JP	ACKERR		; NO MSG
0978   04A7             ; 
0979   04A7 31 6E 0A    ABORT:	LD	SP,STACK
0980   04AA             ;
0981   04AA 06 01       ABORTL:	LD	B,1		; 1 SEC. W/O CHARS.
0982   04AC CD 8E 08    	CALL	RECV
0983   04AF D2 AA 04    	JP	NC,ABORTL	; LOOP UNTIL SENDER DONE
0984   04B2 3E 18       	LD	A,CAN		; CONTROL X
0985   04B4 CD DE 08    	CALL	SEND		; STOP SENDING END
0986   04B7             ;
0987   04B7 06 01       ABORTW:	LD	B,1		; 1 SEC W/O CHARS.
0988   04B9 CD 8E 08    	CALL	RECV
0989   04BC D2 B7 04    	JP	NC,ABORTW	; LOOP UNTIL SENDER DONE
0990   04BF 3E 20       	LD	A,' '		; GET A SPACE...
0991   04C1 CD DE 08    	CALL	SEND		; TO CLEAR OUT CONTROL X
0992   04C4 CD 69 09    	CALL	ERXIT		; EXIT WITH ABORT MSG
0993   04C7 58 4D 4F 44 	.DB "XMODEM PROGRAM CANCELLED",CR,LF,'$'
0993   04CB 45 4D 20 50 
0993   04CF 52 4F 47 52 
0993   04D3 41 4D 20 43 
0993   04D7 41 4E 43 45 
0993   04DB 4C 4C 45 44 
0993   04DF 0D 0A 24 
0994   04E2             ;
0995   04E2             ;---->	INCRSNO: Increment sector #
0996   04E2             ;
0997   04E2 3A 25 0A    INCRSNO:LD	A,(SECTNO)	; INCR..
0998   04E5 3C          	INC	A		; ..SECT..
0999   04E6 32 25 0A    	LD	(SECTNO),A	; ..NUMBER
1000   04E9 E5          	PUSH	HL
1001   04EA 21 00 00    	LD	HL,VOUT		; CK FOR OPTIONAL COUNT TO CONSOLE
1002   04ED 7C          	LD	A,H
1003   04EE B5          	OR	L
1004   04EF C2 F4 04    	JP	NZ,CONSEC
1005   04F2 E1          	POP	HL
1006   04F3 C9          	RET
1007   04F4             ;
1008   04F4 3E 0D       CONSEC:	LD	A,CR
1009   04F6 CD 00 00    	CALL	VOUT
1010   04F9 2A 26 0A    	LD	HL,(SECCNT)	; UPDATE TOTAL SECTOR COUNT
1011   04FC 23          	INC	HL
1012   04FD 22 26 0A    	LD	(SECCNT),HL
1013   0500 CD 05 05    	CALL	DECOUTX		; DISPLAY COUNT
1014   0503 E1          	POP	HL
1015   0504 C9          	RET
1016   0505             ;
1017   0505 C5          DECOUTX:PUSH	BC
1018   0506 D5          	PUSH	DE
1019   0507 E5          	PUSH	HL
1020   0508 01 F6 FF    	LD	BC,-10
1021   050B 11 FF FF    	LD	DE,-1
1022   050E             ;
1023   050E 09          DECOU2X:ADD	HL,BC
1024   050F 13          	INC	DE
1025   0510 DA 0E 05    	JP	C,DECOU2X
1026   0513 01 0A 00    	LD	BC,10
1027   0516 09          	ADD	HL,BC
1028   0517 EB          	EX	DE,HL
1029   0518 7C          	LD	A,H
1030   0519 B5          	OR	L
1031   051A C4 05 05    	CALL	NZ,DECOUTX
1032   051D 7B          	LD	A,E
1033   051E C6 30       	ADD	A,'0'
1034   0520 CD 00 00    	CALL	VOUT
1035   0523 E1          	POP	HL
1036   0524 D1          	POP	DE
1037   0525 C1          	POP	BC
1038   0526 C9          	RET
1039   0527             ;
1040   0527             ;---->	CHEKFIL: See if file exists
1041   0527             ;
1042   0527             ;If it exists, say use a different name.
1043   0527             ;
1044   0527             CHEKFIL:
1045   0527             	.IF SETAREA
1046   0527 CD 85 09    	CALL	RECAREA		; Set the designated area up 	a 01/06/81
1047   052A             	.ENDIF
1048   052A             ;
1049   052A 11 5C 00    	LD	DE,FCB		; POINT TO CTL BLOCK
1050   052D 0E 11       	LD	C,SRCHF		; SEE IF IT..
1051   052F CD 05 00    	CALL	BDOS		; ..EXISTS
1052   0532 3C          	INC	A		; FOUND?
1053   0533 C8          	RET	Z		; ..NO, RETURN
1054   0534 CD 69 09    	CALL	ERXIT		; EXIT, PRINT ERROR MESSAGE
1055   0537 2B 2B 46 49 	.DB "++FILE EXISTS - USE "
1055   053B 4C 45 20 45 
1055   053F 58 49 53 54 
1055   0543 53 20 2D 20 
1055   0547 55 53 45 20 
1056   054B 41 20 44 49 	.DB "A DIFFERENT NAME++"
1056   054F 46 46 45 52 
1056   0553 45 4E 54 20 
1056   0557 4E 41 4D 45 
1056   055B 2B 2B 
1057   055D 0D 0A 24    	.DB CR,LF,'$'
1058   0560             ;
1059   0560             ;---->	MAKEFIL: Makes the file to be received
1060   0560             ;
1061   0560 AF          MAKEFIL:XOR	A		; SET EXT & REC # TO 0
1062   0561 32 68 00    	LD	(FCBEXT),A
1063   0564 32 7C 00    	LD	(FCBSNO),A
1064   0567 11 5C 00    	LD	DE,FCB		; POINT TO FCB
1065   056A 0E 16       	LD	C,MAKE		; GET BDOS FNC
1066   056C CD 05 00    	CALL	BDOS		; TO THE MAKE
1067   056F 3C          	INC	A		; FF=BAD?
1068   0570 C0          	RET	NZ		; OPEN OK
1069   0571             ;Directory full - can't make file
1070   0571 CD 69 09    	CALL	ERXIT
1071   0574 2B 2B 45 52 	.DB "++ERROR - CAN''T MAKE FILE++",CR,LF
1071   0578 52 4F 52 20 
1071   057C 2D 20 43 41 
1071   0580 4E 27 27 54 
1071   0584 20 4D 41 4B 
1071   0588 45 20 46 49 
1071   058C 4C 45 2B 2B 
1071   0590 0D 0A 
1072   0592 44 49 52 45 	.DB "DIRECTORY MUST BE FULL",CR,LF,'$'
1072   0596 43 54 4F 52 
1072   059A 59 20 4D 55 
1072   059E 53 54 20 42 
1072   05A2 45 20 46 55 
1072   05A6 4C 4C 0D 0A 
1072   05AA 24 
1073   05AB             ;
1074   05AB             ;---->	CNREC: Computes record count, and saves it
1075   05AB             ;	       until successful file OPEN.
1076   05AB             ;
1077   05AB             ;LOOK UP THE FCB IN THE DIRECTORY
1078   05AB 3E 3F       CNREC:	LD	A,'?'		; MATCH ALL EXTENTS
1079   05AD 32 68 00    	LD	(FCBEXT),A
1080   05B0 3E FF       	LD	A,0FFH
1081   05B2 32 21 0A    	LD	(MAXEXT),A	; INIT MAX EXT NO.
1082   05B5 0E 11       	LD	C,SRCHF		; GET 'SEARCH FIRST' FNC
1083   05B7 11 5C 00    	LD	DE,FCB
1084   05BA CD 05 00    	CALL	BDOS		; READ FIRST
1085   05BD 3C          	INC	A		; WERE THERE ANY?
1086   05BE C2 FA 05    	JP	NZ,SOME		; GOT SOME
1087   05C1 CD 69 09    	CALL	ERXIT
1088   05C4 2B 2B 46 49 	.DB "++FILE NOT FOUND++$"
1088   05C8 4C 45 20 4E 
1088   05CC 4F 54 20 46 
1088   05D0 4F 55 4E 44 
1088   05D4 2B 2B 24 
1089   05D7             ;
1090   05D7             ;READ MORE DIRECTORY ENTRIES
1091   05D7 0E 12       MOREDIR:LD	C,SRCHN		; SEARCH NEXT
1092   05D9 11 5C 00    	LD	DE,FCB
1093   05DC CD 05 00    	CALL	BDOS		; READ DIR ENTRY
1094   05DF 3C          	INC	A		; CHECK FOR END (0FFH)
1095   05E0 C2 FA 05    	JP	NZ,SOME		; NOT END OF DIR...PROCESS EXTENT
1096   05E3 3A 21 0A    	LD	A,(MAXEXT)	; HIT END...GET HIGHEST EXTENT NO. SEEN
1097   05E6 6F          	LD	L,A		; WHICH GIVES EXTENT COUNT - 1
1098   05E7 26 00       	LD	H,0
1099   05E9 54          	LD	D,H
1100   05EA 3A 22 0A    	LD	A,(RCNT)	; GET RECORD COUNT OF MAX EXTENT SEEN
1101   05ED 5F          	LD	E,A		; SAVE IT IN DE
1102   05EE 29          	ADD	HL,HL
1103   05EF 29          	ADD	HL,HL		; MULTIPLY # OF EXTENTS - 1
1104   05F0 29          	ADD	HL,HL		; TIMES 128
1105   05F1 29          	ADD	HL,HL
1106   05F2 29          	ADD	HL,HL
1107   05F3 29          	ADD	HL,HL
1108   05F4 29          	ADD	HL,HL
1109   05F5 19          	ADD	HL,DE		; ADD IN SIZE OF LAST EXTENT
1110   05F6 22 22 0A    	LD	(RCNT),HL	; SAVE TOTAL RECORD COUNT
1111   05F9 C9          	RET			; AND EXIT
1112   05FA             ;
1113   05FA             ;POINT TO DIRECTORY ENTRY 
1114   05FA 3D          SOME:	DEC	A		; UNDO PREV 'INR A'
1115   05FB E6 03       	AND	3		; MAKE MODULUS 4
1116   05FD 87          	ADD	A,A		; MULTIPLY...
1117   05FE 87          	ADD	A,A		; ..BY 32 BECAUSE
1118   05FF 87          	ADD	A,A		; ..EACH DIRECTORY
1119   0600 87          	ADD	A,A		; ..ENTRY IS 32
1120   0601 87          	ADD	A,A		; ..BYTES LONG
1121   0602 21 80 00    	LD	HL,BASE+80H	; POINT TO BUFFER
1122   0605 85          	ADD	A,L		; POINT TO ENTRY
1123   0606 C6 0F       	ADD	A,15		; OFFSET TO RECORD COUNT
1124   0608 6F          	LD	L,A		; HL NOW POINTS TO REC COUNT
1125   0609 46          	LD	B,(HL)		; GET RECORD COUNT
1126   060A 2B          	DEC	HL
1127   060B 2B          	DEC	HL		; BACK DOWN TO EXTENT NUMBER
1128   060C 2B          	DEC	HL
1129   060D 3A 21 0A    	LD	A,(MAXEXT)	; COMPARE WITH CURRENT MAX.
1130   0610 B7          	OR	A		; IF NO MAX YET
1131   0611 FA 18 06    	JP	M,BIGGER	; THEN SAVE RECORD COUNT ANYWAY
1132   0614 BE          	CP	(HL)
1133   0615 D2 D7 05    	JP	NC,MOREDIR
1134   0618             ;
1135   0618 78          BIGGER:	LD	A,B		; SAVE NEW RECORD COUNT
1136   0619 32 22 0A    	LD	(RCNT),A
1137   061C 7E          	LD	A,(HL)		; SAVE NEW MAX. EXTENT NO.
1138   061D 32 21 0A    	LD	(MAXEXT),A
1139   0620 C3 D7 05    	JP	MOREDIR		; GO FIND MORE EXTENTS
1140   0623             ;
1141   0623             ;---->	OPENFIL: Opens the file to be sent
1142   0623             ;
1143   0623 AF          OPENFIL:XOR	A		; SET EXT & REC # TO 0 FOR PROPER OPEN
1144   0624 32 68 00    	LD	(FCBEXT),A
1145   0627 32 7C 00    	LD	(FCBSNO),A
1146   062A 11 5C 00    	LD	DE,FCB		; POINT TO FILE
1147   062D 0E 0F       	LD	C,OPEN		; GET FUNCTION
1148   062F CD 05 00    	CALL	BDOS		; OPEN IT
1149   0632 3C          	INC	A		; OPEN OK?
1150   0633 C2 4A 06    	JP	NZ,OPENOK	; ..YES
1151   0636 CD 69 09    	CALL	ERXIT		; ..NO, ABORT
1152   0639 2B 2B 4F 50 	.DB "++OPEN ERROR++",CR,LF,'$'
1152   063D 45 4E 20 45 
1152   0641 52 52 4F 52 
1152   0645 2B 2B 0D 0A 
1152   0649 24 
1153   064A             ;
1154   064A             ;Check for distribution-protected file
1155   064A             ;
1156   064A 3A 5D 00    OPENOK:	LD	A,(FCB+1)	; FIRST CHAR OF FILE NAME
1157   064D E6 80       	AND	80H		; CHECK BIT 7
1158   064F C2 5A 06    	JP	NZ,OPENOT	; If on, file can't be sent.
1159   0652 3A 5E 00    	LD	A,(FCB+2)	; Also check "f2" for tag.
1160   0655 E6 80       	AND	80H		; Is it set?
1161   0657 CA 8C 06    	JP	Z,OPENOK2	; If not, ok to send file.
1162   065A             ;
1163   065A CD 69 09    OPENOT:	CALL	ERXIT		; EXIT W/MESSAGE
1164   065D 2B 2B 54 48 	.DB "++THIS FILE IS NOT FOR "
1164   0661 49 53 20 46 
1164   0665 49 4C 45 20 
1164   0669 49 53 20 4E 
1164   066D 4F 54 20 46 
1164   0671 4F 52 20 
1165   0674 44 49 53 54 	.DB "DISTRIBUTION, SORRY++"
1165   0678 52 49 42 55 
1165   067C 54 49 4F 4E 
1165   0680 2C 20 53 4F 
1165   0684 52 52 59 2B 
1165   0688 2B 
1166   0689 0D 0A 24    	.DB CR,LF,'$'
1167   068C             ;
1168   068C             OPENOK2:.EQU $
1169   068C             ;
1170   068C~            	.IF NOLBS | NOCOMS	; CHECK FOR SEND RESTRICTIONS
1171   068C~            	LD	HL,FCB+11
1172   068C~            	LD	A,(HL)		; CHECK FOR PROTECT ATTR
1173   068C~            	AND	7FH		; REMOVE CP/M 2.x ATTRS
1174   068C             	.ENDIF			; NOLBS OR NOCOMS
1175   068C             ;
1176   068C~            	.IF NOLBS		; DON'T ALLOW '#' TO BE SENT.
1177   068C~            	CP	'#'		; CHK FOR '#' AS LAST FIRST
1178   068C~            	JP	Z,OPENOT	; IF '#', CAN'T SEND, SHOW WHY
1179   068C             	.ENDIF			; NOLBS
1180   068C             ;
1181   068C~            	.IF NOCOMS		; DON'T ALLOW .COM TO BE SENT
1182   068C~            	CP	'M'		; IF NOT, CHK FOR '.COM'
1183   068C~            	JP	NZ,OPENOK3	; IF NOT, OK TO SEND
1184   068C~            	DEC	HL
1185   068C~            	LD	A,(HL)		; CHK NEXT CHAR
1186   068C~            	AND	7FH		; STRIP ATTRIBUTES
1187   068C~            	CP	'O'		; 'O'?
1188   068C~            	JP	NZ,OPENOK3	; IF NOT, OK TO SEND
1189   068C~            	DEC	HL
1190   068C~            	LD	A,(HL)		; NOW CHK FIRST CHAR
1191   068C~            	AND	7FH		; STRIP ATTRIBUTES
1192   068C~            	CP	'C'		; 'C' AS IN '.COM'?
1193   068C~            	JP	NZ,OPENOK3	; IF NOT, CONTINUE
1194   068C~            	CALL	ERXIT		; EXIT W/MESSAGE
1195   068C~            	.DB "++CAN''T SEND A .COM FILE++"
1196   068C~            	.DB CR,LF,'$'
1197   068C             	.ENDIF			; NOCOMS
1198   068C             ;
1199   068C CD 57 09    OPENOK3:CALL	ILPRT		; PRINT:
1200   068F 46 49 4C 45 	.DB "FILE OPEN -  ",0	; v48b bhk
1200   0693 20 4F 50 45 
1200   0697 4E 20 2D 20 
1200   069B 20 00 
1201   069D 2A 22 0A    	LD	HL,(RCNT)	; Get record count.
1202   06A0 CD 65 07    	CALL	DECOUT		; PRINT DECIMAL NUMBER OF SECTORS
1203   06A3 CD 57 09    	CALL	ILPRT
1204   06A6 20 28 00    	.DB " (",0
1205   06A9 CD 87 07    	CALL	DHXOUT		; Now print size in hex.
1206   06AC CD 57 09    	CALL	ILPRT
1207   06AF 20 48 45 58 	.DB " HEX) SECTORS",CR,LF ; v48b bhk
1207   06B3 29 20 53 45 
1207   06B7 43 54 4F 52 
1207   06BB 53 0D 0A 
1208   06BE 28 41 50 50 	.DB "(APPROXIMATELY ",0	; v48b bhk
1208   06C2 52 4F 58 49 
1208   06C6 4D 41 54 45 
1208   06CA 4C 59 20 00 
1209   06CE 2A 22 0A    	LD	HL,(RCNT)	; get # of sectors		; v48b bhk
1210   06D1~            	.IF LSPEED
1211   06D1~            	LD	A,(MSPEED)	; V50  JPR
1212   06D1~            	CP	B600		;  "
1213   06D1~            	PUSH	AF		;  "
1214   06D1~            	JP	NZ,S300		;  "
1215   06D1~            	XOR	A		; DIVIDE HL BY 2		   "
1216   06D1~            	LD	A,H		;  "
1217   06D1~            	RRA			;  "
1218   06D1~            	LD	H,A		;  "
1219   06D1~            	LD	A,L		;  "
1220   06D1~            	RRA			;  "
1221   06D1~            	LD	L,A		;  "
1222   06D1~            
1223   06D1~            S300:	
1224   06D1             	.ENDIF
1225   06D1 CD 29 07    	CALL	DIVHL14		; divide HL by 14 (sectors/min)	; v48b bhk
1226   06D4 E5          	PUSH	HL
1227   06D5~            	.IF LOGCAL
1228   06D5~            	LD	(PGSIZE),HL	; V50  JPR
1229   06D5             	.ENDIF
1230   06D5 26 00       	LD	H,0
1231   06D7 CD 65 07    	CALL	DECOUT		; print decimal # of minutes	; v48b bhk
1232   06DA CD 57 09    	CALL	ILPRT		; v48b bhk
1233   06DD 20 4D 49 4E 	.DB " MINS, ",0
1233   06E1 53 2C 20 00 
1234   06E5             
1235   06E5 E1          	POP	HL
1236   06E6 7C          	LD	A,H		; REMAINDER X 4 = SECONDS
1237   06E7 07          	RLCA
1238   06E8 07          	RLCA
1239   06E9 6F          	LD	L,A
1240   06EA 26 00       	LD	H,0
1241   06EC CD 65 07    	CALL	DECOUT
1242   06EF~            	.IF LSPEED
1243   06EF~            	POP	AF		; V50 JPR
1244   06EF~            	JP	NZ,MS300
1245   06EF~            	CALL	ILPRT
1246   06EF~            	.DB " SECS TO SEND AT 600 BAUD).",CR,LF ; v48b bhk
1247   06EF~            	.DB "[CONTROL-X TO CANCEL.]",CR,LF,0 ; v48c bhk
1248   06EF~            	RET
1249   06EF~            MS300:	
1250   06EF             	.ENDIF
1251   06EF CD 57 09    	CALL	ILPRT
1252   06F2 20 53 45 43 	.DB " SECS TO SEND AT 300 BAUD).",CR,LF ; v48b bhk
1252   06F6 53 20 54 4F 
1252   06FA 20 53 45 4E 
1252   06FE 44 20 41 54 
1252   0702 20 33 30 30 
1252   0706 20 42 41 55 
1252   070A 44 29 2E 0D 
1252   070E 0A 
1253   070F 5B 43 4F 4E 	.DB "[CONTROL-X TO CANCEL.]",CR,LF,0 ; v48c bhk
1253   0713 54 52 4F 4C 
1253   0717 2D 58 20 54 
1253   071B 4F 20 43 41 
1253   071F 4E 43 45 4C 
1253   0723 2E 5D 0D 0A 
1253   0727 00 
1254   0728 C9          	RET
1255   0729             ;
1256   0729             ;---->  DIVHL14: Divides HL by 14, 
1257   0729             ;	UPON EXIT: L=QUOTIENT,H=REMAINDER
1258   0729             ;
1259   0729 C5          DIVHL14:PUSH	BC
1260   072A 06 08       	LD	B,8		; SHIFT FACTOR TO B
1261   072C 0E 0E       	LD	C,14		; DIVISOR TO C
1262   072E AF          DIV2:	XOR	A		; clear carry flag and accumulator
1263   072F 29          	ADD	HL,HL
1264   0730 7C          	LD	A,H
1265   0731 91          	SUB	C
1266   0732 FA 3A 07    	JP	M,DIV3		; DONT BORROW ON NEG RESULTS
1267   0735 67          	LD	H,A
1268   0736 7D          	LD	A,L
1269   0737 F6 01       	OR	1		; BORROW 1
1270   0739 6F          	LD	L,A
1271   073A 05          DIV3:	DEC	B
1272   073B C2 2E 07    	JP	NZ,DIV2
1273   073E C1          	POP	BC
1274   073F C9          	RET
1275   0740             ;
1276   0740             ;---->	CLOSFIL: Closes the received file
1277   0740             ;
1278   0740 11 5C 00    CLOSFIL:LD	DE,FCB		; POINT TO FILE
1279   0743 0E 10       	LD	C,CLOSE		; GET FUNCTION
1280   0745 CD 05 00    	CALL	BDOS		; CLOSE IT
1281   0748 3C          	INC	A		; CLOSE OK?
1282   0749 C0          	RET	NZ		; ..YES, RETURN
1283   074A CD 69 09    	CALL	ERXIT		; ..NO, ABORT
1284   074D 2B 2B 43 41 	.DB "++CAN''T CLOSE FILE++",CR,LF,'$'
1284   0751 4E 27 27 54 
1284   0755 20 43 4C 4F 
1284   0759 53 45 20 46 
1284   075D 49 4C 45 2B 
1284   0761 2B 0D 0A 24 
1285   0765             ;
1286   0765             ;
1287   0765             ;----> DECOUT: Decimal output routine
1288   0765             ;
1289   0765 C5          DECOUT:	PUSH	BC
1290   0766 D5          	PUSH	DE
1291   0767 E5          	PUSH	HL
1292   0768 01 F6 FF    	LD	BC,-10
1293   076B 11 FF FF    	LD	DE,-1
1294   076E             ;
1295   076E 09          DECOU2:	ADD	HL,BC
1296   076F 13          	INC	DE
1297   0770 DA 6E 07    	JP	C,DECOU2
1298   0773 01 0A 00    	LD	BC,10
1299   0776 09          	ADD	HL,BC
1300   0777 EB          	EX	DE,HL
1301   0778 7C          	LD	A,H
1302   0779 B5          	OR	L
1303   077A C4 65 07    	CALL	NZ,DECOUT
1304   077D 7B          	LD	A,E
1305   077E C6 30       	ADD	A,'0'
1306   0780 CD 33 09    	CALL	CTYPE
1307   0783 E1          	POP	HL
1308   0784 D1          	POP	DE
1309   0785 C1          	POP	BC
1310   0786 C9          	RET
1311   0787             ;
1312   0787             ;---->	DHXOUT: - double precision hex output routine.
1313   0787             ;	Call with hex value in HL.
1314   0787             ;
1315   0787 E5          DHXOUT:	PUSH	HL		; Save H,L
1316   0788 F5          	PUSH	AF		; Save A
1317   0789 7C          	LD	A,H		; Get MS byte.
1318   078A CD 40 09    	CALL	HEXO		; Output hi order byte.
1319   078D 7D          	LD	A,L		; Get LS byte.
1320   078E CD 40 09    	CALL	HEXO		; Output lo order byte.
1321   0791 F1          	POP	AF		; Restore A
1322   0792 E1          	POP	HL		; Restore H,L
1323   0793 C9          	RET			; Return to caller.
1324   0794             ;
1325   0794             ;
1326   0794             ;---->	RDSECT: Reads a sector
1327   0794             ;
1328   0794             ;For speed, this routine buffers up 16
1329   0794             ;sectors at a time.
1330   0794             ;
1331   0794 3A 31 0A    RDSECT:	LD	A,(SECINBF)	; GET # SECT IN BUFF.
1332   0797 3D          	DEC	A		; DECREMENT..
1333   0798 32 31 0A    	LD	(SECINBF),A	; ..IT
1334   079B FA AB 07    	JP	M,RDBLOCK	; EXHAUSTED?  NEED MORE.
1335   079E 2A 2F 0A    	LD	HL,(SECPTR)	; GET POINTER
1336   07A1 11 80 00    	LD	DE,BASE+80H	; TO DATA
1337   07A4 CD 98 09    	CALL	MOVE128		; MOVE TO BUFFER
1338   07A7 22 2F 0A    	LD	(SECPTR),HL	; SAVE BUFFER POINTER
1339   07AA C9          	RET			; FROM "READSEC"
1340   07AB             ;
1341   07AB             ;Buffer is empty - read in another block of 16
1342   07AB             ;
1343   07AB 3A 2E 0A    RDBLOCK:LD	A,(EOFLG)	; GED EOF FLAG
1344   07AE FE 01       	CP	1		; IS IT SET?
1345   07B0 37          	SCF			; TO SHOW EOF
1346   07B1 C8          	RET	Z		; GOT EOF
1347   07B2 0E 00       	LD	C,0		; SECTORS IN BLOCK
1348   07B4 11 70 0A    	LD	DE,DBUF		; TO DISK BUFFER
1349   07B7             ;
1350   07B7 C5          RDSECLP:PUSH	BC
1351   07B8 D5          	PUSH	DE
1352   07B9 0E 1A       	LD	C,STDMA		; SET DMA..
1353   07BB CD 05 00    	CALL	BDOS		; ..ADDR
1354   07BE 11 5C 00    	LD	DE,FCB
1355   07C1 0E 14       	LD	C,READ
1356   07C3 CD 05 00    	CALL	BDOS
1357   07C6 D1          	POP	DE
1358   07C7 C1          	POP	BC
1359   07C8 B7          	OR	A		; READ OK?
1360   07C9 CA E9 07    	JP	Z,RDSECOK	; YES
1361   07CC 3D          	DEC	A		; EOF?
1362   07CD CA F8 07    	JP	Z,REOF		; GOT EOF
1363   07D0             ;
1364   07D0             ;Read error
1365   07D0             ;
1366   07D0 CD 69 09    	CALL	ERXIT
1367   07D3 2B 2B 46 49 	.DB "++FILE READ ERROR++",CR,LF,'$'
1367   07D7 4C 45 20 52 
1367   07DB 45 41 44 20 
1367   07DF 45 52 52 4F 
1367   07E3 52 2B 2B 0D 
1367   07E7 0A 24 
1368   07E9             ;
1369   07E9 21 80 00    RDSECOK:LD	HL,80H		; ADD LENGTH OF ONE SECTOR...
1370   07EC 19          	ADD	HL,DE		; ...TO NEXT BUFF
1371   07ED EB          	EX	DE,HL		; BUFF TO DE
1372   07EE 0C          	INC	C		; MORE SECTORS?
1373   07EF 79          	LD	A,C		; GET COUNT
1374   07F0 FE 10       	CP	16		; DONE?
1375   07F2 CA FE 07    	JP	Z,RDBFULL	; ..YES, BUFF IS FULL
1376   07F5 C3 B7 07    	JP	RDSECLP		; READ MORE
1377   07F8             ;
1378   07F8 3E 01       REOF:	LD	A,1
1379   07FA 32 2E 0A    	LD	(EOFLG),A	; SET EOF FLAG
1380   07FD 79          	LD	A,C
1381   07FE             ;
1382   07FE             ;Buffer is full, or got EOF
1383   07FE             ;
1384   07FE 32 31 0A    RDBFULL:LD	(SECINBF),A	; STORE SECTOR COUNT
1385   0801 21 70 0A    	LD	HL,DBUF		; INIT BUFFER..
1386   0804 22 2F 0A    	LD	(SECPTR),HL	; ..POINTER
1387   0807 11 80 00    	LD	DE,BASE+80H	; RESET..
1388   080A 0E 1A       	LD	C,STDMA		; ..DMA..
1389   080C CD 05 00    	CALL	BDOS		; ..ADDR
1390   080F C3 94 07    	JP	RDSECT		; PASS SECT TO CALLER
1391   0812             ;
1392   0812             ;---->	WRSECT: Write a sector
1393   0812             ;
1394   0812             ;Writes the sector into a buffer.  When 16
1395   0812             ;have been written, writes the block to disk.
1396   0812             ;
1397   0812             ;Entry point "WRBLOCK" flushes the buffer at EOF.
1398   0812             ;
1399   0812 2A 2F 0A    WRSECT:	LD	HL,(SECPTR)	; GET BUFF ADDR
1400   0815 EB          	EX	DE,HL		; TO DE FOR MOVE
1401   0816 21 80 00    	LD	HL,BASE+80H	; FROM HERE
1402   0819 CD 98 09    	CALL	MOVE128		; MOVE TO BUFFER
1403   081C EB          	EX	DE,HL		; SAVE NEXT..
1404   081D 22 2F 0A    	LD	(SECPTR),HL	; ..BLOCK POINTER
1405   0820 3A 31 0A    	LD	A,(SECINBF)	; BUMP THE..
1406   0823 3C          	INC	A		; ..SECTOR #..
1407   0824 32 31 0A    	LD	(SECINBF),A	; ..IN THE BUFF
1408   0827 FE 10       	CP	16		; HAVE WE 16?
1409   0829 C0          	RET	NZ		; NO, RETURN
1410   082A             ;
1411   082A             ;---->	WRBLOCK: Writes a block to disk
1412   082A             ;
1413   082A 3A 31 0A    WRBLOCK:LD	A,(SECINBF)	; # SECT IN BUFFER
1414   082D B7          	OR	A		; 0 MEANS END OF FILE
1415   082E C8          	RET	Z		; NONE TO WRITE
1416   082F 4F          	LD	C,A		; SAVE COUNT
1417   0830 11 70 0A    	LD	DE,DBUF		; POINT TO DISK BUFF
1418   0833             ;
1419   0833 E5          DKWRLP:	PUSH	HL
1420   0834 D5          	PUSH	DE
1421   0835 C5          	PUSH	BC
1422   0836 0E 1A       	LD	C,STDMA		; SET DMA
1423   0838 CD 05 00    	CALL	BDOS		; TO BUFFER
1424   083B 11 5C 00    	LD	DE,FCB		; THEN WRITE
1425   083E 0E 15       	LD	C,WRITE		; ..THE..
1426   0840 CD 05 00    	CALL	BDOS		; ..BLOCK
1427   0843 C1          	POP	BC
1428   0844 D1          	POP	DE
1429   0845 E1          	POP	HL
1430   0846 B7          	OR	A
1431   0847 C2 66 08    	JP	NZ,WRERR	; OOPS, ERROR
1432   084A 21 80 00    	LD	HL,80H		; LENGTH OF 1 SECT
1433   084D 19          	ADD	HL,DE		; HL= NEXT BUFF
1434   084E EB          	EX	DE,HL		; TO DE FOR SETDMA
1435   084F 0D          	DEC	C		; MORE SECTORS?
1436   0850 C2 33 08    	JP	NZ,DKWRLP	; ..YES, LOOP
1437   0853 AF          	XOR	A		; GET A ZERO
1438   0854 32 31 0A    	LD	(SECINBF),A	; RESET # OF SECTORS
1439   0857 21 70 0A    	LD	HL,DBUF		; RESET BUFFER..
1440   085A 22 2F 0A    	LD	(SECPTR),HL	; ..POINTER
1441   085D             ;
1442   085D 11 80 00    RSDMA:	LD	DE,BASE+80H	; RESET..
1443   0860 0E 1A       	LD	C,STDMA		; ..DMA..
1444   0862 CD 05 00    	CALL	BDOS		; ..ADDR
1445   0865 C9          	RET
1446   0866             ;
1447   0866 CD 5D 08    WRERR:	CALL	RSDMA		; RESET DMA TO NORM.
1448   0869 0E 18       	LD	C,CAN		; CANCEL..
1449   086B CD DE 08    	CALL	SEND		; ..SENDER
1450   086E CD 69 09    	CALL	ERXIT		; EXIT W/MSG:
1451   0871 2B 2B 45 52 	.DB "++ERROR WRITING FILE++",CR,LF,'$'
1451   0875 52 4F 52 20 
1451   0879 57 52 49 54 
1451   087D 49 4E 47 20 
1451   0881 46 49 4C 45 
1451   0885 2B 2B 0D 0A 
1451   0889 24 
1452   088A             ;
1453   088A             ;---->	RECV: Receive a character
1454   088A             ;
1455   088A             ;Timeout time is in B, in seconds.  Entry via
1456   088A             ;"RECVDG" deletes garbage characters on the
1457   088A             ;line.	For example, having just sent a sector,
1458   088A             ;calling RECVDG will delete any line-noise-induced
1459   088A             ;characters "long" before the ACK/NAK would
1460   088A             ;be received.
1461   088A             ;
1462   088A             RECVDG:	.EQU $			; RECEIVE W/GARBAGE DELETE
1463   088A DB 68       	IN	A,(MODDATP)	; GET A CHAR
1464   088C DB 68       	IN	A,(MODDATP)	; ..TOTALLY PURGE UART
1465   088E             ;
1466   088E D5          RECV:	PUSH	DE		; SAVE
1467   088F             ;
1468   088F~            	.IF FASTCLK		; 4MHZ?
1469   088F~            	LD	A,B		; GET TIME REQUEST
1470   088F~            	ADD	A,A		; DOUBLE IT
1471   088F~            	LD	B,A		; NEW TIME IN B
1472   088F             	.ENDIF
1473   088F             ;
1474   088F 11 50 C3    MSEC:	LD	DE,50000	; 1 SEC DCR COUNT 
1475   0892             ;
1476   0892             	.IF ~DCH
1477   0892 DB 6D       MWTI:	IN	A,(MODCTLP)	; CHECK STATUS
1478   0894             	.ENDIF
1479   0894             ;
1480   0894~            	.IF DCH
1481   0894~            MWTI:	IN	A,(MODCTL2)	; CHECK STATUS
1482   0894             	.ENDIF
1483   0894             ;
1484   0894~            	.IF PMMI & FRNTPNL
1485   0894~            	OUT	(PANEL),A	; DISPLAY STATUS ON PANEL LIGHTS
1486   0894             	.ENDIF
1487   0894             ;
1488   0894 E6 01       	AND	MODRCVB		; ISOLATE BIT
1489   0896 FE 01       	CP	MODRCVR		; READY?
1490   0898 CA B3 08    	JP	Z,MCHAR		; GOT CHAR
1491   089B 1D          	DEC	E		; COUNT..
1492   089C C2 92 08    	JP	NZ,MWTI		; ..DOWN..
1493   089F 15          	DEC	D		; ..FOR..
1494   08A0 C2 92 08    	JP	NZ,MWTI		; ..TIMEOUT
1495   08A3 05          	DEC	B		; MORE SECONDS?
1496   08A4 C2 8F 08    	JP	NZ,MSEC		; YES, WAIT
1497   08A7             ;
1498   08A7             ;Test for the presence of carrier - if none, go to 
1499   08A7             ;CARCK and continue testing for 15 seconds. If carrier
1500   08A7             ;returns, continue. If is doesn't return, exit.
1501   08A7             ;
1502   08A7~            	.IF  H8 | DCH		;  was   .IF	EXTMOD | H8 | DCH
1503   08A7~            	IN	A,(MODCTL2)	; READ MODEM STATUS
1504   08A7             	.ENDIF
1505   08A7             ;
1506   08A7 DB 6D       	IN	A,(MODCTLP)	; READ MODEM STATUS       ; 	 read correct port
1507   08A9             ;
1508   08A9~            	.IF PMMI
1509   08A9~            	IN	A,(BAUDRP)	; READ MODEM STATUS
1510   08A9             	.ENDIF
1511   08A9             ;
1512   08A9~            	.IF PMMI & FRNTPNL
1513   08A9~            	OUT	(PANEL),A	; DISPLAY STATUS ON PANEL LIGHTS
1514   08A9             	.ENDIF
1515   08A9             ;
1516   08A9 E6 02       	AND	MODDCDB		; CARRIER DETECT MASK
1517   08AB FE 00       	CP	MODDCDA		; IS IT STILL ON?
1518   08AD C4 BF 08    	CALL	NZ,CARCK	; IF NOT, TEST FOR 15 SECONDS
1519   08B0             ;
1520   08B0             ;Modem timed out receiving - but carrier still on.
1521   08B0             ;
1522   08B0 D1          	POP	DE		; RESTORE D,E
1523   08B1 37          	SCF			; CARRY SHOWS TIMEOUT
1524   08B2 C9          	RET
1525   08B3             ;
1526   08B3             ;Got character from modem
1527   08B3             ;
1528   08B3             MCHAR:
1529   08B3             ;Check to see if there was a framing error,
1530   08B3             ;overrun, or parity error.
1531   08B3             ;
1532   08B3~            	.IF PMMI | H8
1533   08B3~            	IN	A,(MODCTLP)	; GET MODEM STATUS
1534   08B3             	.ENDIF
1535   08B3             ;
1536   08B3~            	.IF DCH
1537   08B3~            	IN	A,(MODCTL2)	; GET MODEM STATUS
1538   08B3             	.ENDIF
1539   08B3             ;
1540   08B3~            	.IF PMMI | H8 | DCH
1541   08B3~            	LD	D,A		; SAVE STATUS
1542   08B3~            	AND	MODFRME		; FRAMING ERROR?
1543   08B3~            	CP	MODFRME
1544   08B3~            	JP	NZ,MCHAR2	; NO, CHECK FOR OVERRUN
1545   08B3~            	LD	A,(ERRCDE)	; GET RECV ERR CODE
1546   08B3~            	OR	MODFRME		; TURN ON RECV ERR CODE
1547   08B3~            	LD	(ERRCDE),A	; PUT IT BACK
1548   08B3~            ;
1549   08B3~            MCHAR2:	LD	A,D		; RESTORE MODEM STATUS
1550   08B3~            	AND	MODOVRE		; OVERRUN?
1551   08B3~            	CP	MODOVRE
1552   08B3~            	JP	NZ,MCHAR3	; NO, CHECK FOR PARITY ERROR
1553   08B3~            	LD	A,(ERRCDE)
1554   08B3~            	OR	MODOVRE		; TURN ON RECV ERR CODE
1555   08B3~            	LD	(ERRCDE),A
1556   08B3~            ;
1557   08B3~            MCHAR3:	LD	A,D		; RESTORE MODEM STATUS
1558   08B3~            	AND	MODPARE		; PARITY ERROR?
1559   08B3~            	CP	MODPARE
1560   08B3~            	JP	NZ,MCHAR4	; NO, GET DATA CHAR
1561   08B3~            	LD	A,(ERRCDE)
1562   08B3~            	OR	MODPARE
1563   08B3~            	LD	(ERRCDE),A
1564   08B3~            ;
1565   08B3~            MCHAR4:
1566   08B3             	.ENDIF			; PMMI OR H8 OR DCH
1567   08B3             ;
1568   08B3             ;Get data char
1569   08B3             ;
1570   08B3 DB 68       	IN	A,(MODDATP)	; READ THE CHAR
1571   08B5 D1          	POP	DE		; RESTORE DE
1572   08B6             ;
1573   08B6             ;Calc checksum and CRC
1574   08B6             ;
1575   08B6 F5          	PUSH	AF		; SAVE THE CHAR
1576   08B7 CD AC 09    	CALL	UPDCRC		; CALC CRC
1577   08BA 81          	ADD	A,C		; ADD TO CHECKSUM
1578   08BB 4F          	LD	C,A		; SAVE CHECKSUM
1579   08BC F1          	POP	AF		; RESTORE CHAR
1580   08BD B7          	OR	A		; CARRY OFF: NO ERROR
1581   08BE C9          	RET			; FROM "RECV"
1582   08BF             ;
1583   08BF             ;CARCK - common 15 second carrier test for RECV and
1584   08BF             ;SEND. If carrier returns within 15 seconds, normal
1585   08BF             ;program execution continues. Else, it will abort
1586   08BF             ;to CP/M via EXIT.
1587   08BF             ;
1588   08BF 1E 96       CARCK:	LD	E,150		; VALUE FOR 15 SECOND DELAY = 150 
1589   08C1             ;
1590   08C1 CD D2 08    CARCK1:	CALL	DELAY		; KILL .1 SECONDS
1591   08C4             ;
1592   08C4~            	.IF  H8 | DCH		;  WAS   .IF	EXTMOD | H8 | DCH
1593   08C4~            	IN	A,(MODCTL2)	; READ MODEM STATUS
1594   08C4             	.ENDIF
1595   08C4             ;
1596   08C4 DB 6D       	IN	A,(MODCTLP)	; READ MODEM STATUS       ; 	 read correct port
1597   08C6             ;
1598   08C6~            	.IF PMMI
1599   08C6~            	IN	A,(BAUDRP)	; READ MODEM STATUS
1600   08C6             	.ENDIF
1601   08C6             ;
1602   08C6~            	.IF PMMI & FRNTPNL
1603   08C6~            	OUT	(PANEL),A	; DISPLAY STATUS
1604   08C6             	.ENDIF
1605   08C6             ;
1606   08C6             	
1607   08C6             ;
1608   08C6 E6 02       	AND	MODDCDB		; CARRIER DETECT MASK
1609   08C8 FE 00       	CP	MODDCDA		; IS IT STILL ON?
1610   08CA C8          	RET	Z		; RETURN IF CARRIER ON
1611   08CB 1D          	DEC	E		; HAS 15 SECONDS EXPIRED?
1612   08CC C2 C1 08    	JP	NZ,CARCK1	; IF NOT, CONTINUE TESTING
1613   08CF C3 6F 09    	JP	EXIT		; ELSE, ABORT TO CP/M.
1614   08D2             ;
1615   08D2             ;DELAY - 100 millisecond delay.
1616   08D2             ;
1617   08D2 C5          DELAY:	PUSH	BC		; SAVE B,C
1618   08D3             ;
1619   08D3~            	.IF FASTCLK		; IF 4MHZ CLOCK
1620   08D3~            	LD	BC,16667	; VALUE FOR 100MS DELAY
1621   08D3             	.ENDIF
1622   08D3             ;
1623   08D3             	.IF ~FASTCLK
1624   08D3 01 8E 20    	LD	BC,8334		; VALUE FOR 100MS DELAY
1625   08D6             	.ENDIF
1626   08D6             ;
1627   08D6 0B          DELAY2:	DEC	BC		; UPDATE COUNT
1628   08D7 78          	LD	A,B		; GET MS BYTE
1629   08D8 B1          	OR	C		; COUNT = ZERO?
1630   08D9 C2 D6 08    	JP	NZ,DELAY2	; IF NOT, CONTINUE
1631   08DC C1          	POP	BC		; RESTORE B,C
1632   08DD C9          	RET			; RETURN TO CARCK1.
1633   08DE             ;
1634   08DE             ;---->	SEND: Send a character to the modem
1635   08DE             ;
1636   08DE F5          SEND:	PUSH	AF		; SAVE THE CHARACTER
1637   08DF CD AC 09    	CALL	UPDCRC		; Calc the crc
1638   08E2 81          	ADD	A,C		; CALC CKSUM
1639   08E3 4F          	LD	C,A		; SAVE CKSUM
1640   08E4             ;
1641   08E4             	.IF ~DCH
1642   08E4 DB 6D       SENDW:	IN	A,(MODCTLP)	; GET STATUS
1643   08E6             	.ENDIF
1644   08E6             ;
1645   08E6~            	.IF DCH
1646   08E6~            SENDW:	IN	A,(MODCTL2)	; GET STATUS
1647   08E6             	.ENDIF
1648   08E6             ;
1649   08E6~            	.IF PMMI & FRNTPNL
1650   08E6~            	OUT	(PANEL),A	; DISPLAY STATUS
1651   08E6             	.ENDIF
1652   08E6             ;
1653   08E6 E6 20       	AND	MODSNDB		; ISOLATE READY BIT
1654   08E8 FE 20       	CP	MODSNDR		; READY?
1655   08EA CA FB 08    	JP	Z,SENDR		; ..YES, GO SEND
1656   08ED             ;
1657   08ED             ;Xmit status not ready, so test for carrier before
1658   08ED             ;looping - if lost, go to CARCK and give it up to 15
1659   08ED             ;seconds to return. If it doesn't return abort via
1660   08ED             ;EXIT.
1661   08ED             ;
1662   08ED D5          	PUSH	DE		; Save D,E
1663   08EE             ;
1664   08EE~            	.IF  H8 | DCH		;  was   .IF	EXTMOD | H8 | DCH
1665   08EE~            	IN	A,(MODCTL2)	; READ MODEM STATUS
1666   08EE             	.ENDIF
1667   08EE             ;
1668   08EE DB 6D       	IN	A,(MODCTLP)	; READ MODEM STATUS       ; 	 read correct port
1669   08F0             ;
1670   08F0~            	.IF PMMI
1671   08F0~            	IN	A,(BAUDRP)	; READ MODEM STATUS
1672   08F0             	.ENDIF
1673   08F0             ;
1674   08F0~            	.IF PMMI & FRNTPNL
1675   08F0~            	OUT	(PANEL),A	; DISPLAY STATUS
1676   08F0             	.ENDIF
1677   08F0             ;
1678   08F0 E6 02       	AND	MODDCDB		; CARRIER DETECT MASK
1679   08F2 FE 00       	CP	MODDCDA		; IS IT STILL ON?
1680   08F4 C4 BF 08    	CALL	NZ,CARCK	; IF NOT, CONTINUE TESTING IT
1681   08F7 D1          	POP	DE		; RESTORE D,E
1682   08F8 C3 E4 08    	JP	SENDW		; ELSE, WAIT FOR XMIT READY.
1683   08FB             ;
1684   08FB             ;Xmit status ready, carrier still on - send the data.
1685   08FB             ;
1686   08FB F1          SENDR:	POP	AF		; GET CHAR
1687   08FC D3 68       	OUT	(MODDATP),A	; OUTPUT IT
1688   08FE CD F0 09    	CALL	PACKET		; N8VEM delay every 30 bytes
1689   0901 C9          	RET			; FROM "SEND"
1690   0902             ;
1691   0902             ;---->	WAITNAK: Waits for initial NAK
1692   0902             ;
1693   0902             ;To ensure no data is sent until the receiving
1694   0902             ;program is ready, this routine waits for the
1695   0902             ;first timeout-NAK or the letter 'C' for CRC
1696   0902             ;from the receiver.  If CRC is in effect, then
1697   0902             ;Cyclic Redundancy Checks are used instead of
1698   0902             ;checksums.
1699   0902             ;(E) contains the # of seconds to wait.
1700   0902             ;
1701   0902             ; If the first character received is a CAN (control-X)
1702   0902             ; then the send will be aborted as though it had timed out.
1703   0902             ; 04/01/82 BHK 
1704   0902             ;
1705   0902 06 01       WAITNAK:LD	B,1		; TIMEOUT DELAY
1706   0904 CD 8E 08    	CALL	RECV		; DID WE GET..
1707   0907 FE 15       	CP	NAK		; ..A NAK?
1708   0909 C8          	RET	Z		; YES, SEND BLOCK
1709   090A FE 43       	CP	CRC		; CRC INDICATED?
1710   090C CA 1B 09    	JP	Z,WAITCRC	; YES, GO PUT CRC IN EFFECT
1711   090F FE 18       	CP	CAN		; WAS IT A CANCEL (CONTROL-X)?		; v48c bhk
1712   0911 CA A7 04    	JP	Z,ABORT		; YES, ABORT				; v48c bhk
1713   0914 1D          	DEC	E		; 80 TRIES?
1714   0915 CA A7 04    	JP	Z,ABORT		; YES, ABORT
1715   0918 C3 02 09    	JP	WAITNAK		; NO, LOOP
1716   091B             ;
1717   091B             ;----> WAITCRC: Turn on CRC Flag
1718   091B             ;
1719   091B AF          WAITCRC:XOR	A		; ZERO ACCUM
1720   091C 32 2C 0A    	LD	(CRCFLG),A	; TURN ON CRC OPT
1721   091F C9          	RET
1722   0920             ;
1723   0920             ;---->	MOVEFCB: Moves FCB(2) to FCB
1724   0920             ;
1725   0920             ;In order to make the XMODEM command 'natural',
1726   0920             ;i.e. XMODEM SEND FILENAME (MODEM S FN.FT) rather
1727   0920             ;than XMODEM FILENAME SEND (MODEM FN.FT S), this
1728   0920             ;routine moves the filename from the second FCB
1729   0920             ;to the first.
1730   0920             ;
1731   0920 21 6C 00    MOVEFCB:LD	HL,FCB+16	; FROM
1732   0923 11 5C 00    	LD	DE,FCB		; TO
1733   0926 06 10       	LD	B,16		; LEN
1734   0928 CD 9A 09    	CALL	MOVE		; DO THE MOVE
1735   092B AF          	XOR	A		; GET 0
1736   092C 32 7C 00    	LD	(FCBSNO),A	; ZERO SECTOR #
1737   092F 32 68 00    	LD	(FCBEXT),A	; ..AND EXTENT
1738   0932 C9          	RET
1739   0933             ;
1740   0933 C5          CTYPE:	PUSH	BC		; SAVE..
1741   0934 D5          	PUSH	DE		; ..ALL..
1742   0935 E5          	PUSH	HL		; ..REGS
1743   0936 5F          	LD	E,A		; CHAR TO E
1744   0937 0E 02       	LD	C,WRCON		; GET BDOS FNC
1745   0939 CD 05 00    	CALL	BDOS		; PRIN THE CHR
1746   093C E1          	POP	HL		; RESTORE..
1747   093D D1          	POP	DE		; ..ALL..
1748   093E C1          	POP	BC		; ..REGS
1749   093F C9          	RET			; FROM "CTYPE"
1750   0940             ;
1751   0940 F5          HEXO:	PUSH	AF		; SAVE FOR RIGHT DIGIT
1752   0941 1F          	RRA			; RIGHT..
1753   0942 1F          	RRA			; ..JUSTIFY..
1754   0943 1F          	RRA			; ..LEFT..
1755   0944 1F          	RRA			; ..DIGIT..
1756   0945 CD 49 09    	CALL	NIBBL		; PRINT LEFT DIGIT
1757   0948 F1          	POP	AF		; RESTORE RIGHT
1758   0949             ;
1759   0949 E6 0F       NIBBL:	AND	0FH		; ISOLATE DIGIT
1760   094B FE 0A       	CP	10		; IS IT <10?
1761   094D DA 52 09    	JP	C,ISNUM		; YES, NOT ALPHA
1762   0950 C6 07       	ADD	A,7		; ADD ALPHA BIAS
1763   0952             ;
1764   0952 C6 30       ISNUM:	ADD	A,'0'		; MAKE PRINTABLE
1765   0954 C3 33 09    	JP	CTYPE		; ..THEN TYPE IT
1766   0957             ;
1767   0957             ;---->	ILPRT: Inline print of message
1768   0957             ;
1769   0957             ;The call to ILPRT is followed by a message,
1770   0957             ;binary 0 as the end.
1771   0957             ;
1772   0957 E3          ILPRT:	EX	(SP),HL		; SAVE HL, GET HL=MSG
1773   0958             ;
1774   0958 7E          ILPLP:	LD	A,(HL)		; GET CHAR
1775   0959 B7          	OR	A		; END OF MSG?
1776   095A CA 64 09    	JP	Z,ILPRET	; ..YES, RETURN
1777   095D CD 33 09    	CALL	CTYPE		; TYPE THE MSG
1778   0960 23          	INC	HL		; TO NEXT CHAR
1779   0961 C3 58 09    	JP	ILPLP		; LOOP
1780   0964             ;
1781   0964 E3          ILPRET:	EX	(SP),HL		; RESTORE HL
1782   0965 C9          	RET			; PAST MSG
1783   0966             ;
1784   0966             EXITLG:				; SPECIAL LOG CALLER EXIT
1785   0966~            	.IF LOGCAL
1786   0966~            	JP	LOGCALL
1787   0966             	.ENDIF
1788   0966 C3 6F 09    	JP	EXIT
1789   0969             ;
1790   0969             ;---->	ERXIT: Exit printing message following call
1791   0969             ;
1792   0969 D1          ERXIT:	POP	DE		; GET MESSAGE
1793   096A 0E 09       	LD	C,PRINT		; GET BDOS FNC
1794   096C CD 05 00    	CALL	BDOS		; PRINT MESSAGE
1795   096F             ;
1796   096F 2A 6E 0A    EXIT:	LD	HL,(STACK)	; GET ORIGINAL STACK
1797   0972 F9          	LD	SP,HL		; RESTORE IT
1798   0973             ;
1799   0973             	.IF SETAREA
1800   0973 CD 77 09    	CALL	RESTU		; restore old area user & drive ..a 01/06/81
1801   0976             	.ENDIF
1802   0976             ;
1803   0976 C9          	RET			; --EXIT-- TO CP/M
1804   0977             ;
1805   0977             	.IF SETAREA
1806   0977             ;
1807   0977             ;------> RESTORE THE OLD USER AREA AND DRIVE FROM A RECEIVED FILE
1808   0977             ;
1809   0977 3A 2A 0A    RESTU:	LD	A,(OLDDRV)	; RESTORE THE OLD DRIVE		;a 01/06/81
1810   097A 5F          	LD	E,A		; A 01/06/81
1811   097B CD 92 09    	CALL	RECDRX		; A 01/06/81
1812   097E 3A 29 0A    	LD	A,(OLDUSER)	; RESTORE THE OLD USER NUMBER	;a 01/06/81
1813   0981 5F          	LD	E,A		; A 01/06/81
1814   0982 C3 8A 09    	JP	RECARE		; A 01/06/81
1815   0985             ;
1816   0985             ;--------> SET USER AREA TO RECEIVE FILE
1817   0985 CD 90 09    RECAREA:CALL	RECDRV		; Ok set the drive to its place	;a 01/06/81
1818   0988 1E 00       	LD	E,RECU		; Ok now set the user area	;a 01/06/81
1819   098A 0E 20       RECARE:	LD	C,USER		; Tell bdos what we want to do	;a 01/06/81
1820   098C CD 05 00    	CALL	BDOS		; Do it				;a 01/06/81
1821   098F C9          	RET
1822   0990             ;
1823   0990 1E 00       RECDRV:	LD	E,DEFDRV-41H	; Make drive cp/m number		;a 01/06/81
1824   0992 0E 0E       RECDRX:	LD	C,SELDRV	; Tell bdos			;a 01/06/81
1825   0994 CD 05 00    	CALL	BDOS		; Do it				;a 01/06/81
1826   0997 C9          	RET			; Back				;a 01/06/81
1827   0998             	.ENDIF
1828   0998             ;
1829   0998             ;Move 128 characters
1830   0998             ;
1831   0998 06 80       MOVE128:LD	B,128		; SET MOVE COUNT
1832   099A             ;
1833   099A             ;Move from (HL) to (DE) length in (B)
1834   099A             ;
1835   099A 7E          MOVE:	LD	A,(HL)		; GET A CHAR
1836   099B 12          	LD	(DE),A		; STORE IT
1837   099C 23          	INC	HL		; TO NEXT "FROM"
1838   099D 13          	INC	DE		; TO NEXT "TO"
1839   099E 05          	DEC	B		; MORE?
1840   099F C2 9A 09    	JP	NZ,MOVE		; ..YES, LOOP
1841   09A2 C9          	RET			; ..NO, RETURN
1842   09A3             ;
1843   09A3             ;************************************************************************
1844   09A3             ;* CRCSUBS (Cyclic Redundancy Code Subroutines) version 1.20		*
1845   09A3             ;* 8080 Mnemonics							*
1846   09A3             ;*									*
1847   09A3             ;*     	These subroutines will compute and check a true 16-bit		*
1848   09A3             ;*	Cyclic Redundancy Code for a message of arbitrary length.	*
1849   09A3             ;*									*
1850   09A3             ;*	The  use  of this scheme will guarantee detection of all	*
1851   09A3             ;*	single and double bit errors, all  errors  with  an  odd	*
1852   09A3             ;*	number  of  error bits, all burst errors of length 16 or	*
1853   09A3             ;*	less, 99.9969% of all 17-bit error bursts, and  99.9984%	*
1854   09A3             ;*	of  all  possible  longer  error bursts.  (Ref: Computer	*
1855   09A3             ;*	Networks, Andrew S.  Tanenbaum, Prentiss-Hall, 1981)		*
1856   09A3             ;*									*
1857   09A3             ;*									*
1858   09A3             ;*	There are four entry points, which are used as follows:		*
1859   09A3             ;*									*
1860   09A3             ;*	CLRCRC - A call to this entry resets the CRC accumulator.	*
1861   09A3             ;*		 It must be called at the start of each message.	*
1862   09A3             ;*									*
1863   09A3             ;*		 Entry Parameters: None.				*
1864   09A3             ;*									*
1865   09A3             ;*		 Exit Conditions:  CRC accumulator cleared.		*
1866   09A3             ;*				   All registers preserved.		*
1867   09A3             ;*									*
1868   09A3             ;*									*
1869   09A3             ;*	UPDCRC - A call to this entry updates the CRC accumulator.	*
1870   09A3             ;*		 It must be called once for each byte in the		*
1871   09A3             ;*		 message for which the CRC is being calculated.		*
1872   09A3             ;*									*
1873   09A3             ;*		 Entry Parameters: (A) = a byte to be included		*
1874   09A3             ;*					 in the CRC calculation.	*
1875   09A3             ;*									*
1876   09A3             ;*		 Exit Conditions:  CRC accumulator updated.		*
1877   09A3             ;*				   All registers preserved.		*
1878   09A3             ;*									*
1879   09A3             ;*									*
1880   09A3             ;*	FINCRC - A call to this entry finishes the CRC calculation	*
1881   09A3             ;*		 for a message which is to be TRANSMITTED. It must	*
1882   09A3             ;*		 be called after the last byte of the message has	*
1883   09A3             ;*		 been passed thru UPDCRC. It returns the calculated	*
1884   09A3             ;*		 CRC bytes, which must be transmitted as the final	*
1885   09A3             ;*		 two bytes of the message (first D, then E).		*
1886   09A3             ;*									*
1887   09A3             ;*		 Entry Parameters: None.				*
1888   09A3             ;*									*
1889   09A3             ;*		 Exit Conditions:  (DE) = calculated CRC bytes.		*
1890   09A3             ;*				   All other registers preserved.	*
1891   09A3             ;*									*
1892   09A3             ;*									*
1893   09A3             ;*	CHKCRC - A call to this routine checks the CRC bytes of		*
1894   09A3             ;*		 a RECEIVED message and returns a code to indicate	*
1895   09A3             ;*		 whether the message was received correctly. It must	*
1896   09A3             ;*		 be called after the message AND the two CRC bytes	*
1897   09A3             ;*		 have been received AND passed thru UPDCRC.		*
1898   09A3             ;*									*
1899   09A3             ;*		 Entry Parameters: None.				*
1900   09A3             ;*									*
1901   09A3             ;*		 Exit Conditions:  (A) =  0 if message ok.		*
1902   09A3             ;*				   (A) = -1 if message garbled.		*
1903   09A3             ;*				   All other registers preserved.	*
1904   09A3             ;*									*
1905   09A3             ;************************************************************************
1906   09A3             ;*									*
1907   09A3             ;*	Designed & coded by Paul Hansknecht, June 13, 1981		*
1908   09A3             ;*									*
1909   09A3             ;*									*
1910   09A3             ;*	Copyright (c) 1981, Carpenter Associates			*
1911   09A3             ;*			    Box 451					*
1912   09A3             ;*			    Bloomfield Hills, MI 48013			*
1913   09A3             ;*			    313/855-3074				*
1914   09A3             ;*									*
1915   09A3             ;*	This program may be freely reproduced for non-profit use.	*
1916   09A3             ;*									*
1917   09A3             ;************************************************************************
1918   09A3             ;
1919   09A3             ;	ENTRY	CLRCRC,UPDCRC,FINCRC,CHKCRC
1920   09A3             ;
1921   09A3             CLRCRC:	.EQU $			; Reset CRC Accumulator for a new message.
1922   09A3 E5          	PUSH	HL
1923   09A4 21 00 00    	LD	HL,0
1924   09A7 22 1F 0A    	LD	(CRCVAL),HL
1925   09AA E1          	POP	HL
1926   09AB C9          	RET
1927   09AC             ;
1928   09AC             UPDCRC:	.EQU $			; Update CRC Accumulator using byte in (A).
1929   09AC F5          	PUSH	AF
1930   09AD C5          	PUSH	BC
1931   09AE E5          	PUSH	HL
1932   09AF 06 08       	LD	B,8
1933   09B1 4F          	LD	C,A
1934   09B2 2A 1F 0A    	LD	HL,(CRCVAL)
1935   09B5 79          UPDLOOP:LD	A,C
1936   09B6 07          	RLCA
1937   09B7 4F          	LD	C,A
1938   09B8 7D          	LD	A,L
1939   09B9 17          	RLA
1940   09BA 6F          	LD	L,A
1941   09BB 7C          	LD	A,H
1942   09BC 17          	RLA
1943   09BD 67          	LD	H,A
1944   09BE D2 C9 09    	JP	NC,SKIPIT
1945   09C1 7C          	LD	A,H		; The generator is X^16 + X^12 + X^5 + 1
1946   09C2 EE 10       	XOR	10H		; as recommended by CCITT.
1947   09C4 67          	LD	H,A		; An alternate generator which is often
1948   09C5 7D          	LD	A,L		; used in synchronous transmission protocols
1949   09C6 EE 21       	XOR	21H		; is X^16 + X^15 + X^2 + 1. This may be
1950   09C8 6F          	LD	L,A		; used by substituting XOR 80H for XOR 10H
1951   09C9 05          SKIPIT:	DEC	B		; and XOR 05H for XOR 21H in the adjacent code.
1952   09CA C2 B5 09    	JP	NZ,UPDLOOP
1953   09CD 22 1F 0A    	LD	(CRCVAL),HL
1954   09D0 E1          	POP	HL
1955   09D1 C1          	POP	BC
1956   09D2 F1          	POP	AF
1957   09D3 C9          	RET
1958   09D4             ;
1959   09D4             FINCRC:	.EQU $			; Finish CRC calc for outbound message.
1960   09D4 F5          	PUSH	AF
1961   09D5 AF          	XOR	A
1962   09D6 CD AC 09    	CALL	UPDCRC
1963   09D9 CD AC 09    	CALL	UPDCRC
1964   09DC E5          	PUSH	HL
1965   09DD 2A 1F 0A    	LD	HL,(CRCVAL)
1966   09E0 54          	LD	D,H
1967   09E1 5D          	LD	E,L
1968   09E2 E1          	POP	HL
1969   09E3 F1          	POP	AF
1970   09E4 C9          	RET
1971   09E5             ;
1972   09E5             CHKCRC:	.EQU $			; Check CRC bytes of received message.
1973   09E5 E5          	PUSH	HL
1974   09E6 2A 1F 0A    	LD	HL,(CRCVAL)
1975   09E9 7C          	LD	A,H
1976   09EA B5          	OR	L
1977   09EB E1          	POP	HL
1978   09EC C8          	RET	Z
1979   09ED 3E FF       	LD	A,0FFH
1980   09EF C9          	RET
1981   09F0             ; ***************** N8VEM code added Oct 2008 - add a delay after every 30 byte
1982   09F0             
1983   09F0             PACKET:				; push then pop all registers
1984   09F0 E5          	PUSH	HL		; store previous value for HL
1985   09F1 D5          	PUSH	DE		; store DE
1986   09F2 C5          	PUSH	BC		; store BC
1987   09F3 F5          	PUSH	AF		; store AF
1988   09F4 21 2B 0A    	LD	HL,OUTCNT	; count how many times have sent out the data - into HL
1989   09F7 7E          	LD	A,(HL)		; put the value in A
1990   09F8 3C          	INC	A		; a=a+1
1991   09F9 77          	LD	(HL),A		; put it back
1992   09FA D6 1E       	SUB	30		; subtract 30
1993   09FC C2 07 0A    	JP	NZ,PACKET1	; if not zero then no delay
1994   09FF 3E 00       	LD	A,0		; reset counter back to 0
1995   0A01 77          	LD	(HL),A		; and store it to memory
1996   0A02 0E 32       	LD	C,50		; delay variable try 50
1997   0A04 CD 0C 0A    	CALL	DELAYP
1998   0A07 F1          PACKET1:POP	AF		; restore AF
1999   0A08 C1          	POP	BC		; restore BC 
2000   0A09 D1          	POP	DE		; restore DE
2001   0A0A E1          	POP	HL		; restore HL
2002   0A0B C9          	RET
2003   0A0C             
2004   0A0C             DELAYP:				; delay routine, pass value in C
2005   0A0C             				; now need to add similar packet delay to xmodem					
2006   0A0C             DELCON1:
2007   0A0C             
2008   0A0C 3E FF       	LD	A,255		; 255 small loop
2009   0A0E             DELCON2:
2010   0A0E D6 01       	SUB	1		; subtract 1
2011   0A10 FE 00       	CP	0		; DECREMENT
2012   0A12 C2 0E 0A    	JP	NZ,DELCON2
2013   0A15 79          	LD	A,C		; get the next C
2014   0A16 D6 01       	SUB	1		; subtract 1	
2015   0A18 4F          	LD	C,A		; store it back to C
2016   0A19 FE 00       	CP	0		; is it 0?
2017   0A1B C2 0C 0A    	JP	NZ,DELCON1
2018   0A1E C9          	RET
2019   0A1F             ; ***** end added code ****
2020   0A1F             ;
2021   0A1F             ;
2022   0A1F 00 00       CRCVAL:	.DW 0
2023   0A21             ;
2024   0A21             ;
2025   0A21             ;
2026   0A21             ;Temporary storage area
2027   0A21             ;
2028   0A21 00          MAXEXT:	.DB 0			; HIGHEST EXTENT NO. SEEN IN FILE SIZE CALC.
2029   0A22 00 00       RCNT:	.DW 0			; RECORD COUNT
2030   0A24 00          RCVSNO:	.DB 0			; SECT # RECEIVED
2031   0A25 00          SECTNO:	.DB 0			; CURRENT SECTOR NUMBER 
2032   0A26 00 00       SECCNT:	.DW 0			; TOTAL SECTOR COUNT
2033   0A28 00          ERRCT:	.DB 0			; ERROR COUNT
2034   0A29 00          OLDUSER:.DB 0			; Save the org user number
2035   0A2A 00          OLDDRV:	.DB 0			; Save the org drive number
2036   0A2B 01          OUTCNT:	.DB 1			; reserve one byte for counter
2037   0A2C             ;
2038   0A2C~            	.IF PMMI | H8 | DCH
2039   0A2C~            ERRCDE:	.DB 0			; RECEIVE ERROR CODE
2040   0A2C             	.ENDIF
2041   0A2C             ;
2042   0A2C 43          CRCFLG:	.DB 'C'			; SET TO NULL IF CRC USED
2043   0A2D             FIRSTIME:
2044   0A2D 01          	.DB 1			; TURNED OFF AFTER FIRST SOH RECEIVED
2045   0A2E             ;
2046   0A2E             ;Following 3 used by disk buffering routines
2047   0A2E 00          EOFLG:	.DB 0			; EOF FLAG (1=TRUE)
2048   0A2F 70 0A       SECPTR:	.DW DBUF
2049   0A31 00          SECINBF:.DB 0			; # OF SECTORS IN BUFFER
2050   0A32             	.DS 60			; STACK AREA
2051   0A6E             STACK:	.DS 2			; STACK POINTER
2052   0A70             ;
2053   0A70             ;16 sector disk buffer
2054   0A70             ;
2055   0A70             DBUF:	.EQU $			; 16 SECTOR DISK BUFFER
2056   0A70             ;
2057   0A70             ;BDOS equates
2058   0A70             ;
2059   0A70             RDCON:	.EQU 1
2060   0A70             WRCON:	.EQU 2
2061   0A70             PRINT:	.EQU 9
2062   0A70             CONST:	.EQU 11			; CONSOLE STAT
2063   0A70             SELDRV:	.EQU 14			; SELECT DRIVE
2064   0A70             OPEN:	.EQU 15			; 0FFH = NOT FOUND
2065   0A70             CLOSE:	.EQU 16			; 	"       "
2066   0A70             SRCHF:	.EQU 17			; 	"       "
2067   0A70             SRCHN:	.EQU 18			; 	"       "
2068   0A70             ERASEF:	.EQU 19			; NO RET CODE
2069   0A70             READ:	.EQU 20			; 0=OK, 1=EOF
2070   0A70             WRITE:	.EQU 21			; 0=OK, 1=ERR, 2=?, 0FFH=NO DIR SPC
2071   0A70             MAKE:	.EQU 22			; 0FFH=BAD
2072   0A70             REN:	.EQU 23			; 0FFH=BAD
2073   0A70             CURDRV:	.EQU 25			; GET CURRENT DRIVE
2074   0A70             STDMA:	.EQU 26			; SET DMA
2075   0A70             USER:	.EQU 32			; SET USER AREA TO RECEIVE FILE
2076   0A70             BDOS:	.EQU BASE+5
2077   0A70             FCB:	.EQU BASE+5CH		; SYSTEM FCB
2078   0A70             FCBEXT:	.EQU FCB+12		; FILE EXTENT
2079   0A70             FCBSNO:	.EQU FCB+32		; SECTOR #
2080   0A70             FCB2:	.EQU BASE+6CH		; SECOND FCB
2081   0A70             ;
2082   0A70             
2083   0A70             ;	.org	$0CFF
2084   0A70             ;endbyte	.db	$FF
2085   0A70             
2086   0A70             ; Oct 15th deleted the above two lines so more compact
2087   0A70             
2088   0A70             	.END
tasm: Number of errors = 0
