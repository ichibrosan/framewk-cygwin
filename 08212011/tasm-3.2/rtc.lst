0001   0000             	.Title	"RTC"
0002   0000             ;
0003   0000             ; Program:	rtc.asm
0004   0000             ; Author:		Andrew Lynch
0005   0000             ; Date:		22 Feb 2007
0006   0000             ; Enviroment:	TASM MS-DOS Z80 Cross Assembler source for CP/M
0007   0000             ;
0008   0000             
0009   0000             ; constants
0010   0000             
0011   0000             ;mask_data:	.EQU	$80		; RTC data line
0012   0000             ;mask_clk:	.EQU	$40		; RTC Serial Clock line
0013   0000             ;mask_rd:	.EQU	$20		; Enable data read from RTC
0014   0000             ;mask_rst:	.EQU	$10		; De-activate RTC reset line
0015   0000             
0016   0000             mask_data:	.EQU	%10000000	; RTC data line
0017   0000             mask_clk:	.EQU	%01000000	; RTC Serial Clock line
0018   0000             mask_rd:	.EQU	%00100000	; Enable data read from RTC
0019   0000             mask_rst:	.EQU	%00010000	; De-activate RTC reset line
0020   0000             
0021   0000             RTC:		.EQU	$70		; Base address for DS1302 RTC
0022   0000             
0023   0100             	.ORG	0100H
0024   0100             
0025   0100             ; initialize time and date fields
0026   0100             
0027   0100 3E 00       	LD	A,$00
0028   0102 32 FA 08    	LD	(SECONDS),A
0029   0105 3E 45       	LD	A,$45
0030   0107 32 F9 08    	LD	(MINUTES),A
0031   010A 3E 19       	LD	A,$19
0032   010C 32 F8 08    	LD	(HOURS),A
0033   010F 3E 23       	LD	A,$23
0034   0111 32 F7 08    	LD	(DATE),A
0035   0114 3E 02       	LD	A,$02
0036   0116 32 F6 08    	LD	(MONTH),A
0037   0119 3E 07       	LD	A,$07
0038   011B 32 F5 08    	LD	(YEAR),A
0039   011E 3E 05       	LD	A,$05
0040   0120 32 FB 08    	LD	(DAY),A
0041   0123 3E 00       	LD	A,$00
0042   0125 32 FC 08    	LD	(GET_PUT),A
0043   0128             	
0044   0128             ; print message 16 times
0045   0128             
0046   0128             Print:
0047   0128 21 10 00    	LD	HL,$0010
0048   012B E5          	PUSH	HL
0049   012C             LOOP:
0050   012C 11 5E 06    	LD	DE,MSG
0051   012F 0E 09       	LD	C,09H			; CP/M write string to console call
0052   0131 CD 05 00    	CALL	0005H
0053   0134             
0054   0134 E1          	POP	HL			; Get loop counter
0055   0135 2B          	DEC	HL			;   and decrement it
0056   0136             
0057   0136 E5          	PUSH	HL			; Put back on stack
0058   0137             
0059   0137             ;	LD	A,L
0060   0137 7C          	LD	A,H			; added
0061   0138 FE 00       	CP	$00			; added
0062   013A             
0063   013A 20 F0       	JR	NZ,LOOP		; Loop while not zero
0064   013C             
0065   013C E1          	POP	HL			; Clean up stack
0066   013D             
0067   013D             ;	program starts here
0068   013D             
0069   013D CD 4B 04    	CALL	RTC_TOP_LOOP
0070   0140              
0071   0140             ;	RET	
0072   0140             
0073   0140             ;
0074   0140             ;	LD	A,$FF
0075   0140             ;	OUT	(RTC),A
0076   0140             
0077   0140             ;	JP	$f803	; MONITOR WARM START
0078   0140             
0079   0140 0E 00       	LD	C,00H			; CP/M system reset call - shut down
0080   0142 CD 05 00    	CALL	0005H
0081   0145             		
0082   0145 76          	HALT				; This code is never reached
0083   0146             
0084   0146             
0085   0146             ; function HEXSTR
0086   0146             ; input number in A
0087   0146             ; output upper nibble of number in ASCII in H
0088   0146             ; output lower nibble of number in ASCII in L
0089   0146             ; uses BC
0090   0146             ;
0091   0146             ; based on following algorithm:
0092   0146             :
0093   0146             ;  const
0094   0146             ;    hextab : string = ('0','1','2','3','4','5','6','7','8',
0095   0146             ;                       '9','A','B','C','D','E','F');
0096   0146             ;
0097   0146             ;  PROCEDURE hexstr(n: int): ^string;
0098   0146             ;  BEGIN
0099   0146             ;    n := n and 255;
0100   0146             ;    tmpstr[1] := hextab[n / 16];
0101   0146             ;    tmpstr[2] := hextab[n and 15];
0102   0146             ;    tmpstr[0] := #2;
0103   0146             ;    return @tmpstr;
0104   0146             ;  END;
0105   0146             
0106   0146             
0107   0146             HEXSTR:
0108   0146 C5          	PUSH	BC			;SAVE BC
0109   0147 47          	LD	B,A
0110   0148 CB 07       	RLC	A			;DO HIGH NIBBLE FIRST  
0111   014A CB 07       	RLC	A
0112   014C CB 07       	RLC	A
0113   014E CB 07       	RLC	A
0114   0150 E6 0F       	AND	0FH			;ONLY THIS NOW
0115   0152 C6 30       	ADD	A,30H			;TRY A NUMBER
0116   0154 FE 3A       	CP	3AH			;TEST IT
0117   0156 38 02       	JR	C,HEXSTR1		;IF CY SET SAVE 'NUMBER' in H
0118   0158 C6 07       	ADD	A,07H			;MAKE IT AN ALPHA
0119   015A             HEXSTR1:
0120   015A 67          	LD	H,A			;SAVE 'ALPHA' in H
0121   015B 78          	LD	A,B			;NEXT NIBBLE
0122   015C E6 0F       	AND	0FH			;JUST THIS
0123   015E C6 30       	ADD	A,30H			;TRY A NUMBER
0124   0160 FE 3A       	CP	3AH			;TEST IT
0125   0162 38 02       	JR	C,HEXSTR2		;IF CY SET SAVE 'NUMBER' in L
0126   0164 C6 07       	ADD	A,07H			;MAKE IT ALPHA
0127   0166             
0128   0166             HEXSTR2:
0129   0166 6F          	LD	L,A			;SAVE 'ALPHA' in L
0130   0167 C1          	POP	BC			;RESTORE BC
0131   0168 C9          	RET
0132   0169             
0133   0169             
0134   0169             ;*****************************************************
0135   0169             ;*	GET K.B. DATA & MAKE IT 'HEX'
0136   0169             ;*****************************************************
0137   0169             
0138   0169             HEXIN:
0139   0169 C5          	PUSH	BC		;SAVE BC REGS.
0140   016A CD 7E 01    	CALL	NIBL		;DO A NIBBLE
0141   016D CB 07       	RLC	A		;MOVE FIRST BYTE UPPER NIBBLE  
0142   016F CB 07       	RLC	A
0143   0171 CB 07       	RLC	A
0144   0173 CB 07       	RLC	A
0145   0175 47          	LD	B,A		;SAVE ROTATED BYTE
0146   0176 C5          	PUSH	BC
0147   0177             		
0148   0177 CD 7E 01    	CALL NIBL		;DO NEXT NIBBLE
0149   017A C1          	POP	BC
0150   017B 80          	ADD	A,B		;COMBINE NIBBLES IN ACC.
0151   017C C1          	POP	BC		;RESTORE BC
0152   017D C9          	RET			;DONE  
0153   017E             NIBL:
0154   017E 0E 01       	LD	C,01H		; CP/M console input call
0155   0180 CD 05 00    	CALL	0005H		;GET K.B. DATA
0156   0183 FE 40       	CP	40H		;TEST FOR ALPHA
0157   0185 30 03       	JR	NC,ALPH
0158   0187 E6 0F       	AND	0FH		;GET THE BITS
0159   0189 C9          	RET
0160   018A             ALPH:
0161   018A E6 0F       	AND	0FH		;GET THE BITS
0162   018C C6 09       	ADD	A,09H		;MAKE IT HEX A-F
0163   018E C9          	RET
0164   018F             
0165   018F             
0166   018F             ; function RTC_BIT_DELAY
0167   018F             ;
0168   018F             ; based on following algorithm:
0169   018F             ;
0170   018F             ;  { Make a short delay }
0171   018F             ;  PROCEDURE rtc_bit_delay;
0172   018F             ;   var
0173   018F             ;     x : int;
0174   018F             ;  BEGIN
0175   018F             ;    x := 3;
0176   018F             ;  END;
0177   018F             
0178   018F             RTC_BIT_DELAY:				; purpose is to delay ~36 uS or 144 t-states at 4MHz
0179   018F F5          	PUSH	AF			; 11 t-states
0180   0190 3E 07       	LD	A,07H			; 7 t-states ADJUST THE TIME 13h IS FOR 4 MHZ
0181   0192             RTC_BIT_DELAY1:
0182   0192 3D          	DEC	A			; 4 t-states DEC COUNTER. 4 T-states = 1 uS.
0183   0193 C2 92 01    	JP	NZ,RTC_BIT_DELAY1	; 10 t-states JUMP TO PAUSELOOP2 IF A <> 0.
0184   0196             
0185   0196 00          	NOP				; 4 t-states
0186   0197 00          	NOP				; 4 t-states
0187   0198 F1          	POP	AF			; 10 t-states
0188   0199 C9          	RET				; 10 t-states (144 t-states total)
0189   019A             
0190   019A             
0191   019A             ; function RTC_RESET
0192   019A             ;
0193   019A             ; based on following algorithm:
0194   019A             ;
0195   019A             ;  { Output a RTC reset signal }
0196   019A             ;  PROCEDURE rtc_reset;
0197   019A             ;  BEGIN
0198   019A             ;    out(rtc_base,mask_data + mask_rd);
0199   019A             ;    rtc_bit_delay();
0200   019A             ;    rtc_bit_delay();
0201   019A             ;    out(rtc_base,mask_data + mask_rd + mask_rst);
0202   019A             ;    rtc_bit_delay();
0203   019A             ;    rtc_bit_delay();
0204   019A             ;  END;
0205   019A             ;
0206   019A             RTC_RESET:
0207   019A 3E A0       	LD	A,mask_data + mask_rd
0208   019C D3 70       	OUT	(RTC),A
0209   019E CD 8F 01    	CALL	RTC_BIT_DELAY
0210   01A1 CD 8F 01    	CALL	RTC_BIT_DELAY
0211   01A4 3E B0       	LD	A,mask_data + mask_rd + mask_rst
0212   01A6 D3 70       	OUT	(RTC),A
0213   01A8 CD 8F 01    	CALL	RTC_BIT_DELAY
0214   01AB CD 8F 01    	CALL	RTC_BIT_DELAY
0215   01AE C9          	RET
0216   01AF             
0217   01AF             
0218   01AF             ; function RTC_RESET_ON
0219   01AF             ;
0220   01AF             ; based on following algorithm:
0221   01AF             ;
0222   01AF             ;  { Assert RTC reset signal }
0223   01AF             ;  PROCEDURE rtc_reset_on;
0224   01AF             ;  BEGIN
0225   01AF             ;    out(rtc_base,mask_data + mask_rd);
0226   01AF             ;    rtc_bit_delay();
0227   01AF             ;    rtc_bit_delay();
0228   01AF             ;  END;
0229   01AF             
0230   01AF             RTC_RESET_ON:
0231   01AF 3E A0       	LD	A,mask_data + mask_rd
0232   01B1 D3 70       	OUT	(RTC),A
0233   01B3 CD 8F 01    	CALL	RTC_BIT_DELAY
0234   01B6 CD 8F 01    	CALL	RTC_BIT_DELAY
0235   01B9 C9          	RET
0236   01BA             
0237   01BA             ; function RTC_RESET_OFF
0238   01BA             ;
0239   01BA             ; based on following algorithm:
0240   01BA             ;
0241   01BA             ;  { De-assert RTC reset signal }
0242   01BA             ;  PROCEDURE rtc_reset_off;
0243   01BA             ;  BEGIN
0244   01BA             ;    out(rtc_base,mask_data + mask_rd + mask_rst);
0245   01BA             ;    rtc_bit_delay();
0246   01BA             ;    rtc_bit_delay();
0247   01BA             ;  END;
0248   01BA             
0249   01BA             RTC_RESET_OFF:
0250   01BA 3E B0       	LD	A,mask_data + mask_rd + mask_rst
0251   01BC D3 70       	OUT	(RTC),A
0252   01BE CD 8F 01    	CALL	RTC_BIT_DELAY
0253   01C1 CD 8F 01    	CALL	RTC_BIT_DELAY
0254   01C4 C9          	RET
0255   01C5             
0256   01C5             ; function RTC_WR
0257   01C5             ; input value in C
0258   01C5             ; uses A
0259   01C5             ;
0260   01C5             ;  PROCEDURE rtc_wr(n : int);
0261   01C5             ;   var
0262   01C5             ;    i : int;
0263   01C5             ;  BEGIN
0264   01C5             ;    for i := 0 while i < 8 do inc(i) loop
0265   01C5             ;       if (n and 1) <> 0 then
0266   01C5             ;          out(rtc_base,mask_rst + mask_data);
0267   01C5             ;          rtc_bit_delay();
0268   01C5             ;          out(rtc_base,mask_rst + mask_clk + mask_data);
0269   01C5             ;       else
0270   01C5             ;          out(rtc_base,mask_rst);
0271   01C5             ;          rtc_bit_delay();
0272   01C5             ;          out(rtc_base,mask_rst + mask_clk);
0273   01C5             ;       end;
0274   01C5             ;       rtc_bit_delay();
0275   01C5             ;       n := shr(n,1);
0276   01C5             ;    end loop;
0277   01C5             ;  END;
0278   01C5             
0279   01C5             RTC_WR:
0280   01C5 AF          	XOR	A			; set A=0 index counter of FOR loop
0281   01C6             
0282   01C6             RTC_WR1:
0283   01C6 F5          	PUSH	AF			; save accumulator as it is the index counter in FOR loop
0284   01C7 79          	LD	A,C			; get the value to be written in A from C (passed value to write in C)
0285   01C8 CB 47       	BIT	0,A			; is LSB a 0 or 1?
0286   01CA CA DB 01    	JP	Z,RTC_WR2		; if it’s a 0, handle it at RTC_WR2.
0287   01CD             					; LSB is a 1, handle it below
0288   01CD             					; setup RTC latch with RST and DATA high, SCLK low
0289   01CD 3E 90       	LD	A,mask_rst + mask_data
0290   01CF D3 70       	OUT	(RTC),A		; output to RTC latch
0291   01D1 CD 8F 01    	CALL	RTC_BIT_DELAY	; let it settle a while
0292   01D4             					; setup RTC with RST, DATA, and SCLK high
0293   01D4 3E D0       	LD	A,mask_rst + mask_clk + mask_data
0294   01D6 D3 70       	OUT	(RTC),A		; output to RTC latch
0295   01D8 C3 E6 01    	JP	RTC_WR3		; exit FOR loop 
0296   01DB             
0297   01DB             RTC_WR2:
0298   01DB             					; LSB is a 0, handle it below
0299   01DB 3E 10       	LD	A,mask_rst		; setup RTC latch with RST high, SCLK and DATA low
0300   01DD D3 70       	OUT	(RTC),A		; output to RTC latch
0301   01DF CD 8F 01    	CALL	RTC_BIT_DELAY	; let it settle a while
0302   01E2             					; setup RTC with RST and SCLK high, DATA low
0303   01E2 3E 50       	LD	A,mask_rst + mask_clk
0304   01E4 D3 70       	OUT	(RTC),A		; output to RTC latch
0305   01E6             
0306   01E6             RTC_WR3:
0307   01E6 CD 8F 01    	CALL	RTC_BIT_DELAY	; let it settle a while
0308   01E9 CB 09       	RRC	C			; move next bit into LSB position for processing to RTC
0309   01EB F1          	POP	AF			; recover accumulator as it is the index counter in FOR loop
0310   01EC 3C          	INC	A			; increment A in FOR loop (A=A+1)
0311   01ED FE 08       	CP	$08			; is A < $08 ?
0312   01EF C2 C6 01    	JP	NZ,RTC_WR1		; No, do FOR loop again
0313   01F2 C9          	RET				; Yes, end function and return
0314   01F3             
0315   01F3             
0316   01F3             ; function RTC_RD
0317   01F3             ; output value in C
0318   01F3             ; uses A
0319   01F3             ;
0320   01F3             ; function RTC_RD
0321   01F3             ;
0322   01F3             ;  PROCEDURE rtc_rd(): int ;
0323   01F3             ;   var
0324   01F3             ;     i,n,mask : int;
0325   01F3             ;  BEGIN
0326   01F3             ;    n := 0;
0327   01F3             ;    mask := 1;
0328   01F3             ;    for i := 0 while i < 8 do inc(i) loop
0329   01F3             ;       out(rtc_base,mask_rst + mask_rd);
0330   01F3             ;       rtc_bit_delay();
0331   01F3             ;       if (in(rtc_base) and #1) <> #0 then
0332   01F3             ;          { Data = 1 }
0333   01F3             ;          n := n + mask;
0334   01F3             ;       else
0335   01F3             ;          { Data = 0 }
0336   01F3             ;       end;
0337   01F3             ;       mask := shl(mask,1);
0338   01F3             ;       out(rtc_base,mask_rst + mask_clk + mask_rd);
0339   01F3             ;       rtc_bit_delay();
0340   01F3             ;    end loop;
0341   01F3             ;    return n;
0342   01F3             ;  END;
0343   01F3             
0344   01F3             RTC_RD:
0345   01F3 AF          	XOR	A			; set A=0 index counter of FOR loop
0346   01F4 0E 00       	LD	C,$00			; set C=0 output of RTC_RD is passed in C
0347   01F6 06 01       	LD	B,$01			; B is mask value
0348   01F8             
0349   01F8             RTC_RD1:
0350   01F8 F5          	PUSH	AF			; save accumulator as it is the index counter in FOR loop
0351   01F9             					; setup RTC with RST and RD high, SCLK low
0352   01F9 3E 30       	LD	A,mask_rst + mask_rd
0353   01FB D3 70       	OUT	(RTC),A		; output to RTC latch
0354   01FD CD 8F 01    	CALL	RTC_BIT_DELAY	; let it settle a while
0355   0200 DB 70       	IN	A,(RTC)		; input from RTC latch
0356   0202 CB 47       	BIT	0,A			; is LSB a 0 or 1?
0357   0204 CA 0A 02    	JP	Z,RTC_RD2		; if LSB is a 1, handle it below
0358   0207 79          	LD	A,C
0359   0208 80          	ADD	A,B
0360   0209 4F          	LD	C,A
0361   020A             ;	INC	C
0362   020A             					; if LSB is a 0, skip it (C=C+0)
0363   020A             RTC_RD2:
0364   020A CB 00       	RLC	B			; move input bit out of LSB position to save it in C
0365   020C             					; setup RTC with RST, SCLK high, and RD high
0366   020C 3E 70       	LD	A,mask_rst + mask_clk + mask_rd
0367   020E D3 70       	OUT	(RTC),A		; output to RTC latch
0368   0210 CD 8F 01    	CALL	RTC_BIT_DELAY	; let it settle
0369   0213 F1          	POP	AF			; recover accumulator as it is the index counter in FOR loop
0370   0214 3C          	INC	A			; increment A in FOR loop (A=A+1)
0371   0215 FE 08       	CP	$08			; is A < $08 ?
0372   0217 C2 F8 01    	JP	NZ,RTC_RD1		; No, do FOR loop again
0373   021A C9          	RET				; Yes, end function and return.  Read RTC value is in C
0374   021B             
0375   021B             ; function RTC_WRITE
0376   021B             ; input address in D
0377   021B             ; input value in E
0378   021B             ; uses A
0379   021B             ;
0380   021B             ; based on following algorithm:		
0381   021B             ;
0382   021B             ;  PROCEDURE rtc_write(address, value: int);
0383   021B             ;  BEGIN
0384   021B             ;    lock();
0385   021B             ;    rtc_reset_off();
0386   021B             ;    { Write command }
0387   021B             ;    rtc_wr(128 + shl(address and $3f,1));
0388   021B             ;    { Write data }
0389   021B             ;    rtc_wr(value and $ff);
0390   021B             ;    rtc_reset_on();
0391   021B             ;    unlock();
0392   021B             ;  END;
0393   021B             
0394   021B             RTC_WRITE:
0395   021B F3          	DI				; disable interrupts during critical section
0396   021C CD BA 01    	CALL	RTC_RESET_OFF	; turn off RTC reset
0397   021F 7A          	LD	A,D			; bring into A the address from D
0398   0220             ;	AND	$3F			; keep only bits 6 LSBs, discard 2 MSBs
0399   0220 E6 3F       	AND	%00111111		; keep only bits 6 LSBs, discard 2 MSBs
0400   0222 CB 07       	RLC	A			; rotate address bits to the left
0401   0224             ;	ADD	A,$80			; set MSB to one for DS1302 COMMAND BYTE (WRITE)
0402   0224 C6 80       	ADD	A,%10000000		; set MSB to one for DS1302 COMMAND BYTE (WRITE)
0403   0226 4F          	LD	C,A			; RTC_WR expects write data (address) in reg C
0404   0227 CD C5 01    	CALL	RTC_WR		; write address to DS1302
0405   022A 7B          	LD	A,E			; start processing value
0406   022B E6 FF       	AND	$FF			; seems unnecessary, probably delete since all values are 8-bit
0407   022D 4F          	LD	C,A			; RTC_WR expects write data (value) in reg C
0408   022E CD C5 01    	CALL	RTC_WR		; write address to DS1302
0409   0231 CD AF 01    	CALL	RTC_RESET_ON	; turn on RTC reset
0410   0234 FB          	EI
0411   0235 C9          	RET
0412   0236             
0413   0236             
0414   0236             ; function RTC_READ
0415   0236             ; input address in D
0416   0236             ; output value in C
0417   0236             ; uses A
0418   0236             ;
0419   0236             ; based on following algorithm
0420   0236             ;
0421   0236             ;  PROCEDURE rtc_read(address: int): int;
0422   0236             ;   var
0423   0236             ;     n : int;
0424   0236             ;  BEGIN
0425   0236             ;    lock();
0426   0236             ;    rtc_reset_off();
0427   0236             ;    { Write command }
0428   0236             ;    rtc_wr(128 + shl(address and $3f,1) + 1);
0429   0236             ;    { Read data }
0430   0236             ;    n := rtc_rd();
0431   0236             ;    rtc_reset_on();
0432   0236             ;    unlock();
0433   0236             ;    return n;
0434   0236             ;  END;
0435   0236             
0436   0236             RTC_READ:
0437   0236 F3          	DI				; disable interrupts during critical section
0438   0237 CD BA 01    	CALL	RTC_RESET_OFF	; turn off RTC reset
0439   023A 7A          	LD	A,D			; bring into A the address from D
0440   023B             ;	AND	$3F			; keep only bits 6 LSBs, discard 2 MSBs
0441   023B E6 3F       	AND	%00111111		; keep only bits 6 LSBs, discard 2 MSBs
0442   023D CB 07       	RLC	A			; rotate address bits to the left
0443   023F             ;	ADD	A,$81			; set MSB to one for DS1302 COMMAND BYTE (READ)
0444   023F C6 81       	ADD	A,%10000001		; set MSB to one for DS1302 COMMAND BYTE (READ)
0445   0241 4F          	LD	C,A			; RTC_WR expects write data (address) in reg C
0446   0242 CD C5 01    	CALL	RTC_WR		; write address to DS1302
0447   0245 CD F3 01    	CALL	RTC_RD		; read value from DS1302 (value is in reg C)
0448   0248 CD AF 01    	CALL	RTC_RESET_ON	; turn on RTC reset
0449   024B FB          	EI
0450   024C C9          	RET
0451   024D             
0452   024D             
0453   024D             ; function RTC_WR_PROTECT
0454   024D             ; input D (address) $07
0455   024D             ; input E (value) $80
0456   024D             ; uses A
0457   024D             ;
0458   024D             ; based on following algorithm
0459   024D             ;
0460   024D             ;  PROCEDURE rtc_wr_protect;
0461   024D             ;  BEGIN
0462   024D             ;    rtc_write(7,128);
0463   024D             ;  END;
0464   024D             
0465   024D             RTC_WR_PROTECT:
0466   024D             ;	LD	D,$07
0467   024D 16 07       	LD	D,%00000111
0468   024F             ;	LD	E,$80
0469   024F 1E 80       	LD	E,%10000000
0470   0251 CD 1B 02    	CALL	RTC_WRITE
0471   0254 C9          	RET
0472   0255             
0473   0255             
0474   0255             ; function RTC_WR_UNPROTECT
0475   0255             ; input D (address) $07
0476   0255             ; input E (value) $00
0477   0255             ; uses A
0478   0255             ;
0479   0255             ; based on following algorithm
0480   0255             ;
0481   0255             ;  PROCEDURE rtc_wr_unprotect;
0482   0255             ;  BEGIN
0483   0255             ;    rtc_write(7,0);
0484   0255             ;  END;
0485   0255             
0486   0255             RTC_WR_UNPROTECT:
0487   0255             ;	LD	D,$07
0488   0255 16 07       	LD	D,%00000111
0489   0257             ;	LD	E,$00
0490   0257 1E 00       	LD	E,%00000000
0491   0259 CD 1B 02    	CALL	RTC_WRITE
0492   025C C9          	RET
0493   025D             
0494   025D             
0495   025D             ; function RTC_GET_TIME
0496   025D             ; input HL (memory address of buffer)
0497   025D             ; uses A,C,D,E
0498   025D             ;
0499   025D             ; based on following algorithm
0500   025D             ;
0501   025D             ;  PROCEDURE rtc_get_time(var buf: string);
0502   025D             ;   var
0503   025D             ;     n  : int;
0504   025D             ;  BEGIN
0505   025D             ;    lock();
0506   025D             ;    rtc_reset_off();
0507   025D             ;    { Write command, burst read }
0508   025D             ;    rtc_wr(255 - 64);
0509   025D             ;    { Read seconds }
0510   025D             ;    n := rtc_rd(); 0
0511   025D             ;    buf[16] := char(((n / 16) and $07)) + '0';
0512   025D             ;    buf[17] := char((n and $0f)) + '0';
0513   025D             ;    { Read minutes }
0514   025D             ;    n := rtc_rd(); 1
0515   025D             ;    buf[13] := char(((n / 16) and $07)) + '0';
0516   025D             ;    buf[14] := char((n and $0f)) + '0';
0517   025D             ;    buf[15] := ':';
0518   025D             ;    { Read hours }
0519   025D             ;    n := rtc_rd(); 2
0520   025D             ;    buf[10] := char(((n / 16) and $03)) + '0';
0521   025D             ;    buf[11] := char((n and $0f)) + '0';
0522   025D             ;    buf[12] := ':';
0523   025D             ;    { Read date }
0524   025D             ;    n := rtc_rd(); 3
0525   025D             ;    buf[7] := char(((n / 16) and $03)) + '0';
0526   025D             ;    buf[8] := char((n and $0f)) + '0';
0527   025D             ;    buf[9] := ' ';
0528   025D             ;    { Read month }
0529   025D             ;    n := rtc_rd(); 4
0530   025D             ;    buf[4] := char(((n / 16) and $03)) + '0';
0531   025D             ;    buf[5] := char((n and $0f)) + '0';
0532   025D             ;    buf[6] := '-';
0533   025D             ;    { Read day }
0534   025D             ;    n := rtc_rd(); 5
0535   025D             ;    {
0536   025D             ;    buf[4] := char(((n / 16) and $03)) + '0';
0537   025D             ;    buf[4] := char((n and $0f)) + '0';
0538   025D             ;    }
0539   025D             ;    { Read year }
0540   025D             ;    n := rtc_rd(); 6
0541   025D             ;    buf[1] := char(((n / 16) and $0f)) + '0';
0542   025D             ;    buf[2] := char((n and $0f)) + '0';
0543   025D             ;    buf[3] := '-';
0544   025D             ;    length(buf) := 17;
0545   025D             ;    rtc_reset_on();
0546   025D             ;    unlock();
0547   025D             ;  END rtc_get_time;
0548   025D             
0549   025D             RTC_GET_TIME:
0550   025D F3          	DI				; disable interrupts during DS1302 read
0551   025E CD BA 01    	CALL	RTC_RESET_OFF		; turn of RTC reset
0552   0261             					;    { Write command, burst read }
0553   0261 0E BF       	LD	C,%10111111		; (255 - 64)
0554   0263 CD C5 01    	CALL	RTC_WR			; send COMMAND BYTE (BURST READ) to DS1302
0555   0266             
0556   0266             ;    { Read seconds }
0557   0266             
0558   0266 CD F3 01    	CALL	RTC_RD			; read value from DS1302, value is in Reg C
0559   0269             
0560   0269             	; digit 16
0561   0269 79          	LD	A,C			; put value output in Reg C into accumulator
0562   026A CB 07       	RLC	A
0563   026C CB 07       	RLC	A
0564   026E CB 07       	RLC	A
0565   0270 CB 07       	RLC	A
0566   0272 E6 07       	AND	$07
0567   0274 C6 30       	ADD	A,'0'
0568   0276 32 E8 08    	LD	(RTC_PRINT_BUFFER+15),A
0569   0279             
0570   0279             	; digit 17
0571   0279 79          	LD	A,C			; put value output in Reg C into accumulator
0572   027A E6 0F       	AND	$0F
0573   027C C6 30       	ADD	A,'0'
0574   027E 32 E9 08    	LD	(RTC_PRINT_BUFFER+16),A
0575   0281             
0576   0281             ;    { Read minutes }
0577   0281             
0578   0281 CD F3 01    	CALL	RTC_RD			; read value from DS1302, value is in Reg C
0579   0284             
0580   0284             	; digit 13
0581   0284 79          	LD	A,C			; put value output in Reg C into accumulator
0582   0285 CB 07       	RLC	A
0583   0287 CB 07       	RLC	A
0584   0289 CB 07       	RLC	A
0585   028B CB 07       	RLC	A
0586   028D E6 07       	AND	$07
0587   028F C6 30       	ADD	A,'0'
0588   0291 32 E5 08    	LD	(RTC_PRINT_BUFFER+12),A
0589   0294             
0590   0294             	; digit 14
0591   0294 79          	LD	A,C			; put value output in Reg C into accumulator
0592   0295 E6 0F       	AND	$0F
0593   0297 C6 30       	ADD	A,'0'
0594   0299 32 E6 08    	LD	(RTC_PRINT_BUFFER+13),A
0595   029C             
0596   029C             	; digit 15	
0597   029C 3E 3A       	LD	A,':'
0598   029E 32 E7 08    	LD	(RTC_PRINT_BUFFER+14),A
0599   02A1             
0600   02A1             ;    { Read hours }
0601   02A1             
0602   02A1 CD F3 01    	CALL	RTC_RD			; read value from DS1302, value is in Reg C
0603   02A4             
0604   02A4             	; digit 10
0605   02A4 79          	LD	A,C			; put value output in Reg C into accumulator
0606   02A5 CB 07       	RLC	A
0607   02A7 CB 07       	RLC	A
0608   02A9 CB 07       	RLC	A
0609   02AB CB 07       	RLC	A
0610   02AD E6 03       	AND	$03
0611   02AF C6 30       	ADD	A,'0'
0612   02B1 32 E2 08    	LD	(RTC_PRINT_BUFFER+09),A
0613   02B4             
0614   02B4             	; digit 11
0615   02B4 79          	LD	A,C			; put value output in Reg C into accumulator
0616   02B5 E6 0F       	AND	$0F
0617   02B7 C6 30       	ADD	A,'0'
0618   02B9 32 E3 08    	LD	(RTC_PRINT_BUFFER+10),A
0619   02BC             
0620   02BC             	; digit 12
0621   02BC 3E 3A       	LD	A,':'
0622   02BE 32 E4 08    	LD	(RTC_PRINT_BUFFER+11),A
0623   02C1             
0624   02C1             ;    { Read date }
0625   02C1             
0626   02C1 CD F3 01    	CALL	RTC_RD			; read value from DS1302, value is in Reg C
0627   02C4             
0628   02C4             	; digit 07
0629   02C4 79          	LD	A,C			; put value output in Reg C into accumulator
0630   02C5 CB 07       	RLC	A
0631   02C7 CB 07       	RLC	A
0632   02C9 CB 07       	RLC	A
0633   02CB CB 07       	RLC	A
0634   02CD E6 03       	AND	$03
0635   02CF C6 30       	ADD	A,'0'
0636   02D1 32 DF 08    	LD	(RTC_PRINT_BUFFER+06),A
0637   02D4             
0638   02D4             	; digit 08
0639   02D4 79          	LD	A,C			; put value output in Reg C into accumulator
0640   02D5 E6 0F       	AND	$0F
0641   02D7 C6 30       	ADD	A,'0'
0642   02D9 32 E0 08    	LD	(RTC_PRINT_BUFFER+07),A
0643   02DC             
0644   02DC             	; digit 09
0645   02DC 3E 20       	LD	A,' '
0646   02DE 32 E1 08    	LD	(RTC_PRINT_BUFFER+08),A
0647   02E1             
0648   02E1             ;    { Read month }
0649   02E1             
0650   02E1 CD F3 01    	CALL	RTC_RD			; read value from DS1302, value is in Reg C
0651   02E4             
0652   02E4             	; digit 04
0653   02E4 79          	LD	A,C			; put value output in Reg C into accumulator
0654   02E5 CB 07       	RLC	A
0655   02E7 CB 07       	RLC	A
0656   02E9 CB 07       	RLC	A
0657   02EB CB 07       	RLC	A
0658   02ED E6 03       	AND	$03
0659   02EF C6 30       	ADD	A,'0'
0660   02F1 32 DC 08    	LD	(RTC_PRINT_BUFFER+03),A
0661   02F4             
0662   02F4             	; digit 05
0663   02F4 79          	LD	A,C			; put value output in Reg C into accumulator
0664   02F5 E6 0F       	AND	$0F
0665   02F7 C6 30       	ADD	A,'0'
0666   02F9 32 DD 08    	LD	(RTC_PRINT_BUFFER+04),A
0667   02FC             
0668   02FC             	; digit 06
0669   02FC 3E 2D       	LD	A,'-'
0670   02FE 32 DE 08    	LD	(RTC_PRINT_BUFFER+05),A
0671   0301             
0672   0301             ;    { Read day }
0673   0301             
0674   0301 CD F3 01    	CALL	RTC_RD			; read value from DS1302, value is in Reg C
0675   0304             
0676   0304             	; digit 04
0677   0304             ;	LD	A,C			; put value output in Reg C into accumulator
0678   0304             ;	RLC	A
0679   0304             ;	RLC	A
0680   0304             ;	RLC	A
0681   0304             ;	RLC	A
0682   0304             ;	AND	$03
0683   0304             ;	ADD	A,'0'
0684   0304             ;	LD	(RTC_PRINT_BUFFER+03),A
0685   0304             
0686   0304             	; digit 04
0687   0304             ;	LD	A,C			; put value output in Reg C into accumulator
0688   0304             ;	AND	$0F
0689   0304             ;	ADD	A,'0'
0690   0304             ;	LD	(RTC_PRINT_BUFFER+03),A
0691   0304             
0692   0304             ; add special code to put "DAY" value at end of string until better solution known
0693   0304             
0694   0304             	; digit 18
0695   0304 3E 2D       	LD	A,'-'
0696   0306 32 EA 08    	LD	(RTC_PRINT_BUFFER+17),A
0697   0309             
0698   0309             	; digit 19
0699   0309 79          	LD	A,C			; put value output in Reg C into accumulator
0700   030A CB 07       	RLC	A
0701   030C CB 07       	RLC	A
0702   030E CB 07       	RLC	A
0703   0310 CB 07       	RLC	A
0704   0312 E6 0F       	AND	$0F
0705   0314 C6 30       	ADD	A,'0'
0706   0316 32 EB 08    	LD	(RTC_PRINT_BUFFER+18),A
0707   0319             
0708   0319             	; digit 20
0709   0319 79          	LD	A,C			; put value output in Reg C into accumulator
0710   031A E6 0F       	AND	$0F
0711   031C C6 30       	ADD	A,'0'
0712   031E 32 EC 08    	LD	(RTC_PRINT_BUFFER+19),A
0713   0321             
0714   0321             
0715   0321             
0716   0321             
0717   0321             ;    { Read year }
0718   0321             
0719   0321 CD F3 01    	CALL	RTC_RD			; read value from DS1302, value is in Reg C
0720   0324             
0721   0324             	; digit 01
0722   0324 79          	LD	A,C			; put value output in Reg C into accumulator
0723   0325 CB 07       	RLC	A
0724   0327 CB 07       	RLC	A
0725   0329 CB 07       	RLC	A
0726   032B CB 07       	RLC	A
0727   032D E6 0F       	AND	$0F
0728   032F C6 30       	ADD	A,'0'
0729   0331 32 D9 08    	LD	(RTC_PRINT_BUFFER+00),A
0730   0334             
0731   0334             	; digit 02
0732   0334 79          	LD	A,C			; put value output in Reg C into accumulator
0733   0335 E6 0F       	AND	$0F
0734   0337 C6 30       	ADD	A,'0'
0735   0339 32 DA 08    	LD	(RTC_PRINT_BUFFER+01),A
0736   033C             
0737   033C             	; digit 03
0738   033C 3E 2D       	LD	A,'-'
0739   033E 32 DB 08    	LD	(RTC_PRINT_BUFFER+02),A
0740   0341             
0741   0341 CD AF 01    	CALL	RTC_RESET_ON		; turn RTC reset back on 
0742   0344 FB          	EI				; re-enable interrupts
0743   0345             
0744   0345 C9          	RET				; Yes, end function and return
0745   0346             
0746   0346             
0747   0346             ; function RTC_SET_NOW
0748   0346             ; uses A, D, E
0749   0346             ;
0750   0346             ; based on following algorithm
0751   0346             ;
0752   0346             ;  { Set time to 96-02-18 19:43:00 }
0753   0346             ;  PROCEDURE rtc_set_now;
0754   0346             ;  BEGIN
0755   0346             ;    rtc_wr_unprotect();
0756   0346             ;    { Set seconds }
0757   0346             ;    rtc_write(0,0);
0758   0346             ;    { Set minutes }
0759   0346             ;    rtc_write(1,$43);
0760   0346             ;    { Set hours }
0761   0346             ;    rtc_write(2,$19);
0762   0346             ;    { Set date }
0763   0346             ;    rtc_write(3,$18);
0764   0346             ;    { Set month }
0765   0346             ;    rtc_write(4,$02);
0766   0346             ;    { Set day }
0767   0346             ;    rtc_write(5,$07);
0768   0346             ;    { Set year }
0769   0346             ;    rtc_write(6,$96);
0770   0346             ;    rtc_wr_protect();
0771   0346             ;  END;
0772   0346             
0773   0346             RTC_SET_NOW:
0774   0346             ; set time to 07-02-23 19:45:00-05 <-Friday
0775   0346 CD 55 02    	CALL RTC_WR_UNPROTECT
0776   0349             ; seconds
0777   0349 16 00       	LD	D,$00
0778   034B 3A FA 08    	LD	A,(SECONDS)
0779   034E 5F          	LD	E,A
0780   034F CD 1B 02    	CALL RTC_WRITE
0781   0352             
0782   0352             ; minutes
0783   0352 16 01       	LD	D,$01
0784   0354 3A F9 08    	LD	A,(MINUTES)
0785   0357 5F          	LD	E,A
0786   0358 CD 1B 02    	CALL RTC_WRITE
0787   035B             
0788   035B             ; hours
0789   035B 16 02       	LD	D,$02
0790   035D 3A F8 08    	LD	A,(HOURS)
0791   0360 5F          	LD	E,A
0792   0361 CD 1B 02    	CALL RTC_WRITE
0793   0364             
0794   0364             ; date
0795   0364 16 03       	LD	D,$03
0796   0366 3A F7 08    	LD	A,(DATE)
0797   0369 5F          	LD	E,A
0798   036A CD 1B 02    	CALL RTC_WRITE
0799   036D             
0800   036D             ; month
0801   036D 16 04       	LD	D,$04
0802   036F 3A F6 08    	LD	A,(MONTH)
0803   0372 5F          	LD	E,A
0804   0373 CD 1B 02    	CALL RTC_WRITE
0805   0376             
0806   0376             ; day
0807   0376 16 05       	LD	D,$05
0808   0378 3A FB 08    	LD	A,(DAY)
0809   037B 5F          	LD	E,A
0810   037C CD 1B 02    	CALL RTC_WRITE
0811   037F             
0812   037F             ; year
0813   037F 16 06       	LD	D,$06
0814   0381 3A F5 08    	LD	A,(YEAR)
0815   0384 5F          	LD	E,A
0816   0385 CD 1B 02    	CALL RTC_WRITE
0817   0388             
0818   0388 CD 4D 02    	CALL RTC_WR_PROTECT
0819   038B C9          	RET
0820   038C             
0821   038C             RTC_INIT_NOW:
0822   038C             ; set time to Current Time
0823   038C             
0824   038C             ; year
0825   038C 11 C0 08    	LD	DE,RTC_TOP_LOOP1_INIT_YEAR
0826   038F 0E 09       	LD	C,09H			; CP/M write string to console call
0827   0391 CD 05 00    	CALL	0005H
0828   0394 CD 69 01    	CALL	HEXIN
0829   0397 32 F5 08    	LD	(YEAR),A
0830   039A             
0831   039A             ; month
0832   039A 11 B0 08    	LD	DE,RTC_TOP_LOOP1_INIT_MONTH
0833   039D 0E 09       	LD	C,09H			; CP/M write string to console call
0834   039F CD 05 00    	CALL	0005H
0835   03A2 CD 69 01    	CALL	HEXIN
0836   03A5 32 F6 08    	LD	(MONTH),A
0837   03A8             
0838   03A8             ; date
0839   03A8 11 A8 08    	LD	DE,RTC_TOP_LOOP1_INIT_DATE
0840   03AB 0E 09       	LD	C,09H			; CP/M write string to console call
0841   03AD CD 05 00    	CALL	0005H
0842   03B0 CD 69 01    	CALL	HEXIN
0843   03B3 32 F7 08    	LD	(DATE),A
0844   03B6             
0845   03B6             ; hours
0846   03B6 11 9F 08    	LD	DE,RTC_TOP_LOOP1_INIT_HOURS
0847   03B9 0E 09       	LD	C,09H			; CP/M write string to console call
0848   03BB CD 05 00    	CALL	0005H
0849   03BE CD 69 01    	CALL	HEXIN
0850   03C1 32 F8 08    	LD	(HOURS),A
0851   03C4             
0852   03C4             ; minutes
0853   03C4 11 94 08    	LD	DE,RTC_TOP_LOOP1_INIT_MINUTES
0854   03C7 0E 09       	LD	C,09H			; CP/M write string to console call
0855   03C9 CD 05 00    	CALL	0005H
0856   03CC CD 69 01    	CALL	HEXIN
0857   03CF 32 F9 08    	LD	(MINUTES),A
0858   03D2             
0859   03D2             ; seconds
0860   03D2 11 89 08    	LD	DE,RTC_TOP_LOOP1_INIT_SECONDS
0861   03D5 0E 09       	LD	C,09H			; CP/M write string to console call
0862   03D7 CD 05 00    	CALL	0005H
0863   03DA CD 69 01    	CALL	HEXIN
0864   03DD 32 FA 08    	LD	(SECONDS),A
0865   03E0             
0866   03E0             ; day
0867   03E0 11 B9 08    	LD	DE,RTC_TOP_LOOP1_INIT_DAY
0868   03E3 0E 09       	LD	C,09H			; CP/M write string to console call
0869   03E5 CD 05 00    	CALL	0005H
0870   03E8 CD 69 01    	CALL	HEXIN
0871   03EB 32 FB 08    	LD	(DAY),A
0872   03EE             
0873   03EE C9          	RET
0874   03EF             
0875   03EF             
0876   03EF             ; function RTC_RESTART
0877   03EF             ;
0878   03EF             ; uses A, D, E,
0879   03EF             ;
0880   03EF             ; based on the following algorithm
0881   03EF             ;
0882   03EF             ;  { Restart clock, set seconds to 00 }
0883   03EF             ;  PROCEDURE rtc_restart;
0884   03EF             ;  BEGIN
0885   03EF             ;    rtc_wr_unprotect();
0886   03EF             ;    { Set seconds }
0887   03EF             ;    rtc_write(0,0);
0888   03EF             ;    rtc_wr_protect();
0889   03EF             ;  END;
0890   03EF             
0891   03EF             RTC_RESTART:
0892   03EF CD 55 02    	CALL RTC_WR_UNPROTECT
0893   03F2 16 00       	LD	D,$00
0894   03F4 1E 00       	LD	E,$00
0895   03F6 CD 1B 02    	CALL RTC_WRITE
0896   03F9 CD 4D 02    	CALL RTC_WR_PROTECT
0897   03FC C9          	RET
0898   03FD             
0899   03FD             
0900   03FD             ; function RTC_CHARGE_ENABLE
0901   03FD             ;
0902   03FD             ; uses A, D, E
0903   03FD             ;
0904   03FD             ; based on following algorithm
0905   03FD             ;
0906   03FD             ;  PROCEDURE rtc_charge_enable;
0907   03FD             ;  BEGIN
0908   03FD             ;    rtc_wr_unprotect();
0909   03FD             ;    { Enable trickle charger, 2kohm, 1 diode }
0910   03FD             ;    rtc_write(8,$a5);
0911   03FD             ;    rtc_wr_protect();
0912   03FD             ;  END;
0913   03FD             
0914   03FD             RTC_CHARGE_ENABLE
0915   03FD CD 55 02    	CALL	RTC_WR_UNPROTECT
0916   0400 16 08       	LD	D,$08
0917   0402 1E A5       	LD	E,$A5
0918   0404 CD 1B 02    	CALL	RTC_WRITE
0919   0407 CD 4D 02    	CALL	RTC_WR_PROTECT
0920   040A C9          	RET
0921   040B             
0922   040B             
0923   040B             ; function RTC_CHARGE_DISABLE
0924   040B             ;
0925   040B             ; uses A, D, E
0926   040B             ;
0927   040B             ; based on following algorithm
0928   040B             ;
0929   040B             ;  PROCEDURE rtc_charge_disable;
0930   040B             ;  BEGIN
0931   040B             ;    rtc_wr_unprotect();
0932   040B             ;    { Disable trickle charger}
0933   040B             ;    rtc_write(8,$00);
0934   040B             ;    rtc_wr_protect();
0935   040B             ;  END;
0936   040B             
0937   040B             RTC_CHARGE_DISABLE
0938   040B CD 55 02    	CALL	RTC_WR_UNPROTECT
0939   040E 16 08       	LD	D,$08
0940   0410 1E 00       	LD	E,$00
0941   0412 CD 1B 02    	CALL	RTC_WRITE
0942   0415 CD 4D 02    	CALL	RTC_WR_PROTECT
0943   0418 C9          	RET
0944   0419             
0945   0419             
0946   0419             ; function TEST_BIT_DELAY
0947   0419             ;
0948   0419             ; based on the following algorithm
0949   0419             ;
0950   0419             ;
0951   0419             ;  PROCEDURE test_bit_delay();
0952   0419             ;   var
0953   0419             ;     i,t0,t1 : int;
0954   0419             ;  BEGIN
0955   0419             ;    putln("Testing bit delay...");
0956   0419             ;    t0 := sys_time();
0957   0419             ;    for i := 0 while i < 1000 do inc(i) loop
0958   0419             ;      rtc_bit_delay();
0959   0419             ;    end loop;
0960   0419             ;    t1 := sys_time();
0961   0419             ;    putln(i," rtc_bit_delay calls took ",t1-t0," ms.");
0962   0419             ;  END;
0963   0419             
0964   0419             RTC_TEST_BIT_DELAY
0965   0419 11 75 06    	LD	DE,TESTING_BIT_DELAY_MSG
0966   041C 0E 09       	LD	C,09H			; CP/M write string to console call
0967   041E CD 05 00    	CALL	0005H
0968   0421 0E 01       	LD	C,01H			; CP/M console input call
0969   0423 CD 05 00    	CALL	0005H
0970   0426             
0971   0426             	; test should take approximately 43 seconds based on the following code analysis
0972   0426             	; of Z80 T-states on a 4 MHz processor
0973   0426             	; =(4+15*(7+255*(7+255*(17+144+4+10)+4+10)+10)+7)/4/1000000
0974   0426             
0975   0426 06 0F       	LD	B,$0F
0976   0428             PAUSE:
0977   0428 0E FF       	LD	C,$FF
0978   042A             PAUSE1:
0979   042A 3E FF       	LD	A,$FF			; ADJUST THE TIME 13h IS FOR 4 MHZ
0980   042C             PAUSE2:
0981   042C CD 8F 01    	CALL	RTC_BIT_DELAY		; CAUSE 36uS DELAY
0982   042F 3D          	DEC	A			; DEC COUNTER.
0983   0430 C2 2C 04    	JP	NZ,PAUSE2		; JUMP TO PAUSE2 IF A <> 0.
0984   0433 0D          	DEC	C			; DEC COUNTER
0985   0434 C2 2A 04    	JP	NZ,PAUSE1		; JUMP TO PAUSE1 IF C <> 0.
0986   0437 10 EF       	DJNZ	PAUSE			; JUMP TO PAUSE IF B <> 0.
0987   0439             
0988   0439 11 CB 06    	LD	DE,TESTING_BIT_DELAY_OVER
0989   043C 0E 09       	LD	C,09H			; CP/M write string to console call
0990   043E CD 05 00    	CALL	0005H
0991   0441 C9          	RET
0992   0442             
0993   0442             
0994   0442             ; function RTC_HELP
0995   0442             ;
0996   0442             ; based on following algorithm
0997   0442             ;
0998   0442             ;  PROCEDURE help();
0999   0442             ;  BEGIN
1000   0442             ;    putln();
1001   0442             ;    putln("rtc: ",version);
1002   0442             ;    putln("rtc: Commands: (E)xit (T)ime st(A)rt (S)et (R)aw (L)oop (C)harge (N)ocharge (H)elp");
1003   0442             ;  END;
1004   0442             
1005   0442             RTC_HELP
1006   0442 11 EB 06    	LD	DE,RTC_HELP_MSG
1007   0445 0E 09       	LD	C,09H			; CP/M write string to console call
1008   0447 CD 05 00    	CALL	0005H
1009   044A C9          	RET
1010   044B             
1011   044B             
1012   044B             ; function RTC_TOP_LOOP
1013   044B             ;
1014   044B             ; based on following algorithm
1015   044B             ;
1016   044B             ;  PROCEDURE toploop();
1017   044B             ;   var
1018   044B             ;     err,i,n,fd  : int;
1019   044B             ;  BEGIN
1020   044B             ;    putln();
1021   044B             ;    help();
1022   044B             ;    rtc_reset_on();
1023   044B             ;    hold(100);
1024   044B             ;    test_bit_delay();
1025   044B             ;    rtc_charge_disable();
1026   044B             ;    putln("rtc: trickle charger disabled.");
1027   044B             ;    loop
1028   044B             ;       put("rtc>");
1029   044B             ;       gets(line);
1030   044B             ;       if line = "exit" then
1031   044B             ;          putln("Bye.");
1032   044B             ;          exit(0);
1033   044B             ;       elsif line = "charge" then
1034   044B             ;          putln("Trickle charger enabled.");
1035   044B             ;          rtc_charge_enable();
1036   044B             ;       elsif line = "nocharge" then
1037   044B             ;          putln("Trickle charger disabled.");
1038   044B             ;          rtc_charge_disable();
1039   044B             ;       elsif line = "start" then
1040   044B             ;          rtc_restart();
1041   044B             ;          putln("Restarting RTC");
1042   044B             ;       elsif line = "t" then
1043   044B             ;          rtc_get_time(line);
1044   044B             ;          putln("Current time: ",line);
1045   044B             ;       elsif line = "raw" then
1046   044B             ;          putln();
1047   044B             ;          putln("Raw read loop, hit any key to stop...");
1048   044B             ;          while read(0,@n,1 + RD_NOWAIT) = 0 loop
1049   044B             ;             put(#13,"sec=",hexstr(rtc_read(0))^);
1050   044B             ;             put(" min=",hexstr(rtc_read(1))^);
1051   044B             ;             hold(500);
1052   044B             ;          end loop;
1053   044B             ;       elsif line = "loop" then
1054   044B             ;          putln();
1055   044B             ;          putln("Clock loop, hit any key to stop...");
1056   044B             ;          while read(0,@n,1 + RD_NOWAIT) = 0 loop
1057   044B             ;             rtc_get_time(line);
1058   044B             ;             put(#13,line);
1059   044B             ;             hold(200);
1060   044B             ;          end loop;
1061   044B             ;       elsif line = "set" then
1062   044B             ;          putln("Setting RTC time to 96-02-18 19:43:00");
1063   044B             ;          rtc_set_now();
1064   044B             ;       elsif (line = "help") or (line = "?") then
1065   044B             ;          help();
1066   044B             ;       elsif length(line) <> 0 then
1067   044B             ;          putln("You typed: """,line,"""");
1068   044B             ;       end;
1069   044B             ;    end loop;
1070   044B             ;  END toploop;
1071   044B             
1072   044B             RTC_TOP_LOOP:
1073   044B 11 72 06    	LD	DE,CRLF_MSG
1074   044E 0E 09       	LD	C,09H			; CP/M write string to console call
1075   0450 CD 05 00    	CALL	0005H
1076   0453             
1077   0453 CD 42 04    	CALL	RTC_HELP
1078   0456             
1079   0456 CD AF 01    	CALL	RTC_RESET_ON
1080   0459             
1081   0459 CD 8F 01    	CALL	RTC_BIT_DELAY
1082   045C CD 8F 01    	CALL	RTC_BIT_DELAY
1083   045F CD 8F 01    	CALL	RTC_BIT_DELAY
1084   0462             
1085   0462             ;	CALL	RTC_TEST_BIT_DELAY
1086   0462             
1087   0462 CD 0B 04    	CALL	RTC_CHARGE_DISABLE
1088   0465             	
1089   0465 11 63 07    	LD	DE,RTC_TOP_LOOP1_MSG
1090   0468 0E 09       	LD	C,09H			; CP/M write string to console call
1091   046A CD 05 00    	CALL	0005H
1092   046D             
1093   046D             RTC_TOP_LOOP_1:
1094   046D 11 86 07    	LD	DE,RTC_TOP_LOOP1_PROMPT
1095   0470 0E 09       	LD	C,09H			; CP/M write string to console call
1096   0472 CD 05 00    	CALL	0005H
1097   0475             	
1098   0475 0E 01       	LD	C,01H			; CP/M console input call
1099   0477 CD 05 00    	CALL	0005H
1100   047A             
1101   047A E6 5F       	AND	%01011111		; handle lower case responses to menu
1102   047C             
1103   047C FE 45       	CP	'E'
1104   047E CA D6 04    	JP	Z,RTC_TOP_LOOP_EXIT
1105   0481             
1106   0481 FE 43       	CP	'C'
1107   0483 CA D7 04    	JP	Z,RTC_TOP_LOOP_CHARGE
1108   0486             
1109   0486 FE 4E       	CP	'N'
1110   0488 CA E5 04    	JP	Z,RTC_TOP_LOOP_NOCHARGE
1111   048B             
1112   048B FE 41       	CP	'A'
1113   048D CA F3 04    	JP	Z,RTC_TOP_LOOP_START
1114   0490             
1115   0490 FE 54       	CP	'T'
1116   0492 CA 01 05    	JP	Z,RTC_TOP_LOOP_TIME
1117   0495             
1118   0495 FE 52       	CP	'R'
1119   0497 CA 17 05    	JP	Z,RTC_TOP_LOOP_RAW
1120   049A             
1121   049A FE 4C       	CP	'L'
1122   049C CA A2 05    	JP	Z,RTC_TOP_LOOP_LOOP
1123   049F             
1124   049F FE 48       	CP	'H'
1125   04A1 CA E4 05    	JP	Z,RTC_TOP_LOOP_HELP
1126   04A4             
1127   04A4 FE 44       	CP	'D'
1128   04A6 CA DE 05    	JP	Z,RTC_TOP_LOOP_DELAY
1129   04A9             
1130   04A9 FE 53       	CP	'S'
1131   04AB CA C2 05    	JP	Z,RTC_TOP_LOOP_SET
1132   04AE             
1133   04AE FE 49       	CP	'I'
1134   04B0 CA D0 05    	JP	Z,RTC_TOP_LOOP_INIT
1135   04B3             
1136   04B3 FE 47       	CP	'G'
1137   04B5 CA EF 05    	JP	Z,RTC_TOP_LOOP_GET
1138   04B8             
1139   04B8 FE 50       	CP	'P'
1140   04BA CA EA 05    	JP	Z,RTC_TOP_LOOP_PUT
1141   04BD             
1142   04BD 11 C8 08    	LD	DE,RTC_TOP_LOOP1_OTHER1
1143   04C0 0E 09       	LD	C,09H			; CP/M write string to console call
1144   04C2 CD 05 00    	CALL	0005H
1145   04C5             
1146   04C5 5F          	LD	E,A
1147   04C6 0E 02       	LD	C,02H			; CP/M Console output call
1148   04C8 CD 05 00    	CALL	0005H
1149   04CB             
1150   04CB 11 D6 08    	LD	DE,RTC_TOP_LOOP1_OTHER2
1151   04CE 0E 09       	LD	C,09H			; CP/M write string to console call
1152   04D0 CD 05 00    	CALL	0005H
1153   04D3             	
1154   04D3 C3 6D 04    	JP	RTC_TOP_LOOP_1
1155   04D6             
1156   04D6             RTC_TOP_LOOP_EXIT:
1157   04D6 C9          	RET
1158   04D7             
1159   04D7             RTC_TOP_LOOP_CHARGE:
1160   04D7 11 8D 07    	LD	DE,RTC_TOP_LOOP1_CHARGE
1161   04DA 0E 09       	LD	C,09H			; CP/M write string to console call
1162   04DC CD 05 00    	CALL	0005H
1163   04DF CD FD 03    	CALL	RTC_CHARGE_ENABLE
1164   04E2 C3 6D 04    	JP	RTC_TOP_LOOP_1
1165   04E5             
1166   04E5             RTC_TOP_LOOP_NOCHARGE:
1167   04E5 11 AA 07    	LD	DE,RTC_TOP_LOOP1_NOCHARGE
1168   04E8 0E 09       	LD	C,09H			; CP/M write string to console call
1169   04EA CD 05 00    	CALL	0005H
1170   04ED CD 0B 04    	CALL	RTC_CHARGE_DISABLE
1171   04F0 C3 6D 04    	JP	RTC_TOP_LOOP_1
1172   04F3             
1173   04F3             RTC_TOP_LOOP_START:
1174   04F3 11 C8 07    	LD	DE,RTC_TOP_LOOP1_START
1175   04F6 0E 09       	LD	C,09H			; CP/M write string to console call
1176   04F8 CD 05 00    	CALL	0005H
1177   04FB CD EF 03    	CALL	RTC_RESTART
1178   04FE C3 6D 04    	JP	RTC_TOP_LOOP_1
1179   0501             
1180   0501             RTC_TOP_LOOP_TIME:
1181   0501 11 D9 07    	LD	DE,RTC_TOP_LOOP1_TIME
1182   0504 0E 09       	LD	C,09H			; CP/M write string to console call
1183   0506 CD 05 00    	CALL	0005H
1184   0509 CD 5D 02    	CALL	RTC_GET_TIME
1185   050C 11 D9 08    	LD	DE,RTC_PRINT_BUFFER
1186   050F 0E 09       	LD	C,09H			; CP/M write string to console call
1187   0511 CD 05 00    	CALL	0005H
1188   0514 C3 6D 04    	JP	RTC_TOP_LOOP_1
1189   0517             
1190   0517             RTC_TOP_LOOP_RAW:
1191   0517 11 EA 07    	LD	DE,RTC_TOP_LOOP1_RAW
1192   051A 0E 09       	LD	C,09H			; CP/M write string to console call
1193   051C CD 05 00    	CALL	0005H
1194   051F             RTC_TOP_LOOP_RAW1:
1195   051F             
1196   051F             ;	{ Read seconds }
1197   051F 16 00       	LD	D,$00			; seconds register in DS1302
1198   0521 CD 36 02    	CALL	RTC_READ		; read value from DS1302, value is in Reg C
1199   0524             
1200   0524             	; digit 16
1201   0524 79          	LD	A,C			; put value output in Reg C into accumulator
1202   0525 CB 07       	RLC	A
1203   0527 CB 07       	RLC	A
1204   0529 CB 07       	RLC	A
1205   052B CB 07       	RLC	A
1206   052D E6 07       	AND	$07
1207   052F C6 30       	ADD	A,'0'
1208   0531 32 E8 08    	LD	(RTC_PRINT_BUFFER+15),A
1209   0534             
1210   0534             	; digit 17
1211   0534 79          	LD	A,C			; put value output in Reg C into accumulator
1212   0535 E6 0F       	AND	$0F
1213   0537 C6 30       	ADD	A,'0'
1214   0539 32 E9 08    	LD	(RTC_PRINT_BUFFER+16),A
1215   053C             
1216   053C             ;	{ Read minutes }
1217   053C             
1218   053C 16 01       	LD	D,$01			; minutes register in DS1302
1219   053E CD 36 02    	CALL	RTC_READ		; read value from DS1302, value is in Reg C
1220   0541             
1221   0541             	; digit 13
1222   0541 79          	LD	A,C			; put value output in Reg C into accumulator
1223   0542 CB 07       	RLC	A
1224   0544 CB 07       	RLC	A
1225   0546 CB 07       	RLC	A
1226   0548 CB 07       	RLC	A
1227   054A E6 07       	AND	$07
1228   054C C6 30       	ADD	A,'0'
1229   054E 32 E5 08    	LD	(RTC_PRINT_BUFFER+12),A
1230   0551             
1231   0551             	; digit 14
1232   0551 79          	LD	A,C			; put value output in Reg C into accumulator
1233   0552 E6 0F       	AND	$0F
1234   0554 C6 30       	ADD	A,'0'
1235   0556 32 E6 08    	LD	(RTC_PRINT_BUFFER+13),A
1236   0559             
1237   0559             	; digit 15
1238   0559 3E 3A       	LD	A,':'
1239   055B 32 E7 08    	LD	(RTC_PRINT_BUFFER+14),A
1240   055E             
1241   055E             	; digits 1-12 and 18-20 are spaces
1242   055E 3E 20       	LD	A,' '			; space
1243   0560 32 EC 08    	LD	(RTC_PRINT_BUFFER+19),A
1244   0563 32 EB 08    	LD	(RTC_PRINT_BUFFER+18),A
1245   0566 32 EA 08    	LD	(RTC_PRINT_BUFFER+17),A
1246   0569 32 E4 08    	LD	(RTC_PRINT_BUFFER+11),A
1247   056C 32 E3 08    	LD	(RTC_PRINT_BUFFER+10),A
1248   056F 32 E2 08    	LD	(RTC_PRINT_BUFFER+09),A
1249   0572 32 E1 08    	LD	(RTC_PRINT_BUFFER+08),A
1250   0575 32 E0 08    	LD	(RTC_PRINT_BUFFER+07),A
1251   0578 32 DF 08    	LD	(RTC_PRINT_BUFFER+06),A
1252   057B 32 DE 08    	LD	(RTC_PRINT_BUFFER+05),A
1253   057E 32 DD 08    	LD	(RTC_PRINT_BUFFER+04),A
1254   0581 32 DC 08    	LD	(RTC_PRINT_BUFFER+03),A
1255   0584 32 DB 08    	LD	(RTC_PRINT_BUFFER+02),A
1256   0587 32 DA 08    	LD	(RTC_PRINT_BUFFER+01),A
1257   058A 32 D9 08    	LD	(RTC_PRINT_BUFFER+00),A
1258   058D             
1259   058D 11 D9 08    	LD	DE,RTC_PRINT_BUFFER
1260   0590 0E 09       	LD	C,09H			; CP/M write string to console call
1261   0592 CD 05 00    	CALL	0005H
1262   0595             
1263   0595 0E 01       	LD	C,01H			; CP/M console input call
1264   0597 CD 05 00    	CALL	0005H
1265   059A             
1266   059A FE 20       	CP	' '			; space
1267   059C CA 1F 05    	JP	Z,RTC_TOP_LOOP_RAW1
1268   059F             
1269   059F C3 6D 04    	JP	RTC_TOP_LOOP_1
1270   05A2             
1271   05A2             RTC_TOP_LOOP_LOOP:
1272   05A2 11 18 08    	LD	DE,RTC_TOP_LOOP1_LOOP
1273   05A5 0E 09       	LD	C,09H			; CP/M write string to console call
1274   05A7 CD 05 00    	CALL	0005H
1275   05AA             
1276   05AA             RTC_TOP_LOOP_LOOP1:
1277   05AA CD 5D 02    	CALL	RTC_GET_TIME
1278   05AD             
1279   05AD 11 D9 08    	LD	DE,RTC_PRINT_BUFFER
1280   05B0 0E 09       	LD	C,09H			; CP/M write string to console call
1281   05B2 CD 05 00    	CALL	0005H
1282   05B5             
1283   05B5 0E 01       	LD	C,01H			; CP/M console input call
1284   05B7 CD 05 00    	CALL	0005H
1285   05BA             
1286   05BA FE 20       	CP	' '
1287   05BC CA AA 05    	JP	Z,RTC_TOP_LOOP_LOOP1	
1288   05BF             
1289   05BF C3 6D 04    	JP	RTC_TOP_LOOP_1
1290   05C2             
1291   05C2             RTC_TOP_LOOP_SET:
1292   05C2 11 43 08    	LD	DE,RTC_TOP_LOOP1_SET
1293   05C5 0E 09       	LD	C,09H			; CP/M write string to console call
1294   05C7 CD 05 00    	CALL	0005H
1295   05CA CD 46 03    	CALL	RTC_SET_NOW
1296   05CD C3 6D 04    	JP	RTC_TOP_LOOP_1
1297   05D0             
1298   05D0             RTC_TOP_LOOP_INIT:
1299   05D0 11 55 08    	LD	DE,RTC_TOP_LOOP1_INIT
1300   05D3 0E 09       	LD	C,09H			; CP/M write string to console call
1301   05D5 CD 05 00    	CALL	0005H
1302   05D8 CD 8C 03    	CALL	RTC_INIT_NOW
1303   05DB C3 6D 04    	JP	RTC_TOP_LOOP_1
1304   05DE             
1305   05DE             RTC_TOP_LOOP_DELAY:
1306   05DE CD 19 04    	CALL	RTC_TEST_BIT_DELAY
1307   05E1 C3 6D 04    	JP	RTC_TOP_LOOP_1
1308   05E4             
1309   05E4             RTC_TOP_LOOP_HELP:
1310   05E4 CD 42 04    	CALL	RTC_HELP
1311   05E7 C3 6D 04    	JP	RTC_TOP_LOOP_1
1312   05EA             
1313   05EA             RTC_TOP_LOOP_PUT:
1314   05EA 3E 01       	LD	A,$01			; set PUT as true
1315   05EC 32 FC 08    	LD	(GET_PUT),A
1316   05EF             RTC_TOP_LOOP_GET:
1317   05EF 11 69 08    	LD	DE,RTC_TOP_LOOP1_GET
1318   05F2 0E 09       	LD	C,09H			; CP/M write string to console call
1319   05F4 CD 05 00    	CALL	0005H
1320   05F7             
1321   05F7 CD 69 01    	CALL	HEXIN			; read NVRAM address
1322   05FA 32 FD 08    	LD	(PUT_ADR),A		; store for possible PUT later
1323   05FD             
1324   05FD             ;	{ Read NVRAM address }
1325   05FD 57          	LD	D,A			; seconds register in DS1302
1326   05FE CD 36 02    	CALL	RTC_READ		; read value from DS1302, value is in Reg C
1327   0601             
1328   0601             	; first digit
1329   0601 79          	LD	A,C			; put value output in Reg C into accumulator
1330   0602 CB 07       	RLC	A
1331   0604 CB 07       	RLC	A
1332   0606 CB 07       	RLC	A
1333   0608 CB 07       	RLC	A
1334   060A E6 0F       	AND	$0F
1335   060C FE 0A       	CP	0AH			;TEST FOR NUMERIC & convert to ASCII
1336   060E 38 02       	JR	C,NUM1			;if not ALPHA, its numeric and skip
1337   0610 C6 07       	ADD	A,$07
1338   0612             
1339   0612 C6 30       NUM1:	ADD	A,'0'
1340   0614 32 F0 08    	LD	(RTC_GET_BUFFER),A
1341   0617             
1342   0617             	; second digit
1343   0617 79          	LD	A,C			; put value output in Reg C into accumulator
1344   0618 E6 0F       	AND	$0F
1345   061A FE 0A       	CP	0AH			;TEST FOR NUMERIC & convert to ASCII
1346   061C 38 02       	JR	C,NUM2			;if not ALPHA, its numeric and skip
1347   061E C6 07       	ADD	A,$07	
1348   0620             
1349   0620 C6 30       NUM2:	ADD	A,'0'
1350   0622 32 F1 08    	LD	(RTC_GET_BUFFER+1),A
1351   0625             
1352   0625 11 D6 08    	LD	DE,RTC_TOP_LOOP1_OTHER2
1353   0628 0E 09       	LD	C,09H			; CP/M write string to console call
1354   062A CD 05 00    	CALL	0005H
1355   062D             
1356   062D 11 F0 08    	LD	DE,RTC_GET_BUFFER
1357   0630 0E 09       	LD	C,09H			; CP/M write string to console call
1358   0632 CD 05 00    	CALL	0005H
1359   0635             
1360   0635 3A FC 08    	LD	A,(GET_PUT)		; check if GET or PUT mode
1361   0638 FE 00       	CP	$00
1362   063A CA 56 06    	JP	Z,RTC_GET_PUT_EXIT	; if GET mode, exit
1363   063D             
1364   063D 11 7B 08    	LD	DE,RTC_TOP_LOOP1_PUT
1365   0640 0E 09       	LD	C,09H			; CP/M write string to console call
1366   0642 CD 05 00    	CALL	0005H
1367   0645             
1368   0645             ;	{ Write NVRAM address }
1369   0645             
1370   0645 CD 55 02    	CALL	RTC_WR_UNPROTECT
1371   0648             
1372   0648 CD 69 01    	CALL	HEXIN			; read NVRAM address
1373   064B 5F          	LD	E,A			; new data for NVRAM register in DS1302
1374   064C 3A FD 08    	LD	A,(PUT_ADR)
1375   064F 57          	LD	D,A			; load address from before
1376   0650             
1377   0650 CD 1B 02    	CALL	RTC_WRITE		; read value from DS1302, value is in Reg C
1378   0653             
1379   0653 CD 4D 02    	CALL	RTC_WR_PROTECT
1380   0656             
1381   0656             RTC_GET_PUT_EXIT:
1382   0656 3E 00       	LD	A,$00			; reset GET mode
1383   0658 32 FC 08    	LD	(GET_PUT),A
1384   065B C3 6D 04    	JP	RTC_TOP_LOOP_1
1385   065E             
1386   065E             
1387   065E             
1388   065E             
1389   065E             ;
1390   065E             ; Text Strings
1391   065E             ;
1392   065E             
1393   065E             MSG:
1394   065E 53 74 61 72 	.TEXT	"Start RTC Program"
1394   0662 74 20 52 54 
1394   0666 43 20 50 72 
1394   066A 6F 67 72 61 
1394   066E 6D 
1395   066F 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1396   0671 24          	.DB	"$"			; Line terminator
1397   0672             
1398   0672             CRLF_MSG:
1399   0672 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1400   0674 24          	.DB	"$"			; Line terminator
1401   0675             
1402   0675             TESTING_BIT_DELAY_MSG:
1403   0675 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1404   0677 54 65 73 74 	.TEXT	"Testing bit delay.  Successful test is ~43 sec."
1404   067B 69 6E 67 20 
1404   067F 62 69 74 20 
1404   0683 64 65 6C 61 
1404   0687 79 2E 20 20 
1404   068B 53 75 63 63 
1404   068F 65 73 73 66 
1404   0693 75 6C 20 74 
1404   0697 65 73 74 20 
1404   069B 69 73 20 7E 
1404   069F 34 33 20 73 
1404   06A3 65 63 2E 
1405   06A6 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1406   06A8 53 74 61 72 	.TEXT	"Start clock and press space bar."
1406   06AC 74 20 63 6C 
1406   06B0 6F 63 6B 20 
1406   06B4 61 6E 64 20 
1406   06B8 70 72 65 73 
1406   06BC 73 20 73 70 
1406   06C0 61 63 65 20 
1406   06C4 62 61 72 2E 
1407   06C8 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1408   06CA 24          	.DB	"$"			; Line terminator
1409   06CB             
1410   06CB             TESTING_BIT_DELAY_OVER:
1411   06CB 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1412   06CD 54 65 73 74 	.TEXT	"Test complete.  Stop clock."
1412   06D1 20 63 6F 6D 
1412   06D5 70 6C 65 74 
1412   06D9 65 2E 20 20 
1412   06DD 53 74 6F 70 
1412   06E1 20 63 6C 6F 
1412   06E5 63 6B 2E 
1413   06E8 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1414   06EA 24          	.DB	"$"			; Line terminator
1415   06EB             
1416   06EB             RTC_HELP_MSG:
1417   06EB 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1418   06ED 52 54 43 3A 	.TEXT	"RTC: Version 1.0"
1418   06F1 20 56 65 72 
1418   06F5 73 69 6F 6E 
1418   06F9 20 31 2E 30 
1419   06FD 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1420   06FF 52 54 43 3A 	.TEXT	"RTC: Commands: E)xit T)ime st(A)rt S)et R)aw L)oop C)harge N)ocharge D)elay I)nit G)et P)ut H)elp"
1420   0703 20 43 6F 6D 
1420   0707 6D 61 6E 64 
1420   070B 73 3A 20 45 
1420   070F 29 78 69 74 
1420   0713 20 54 29 69 
1420   0717 6D 65 20 73 
1420   071B 74 28 41 29 
1420   071F 72 74 20 53 
1420   0723 29 65 74 20 
1420   0727 52 29 61 77 
1420   072B 20 4C 29 6F 
1420   072F 6F 70 20 43 
1420   0733 29 68 61 72 
1420   0737 67 65 20 4E 
1420   073B 29 6F 63 68 
1420   073F 61 72 67 65 
1420   0743 20 44 29 65 
1420   0747 6C 61 79 20 
1420   074B 49 29 6E 69 
1420   074F 74 20 47 29 
1420   0753 65 74 20 50 
1420   0757 29 75 74 20 
1420   075B 48 29 65 6C 
1420   075F 70 
1421   0760 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1422   0762 24          	.DB	"$"			; Line terminator
1423   0763             
1424   0763             RTC_TOP_LOOP1_MSG:
1425   0763 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1426   0765 52 54 43 3A 	.TEXT	"RTC: trickle charger disabled."
1426   0769 20 74 72 69 
1426   076D 63 6B 6C 65 
1426   0771 20 63 68 61 
1426   0775 72 67 65 72 
1426   0779 20 64 69 73 
1426   077D 61 62 6C 65 
1426   0781 64 2E 
1427   0783 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1428   0785 24          	.DB	"$"			; Line terminator
1429   0786             
1430   0786             RTC_TOP_LOOP1_PROMPT:
1431   0786 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1432   0788 52 54 43 3E 	.TEXT	"RTC>"
1433   078C 24          	.DB	"$"			; Line terminator
1434   078D             
1435   078D             RTC_TOP_LOOP1_CHARGE:
1436   078D 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1437   078F 54 72 69 63 	.TEXT	"Trickle charger enabled."
1437   0793 6B 6C 65 20 
1437   0797 63 68 61 72 
1437   079B 67 65 72 20 
1437   079F 65 6E 61 62 
1437   07A3 6C 65 64 2E 
1438   07A7 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1439   07A9 24          	.DB	"$"			; Line terminator
1440   07AA             
1441   07AA             RTC_TOP_LOOP1_NOCHARGE:
1442   07AA 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1443   07AC 54 72 69 63 	.TEXT	"Trickle charger disabled."
1443   07B0 6B 6C 65 20 
1443   07B4 63 68 61 72 
1443   07B8 67 65 72 20 
1443   07BC 64 69 73 61 
1443   07C0 62 6C 65 64 
1443   07C4 2E 
1444   07C5 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1445   07C7 24          	.DB	"$"			; Line terminator
1446   07C8             
1447   07C8             RTC_TOP_LOOP1_START:
1448   07C8 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1449   07CA 52 65 73 74 	.TEXT	"Restart RTC."
1449   07CE 61 72 74 20 
1449   07D2 52 54 43 2E 
1450   07D6 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1451   07D8 24          	.DB	"$"			; Line terminator
1452   07D9             
1453   07D9             RTC_TOP_LOOP1_TIME:
1454   07D9 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1455   07DB 43 75 72 72 	.TEXT	"Current time: "
1455   07DF 65 6E 74 20 
1455   07E3 74 69 6D 65 
1455   07E7 3A 20 
1456   07E9 24          	.DB	"$"			; Line terminator
1457   07EA             
1458   07EA             RTC_TOP_LOOP1_RAW:
1459   07EA 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1460   07EC 52 61 77 20 	.TEXT	"Raw read Loop.  Press SPACE BAR for next."
1460   07F0 72 65 61 64 
1460   07F4 20 4C 6F 6F 
1460   07F8 70 2E 20 20 
1460   07FC 50 72 65 73 
1460   0800 73 20 53 50 
1460   0804 41 43 45 20 
1460   0808 42 41 52 20 
1460   080C 66 6F 72 20 
1460   0810 6E 65 78 74 
1460   0814 2E 
1461   0815 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1462   0817 24          	.DB	"$"			; Line terminator
1463   0818             
1464   0818             RTC_TOP_LOOP1_LOOP:
1465   0818 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1466   081A 43 6C 6F 63 	.TEXT	"Clock Loop.  Press SPACE BAR for next."
1466   081E 6B 20 4C 6F 
1466   0822 6F 70 2E 20 
1466   0826 20 50 72 65 
1466   082A 73 73 20 53 
1466   082E 50 41 43 45 
1466   0832 20 42 41 52 
1466   0836 20 66 6F 72 
1466   083A 20 6E 65 78 
1466   083E 74 2E 
1467   0840 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1468   0842 24          	.DB	"$"			; Line terminator
1469   0843             
1470   0843             RTC_TOP_LOOP1_SET:
1471   0843 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1472   0845 53 65 74 20 	.TEXT	"Set RTC time."
1472   0849 52 54 43 20 
1472   084D 74 69 6D 65 
1472   0851 2E 
1473   0852 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1474   0854 24          	.DB	"$"			; Line terminator
1475   0855             
1476   0855             RTC_TOP_LOOP1_INIT:
1477   0855 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1478   0857 49 6E 69 74 	.TEXT	"Init date/time."
1478   085B 20 64 61 74 
1478   085F 65 2F 74 69 
1478   0863 6D 65 2E 
1479   0866 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1480   0868 24          	.DB	"$"			; Line terminator
1481   0869             
1482   0869             RTC_TOP_LOOP1_GET:
1483   0869 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1484   086B 47 65 74 20 	.TEXT	"Get NVRAM addr:"
1484   086F 4E 56 52 41 
1484   0873 4D 20 61 64 
1484   0877 64 72 3A 
1485   087A 24          	.DB	"$"			; Line terminator
1486   087B             
1487   087B             RTC_TOP_LOOP1_PUT:
1488   087B 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1489   087D 4E 56 52 41 	.TEXT	"NVRAM data:"
1489   0881 4D 20 64 61 
1489   0885 74 61 3A 
1490   0888 24          	.DB	"$"			; Line terminator
1491   0889             
1492   0889             RTC_TOP_LOOP1_INIT_SECONDS:
1493   0889 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1494   088B 53 45 43 4F 	.TEXT	"SECONDS:"
1494   088F 4E 44 53 3A 
1495   0893 24          	.DB	"$"			; Line terminator
1496   0894             
1497   0894             RTC_TOP_LOOP1_INIT_MINUTES:
1498   0894 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1499   0896 4D 49 4E 55 	.TEXT	"MINUTES:"
1499   089A 54 45 53 3A 
1500   089E 24          	.DB	"$"			; Line terminator
1501   089F             
1502   089F             RTC_TOP_LOOP1_INIT_HOURS:
1503   089F 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1504   08A1 48 4F 55 52 	.TEXT	"HOURS:"
1504   08A5 53 3A 
1505   08A7 24          	.DB	"$"			; Line terminator
1506   08A8             
1507   08A8             RTC_TOP_LOOP1_INIT_DATE:
1508   08A8 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1509   08AA 44 41 54 45 	.TEXT	"DATE:"
1509   08AE 3A 
1510   08AF 24          	.DB	"$"			; Line terminator
1511   08B0             
1512   08B0             RTC_TOP_LOOP1_INIT_MONTH:
1513   08B0 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1514   08B2 4D 4F 4E 54 	.TEXT	"MONTH:"
1514   08B6 48 3A 
1515   08B8 24          	.DB	"$"			; Line terminator
1516   08B9             
1517   08B9             RTC_TOP_LOOP1_INIT_DAY:
1518   08B9 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1519   08BB 44 41 59 3A 	.TEXT	"DAY:"
1520   08BF 24          	.DB	"$"			; Line terminator
1521   08C0             
1522   08C0             RTC_TOP_LOOP1_INIT_YEAR:
1523   08C0 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1524   08C2 59 45 41 52 	.TEXT	"YEAR:"
1524   08C6 3A 
1525   08C7 24          	.DB	"$"			; Line terminator
1526   08C8             
1527   08C8             RTC_TOP_LOOP1_OTHER1:
1528   08C8 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1529   08CA 59 4F 55 20 	.TEXT	"YOU TYPED: "
1529   08CE 54 59 50 45 
1529   08D2 44 3A 20 
1530   08D5 24          	.DB	"$"			; Line terminator
1531   08D6             
1532   08D6             RTC_TOP_LOOP1_OTHER2:
1533   08D6 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1534   08D8 24          	.DB	"$"			; Line terminator
1535   08D9             
1536   08D9             RTC_PRINT_BUFFER:
1537   08D9             	.DS	20			; Buffer for formatted date & time to print
1538   08ED 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1539   08EF 24          	.DB	"$"			; line terminator
1540   08F0             
1541   08F0             RTC_GET_BUFFER:
1542   08F0             	.DS	2			; Buffer for formatted NVRAM data to print
1543   08F2 0A 0D       	.DB	0Ah, 0Dh		; line feed and carriage return
1544   08F4 24          	.DB	"$"			; line terminator
1545   08F5             
1546   08F5             ;
1547   08F5             ; Generic FOR-NEXT loop algorithm
1548   08F5             ;
1549   08F5             ;	LD	A,$00			; set A=0 index counter of FOR loop
1550   08F5             ;FOR_LOOP:
1551   08F5             ;	PUSH	AF			; save accumulator as it is the index counter in FOR loop
1552   08F5             ;	{ contents of FOR loop here }	; setup RTC with RST and RD high, SCLK low
1553   08F5             ;	POP	AF			; recover accumulator as it is the index counter in FOR loop
1554   08F5             ;	INC	A			; increment A in FOR loop (A=A+1)
1555   08F5             ;	CP	$08			; is A < $08 ?
1556   08F5             ;	JP	NZ,FOR_LOOP		; No, do FOR loop again
1557   08F5             ;	RET				; Yes, end function and return.  Read RTC value is in C
1558   08F5             
1559   08F5             YEAR	.DS	1
1560   08F6             MONTH	.DS	1
1561   08F7             DATE	.DS	1
1562   08F8             HOURS	.DS	1
1563   08F9             MINUTES	.DS	1
1564   08FA             SECONDS	.DS	1
1565   08FB             DAY	.DS	1
1566   08FC             GET_PUT	.DS	1
1567   08FD             PUT_ADR	.DS	1
1568   08FE             
1569   08FE             
1570   08FF             	.ORG	$08ff
1571   08FF 00          	.db	$00
1572   0900             
1573   0900             
1574   0900             .end
1575   0900             
tasm: Number of errors = 0
