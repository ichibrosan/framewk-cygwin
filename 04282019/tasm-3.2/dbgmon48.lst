0001   0000             ;****************************************************************
0002   0000             ;*	Z80 Test Prototype                                      *
0003   0000             ;*	THIRD BOOT Program (RAM LOADABLE MONITOR EXPERIMENT)    *
0004   0000             ;*	Andrew Lynch                                            *
0005   0000             ;*	lynchaj@yahoo.com                                       *
0006   0000             ;*	13 Feb 2007 with mods J Moxham 4th October 2008         *
0007   0000             ;****************************************************************
0008   0000             
0009   0000             ;********************* PROGRAM OBJECTIVES *********************************
0010   0000             
0011   0000             ; OBJECTIVE OF FIRST BOOT PROGRAM is to verify CPU, ROM, RAM, memory decode, and
0012   0000             ; IO decode logic function
0013   0000             
0014   0000             ; Simple output are LEDs attached to chipselect logic at IO port and memory
0015   0000             ; chipselect lines.  Chip Select lines are active when grounded and result
0016   0000             ; in LEDs slightly dimming
0017   0000             
0018   0000             ; Simple input is the RESET key and the INTERRUPT key.  The RESET key starts
0019   0000             ; and restarts the program dimming the LEDs in a cycle.  Pressing the INTERRUPT
0020   0000             ; key halts the CPU and stops the program.  Pressing RESET again restarts.
0021   0000             
0022   0000             ; OBJECTIVE OF SECOND BOOT PROGRAM is to expand on FIRST BOOT program and 
0023   0000             ; verify correct operation of PIO and UART circuits
0024   0000             
0025   0000             ; OBJECTIVE OF THIRD BOOT PROGRAM is to add basic ROM monitor functions
0026   0000             
0027   0000             
0028   0000             ;********************* REFERENCES *****************************************
0029   0000             
0030   0000             ; Thomas Scherrer basic hardware test assembler sources from the Z80 info page
0031   0000             ; including original schematic concept
0032   0000             
0033   0000             ; http://z80.info/z80sourc.txt
0034   0000             
0035   0000             ; Code samples from Bruce Jones public domain ROM monitor for the SBC-200C 
0036   0000             
0037   0000             ; http://www.retrotechnology.com/herbs_stuff/sd_bruce_code.zip
0038   0000             
0039   0000             ; Inspiration from Joel Owens "Z-80 Space-Time Productions Single Board Computer"
0040   0000             
0041   0000             ; http://www.joelowens.org/z80/z80index.html
0042   0000             
0043   0000             ; Great help and technical advice from Allison at ALPACA_DESIGNERS
0044   0000             
0045   0000             ; http://groups.yahoo.com/group/alpaca_designers
0046   0000             
0047   0000             ; INTEL SDK-85 ROM Debug Monitor
0048   0000             
0049   0000             ;********************* HARDWARE IO ADR ************************************
0050   0000             
0051   0000             ; IO ADDRESS DECODE PORT BASES
0052   0000             ; TEST PROTOTYPE ACCEPTS FOUR SETS OF IO ADDRESSES STARTING AT THE FOLLOWING
0053   0000             ; BASE ADDRESSES.  THESE CORRESPOND TO THE CHIP SELECT LINES OUTPUT FROM THE
0054   0000             ; 74LS139 DEMULTIPLEXER
0055   0000             
0056   0000             IO_Y0:		.EQU	$60
0057   0000             IO_Y1:		.EQU	$68
0058   0000             IO_Y2:		.EQU	$70
0059   0000             IO_Y3:		.EQU	$78
0060   0000             
0061   0000             ; PIO 82C55 I/O IS ATTACHED TO THE FIRST IO BASE ADDRESS
0062   0000             
0063   0000             PIO1A:		.EQU	$IO_Y0+0	; (INPUT)  IN 1-8
0064   0000             PIO1B:		.EQU	$IO_Y0+1	; (OUTPUT) OUT TO LEDS
0065   0000             PIO1C:		.EQU	$IO_Y0+2	; (INPUT)  
0066   0000             PIO1CONT:	.EQU	$IO_Y0+3	; CONTROL BYTE PIO 82C55
0067   0000             
0068   0000             ; UART 16C450 SERIAL IS ATTACHED TO THE SECOND IO BASE ADDRESS
0069   0000             
0070   0000             UART0:		.EQU	$IO_Y1+0	; DATA IN/OUT
0071   0000             UART1:		.EQU	$IO_Y1+1	; CHECK RX
0072   0000             UART2:		.EQU	$IO_Y1+2	; INTERRUPTS
0073   0000             UART3:		.EQU	$IO_Y1+3	; LINE CONTROL
0074   0000             UART4:		.EQU	$IO_Y1+4	; MODEM CONTROL
0075   0000             UART5:		.EQU	$IO_Y1+5	; LINE STATUS
0076   0000             UART6:		.EQU	$IO_Y1+6	; MODEM STATUS
0077   0000             UART7:		.EQU	$IO_Y1+7	; SCRATCH REG.
0078   0000             
0079   0000             ; MEMORY PAGE CONFIGURATION LATCH IS ATTACHED TO FOURTH IO BASE ADDRESS
0080   0000             
0081   0000             MPCL_RAM:	.EQU	$IO_Y3		; RAM CONTROL PORT, SHOULD ONLY BE CHANGED WHILE
0082   0000             					; IN UPPER MEMORY PAGE $8000-$FFFF OR LIKELY
0083   0000             					; LOSS OF CPU MEMORY CONTEXT.
0084   0000             
0085   0000             MPCL_ROM:	.EQU	$IO_Y3+$04	; ROM CONTROL PORT, SHOULD ONLY BE CHANGED WHILE
0086   0000             					; IN UPPER MEMORY PAGE $8000-$FFFF OR LIKELY
0087   0000             					; LOSS OF CPU MEMORY CONTEXT.
0088   0000             
0089   0000             ; RAM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT ( IO_Y3 ) INFORMATION
0090   0000             
0091   0000             ;	7 6 5 4  3 2 1 0      ONLY APPLICABLE TO THE LOWER MEMORY PAGE $0000-$7FFF
0092   0000             ;	^ ^ ^ ^  ^ ^ ^ ^
0093   0000             ;	: : : :  : : : :--0 = A15 RAM ADDRESS LINE DEFAULT IS 0
0094   0000             ;	: : : :  : : :----0 = A16 RAM ADDRESS LINE DEFAULT IS 0
0095   0000             ;	: : : :  : :------0 = A17 RAM ADDRESS LINE DEFAULT IS 0
0096   0000             ;	: : : :  :--------0 = A18 RAM ADDRESS LINE DEFAULT IS 0
0097   0000             ;	: : : :-----------0 = 
0098   0000             ;	: : :-------------0 = 
0099   0000             ;	: :---------------0 = 
0100   0000             ;	:-----------------0 = 
0101   0000             
0102   0000             ; ROM MEMORY PAGE CONFIGURATION LATCH CONTROL PORT ( IO_Y3+$04 ) INFORMATION
0103   0000             
0104   0000             ;	7 6 5 4  3 2 1 0      ONLY APPLICABLE TO THE LOWER MEMORY PAGE $0000-$7FFF
0105   0000             ;	^ ^ ^ ^  ^ ^ ^ ^
0106   0000             ;	: : : :  : : : :--0 = A15 ROM ADDRESS LINE DEFAULT IS 0
0107   0000             ;	: : : :  : : :----0 = A16 ROM ADDRESS LINE DEFAULT IS 0
0108   0000             ;	: : : :  : :------0 = A17 ROM ADDRESS LINE DEFAULT IS 0
0109   0000             ;	: : : :  :--------0 = A18 ROM ADDRESS LINE DEFAULT IS 0
0110   0000             ;	: : : :-----------0 = A19 ROM ONLY ADDRESS LINE DEFAULT IS 0
0111   0000             ;	: : :-------------0 = 
0112   0000             ;	: :---------------0 = 
0113   0000             ;	:-----------------0 = ROM SELECT (0=ROM, 1=RAM) DEFAULT IS 0
0114   0000             
0115   0000             
0116   0000             ; NOTE THESE ARE ARTIFACTS FROM THE BRUCE JONES ROM MONITOR PROGRAM
0117   0000             ; THE FLOPPY DISK CONTROLLER HARDWARE DOES NOT EXIST IN TEST PROTOTYPE
0118   0000             ; AT THIS TIME BUT MAY BE INCLUDED AT SOME FUTURE DATE
0119   0000             
0120   0000             ; PI/O DISK CONTROLLER DATA
0121   0000             
0122   0000             ;	DCMD	==	63H	;FDC CONTROL PORT
0123   0000             ;	WDC	==	64H	;FDC BASE ADDRESS
0124   0000             ;	WCMD	==	WDC+0	;FDC COMMAND REG
0125   0000             ;	WSTAT	==	WDC+0	;FDC STATUS REG
0126   0000             ;	WTRACK	==	WDC+1
0127   0000             ;	WSECT	==	WDC+2	;FDC SECTOR REG
0128   0000             ;	WDATA	==	WDC+3	;FDC DATA REG
0129   0000             
0130   0000             ;179X COMMAND VALUES
0131   0000             
0132   0000             ;	RES	==	0BH	;RESTORE
0133   0000             ;	SEEK	==	1BH	;SEEK NO VERIFY
0134   0000             ;	READ	==	8CH	;READ NO SIDE COMPARE
0135   0000             ;	WRITE	==	0ACH	;WRITE NO SIDE COMPARE
0136   0000             ;	INT	==	0D0H	;FORCE INTERRUPT
0137   0000             
0138   0000             ;	DENS	==	01111110B ;INITIAL BOOT BYTE
0139   0000             ;	HOME	==	0	;HOME TRACK VALUE
0140   0000             ;	TRAK	==	0	;DESTINATION TRACK
0141   0000             ;	BOOT	==	0	;LOCATION TO JUMP AFTER BOOTSTRAP
0142   0000             ;	BCOUNT	==	512	;NUMBER OF BYTES TO READ IN
0143   0000             
0144   0000             ;PIO DISK CONTROLLER CONTROL PORT ( 63H ) INFORMATION
0145   0000             
0146   0000             ;	7 6 5 4  3 2 1 0
0147   0000             ;	^ ^ ^ ^  ^ ^ ^ ^
0148   0000             ;	: : : :  : : : :--0 = DISK 0 SELECTED
0149   0000             ;	: : : :  : : :----0 = DISK 1 SELECTED
0150   0000             ;	: : : :  : :------0 = DISK 2 SELECTED
0151   0000             ;	: : : :  :--------0 = DISK 3 SELECTED
0152   0000             ;	: : : :-----------1 = LOWER HEAD
0153   0000             ;	: : :-------------0 = 
0154   0000             ;	: :---------------0 = 
0155   0000             ;	:-----------------0 = WAIT STATE
0156   0000             
0157   0000             
0158   0000             ;********************* CONSTANTS ****************************************
0159   0000             
0160   0000             RAMTOP:		.EQU	$FFFF	; HIGHEST ADDRESSABLE MEMORY LOCATION
0161   0000             RAMBOTTOM:	.EQU	$8000	; START OF FIXED UPPER 32K PAGE OF 512KB x 8 RAM 8000H-FFFFH
0162   0000             MONSTARTCOLD:	.EQU	$F800	; COLD START MONITOR IN HIGH RAM
0163   0000             END:		.EQU	$FF	; Mark END OF TEXT
0164   0000             CR:		.EQU	0DH	; ASCII carriage return character
0165   0000             LF:		.EQU	0AH	; ASCII line feed character
0166   0000             ESC:		.EQU	1BH	; ASCII escape character
0167   0000             
0168   0000             
0169   0000             ;*******************************************************************
0170   0000             ;*	MAIN PROGRAM
0171   0000             ;*******************************************************************
0172   0000             
0173   F800             	.ORG	MONSTARTCOLD
0174   F800 CD B3 FB    	CALL	INITIALIZE
0175   F803             MONSTARTWARM:			; CALL HERE FOR MONITOR WARM START
0176   F803             
0177   F803 AF          	XOR	A		;ZERO OUT ACCUMULATOR (added)
0178   F804 E5          	PUSH	HL		;protect HL from overwrite     
0179   F805 21 53 FC    	LD	HL,TXT_READY	;POINT AT TEXT
0180   F808 CD 65 F9    	CALL	MSG		;SHOW WE'RE HERE
0181   F80B E1          	POP	HL		;protect HL from overwrite
0182   F80C             
0183   F80C             
0184   F80C             ;**************** MONITOR COMMANDS *****************
0185   F80C             
0186   F80C             ;not done ; A BOOT FV II DRIVE 0
0187   F80C             ;not done ; B BOOT FV II DRIVE 1
0188   F80C             ;not done ; 1 BOOT FV II DRIVE 0 FROM ROM
0189   F80C             ;not done ; 2 BOOT FV II DRIVE 1 FROM ROM
0190   F80C             ;done ; A Print out all commands
0191   F80C             ;done ; C BOOT CP/M FROM ROM DRIVE
0192   F80C             ;done ; D XXXXH YYYYH  DUMP MEMORY FROM XXXX TO YYYY
0193   F80C             ;done ; E XXXXH EXAMINE MEMORY LOC XXXX
0194   F80C             ;done ; F XXXXH YYYYH ZZH FILL MEMORY FROM XXXX TO YYYY WITH ZZ
0195   F80C             ;done ; H LOAD INTEL HEX FORMAT DATA
0196   F80C             ;done ; I INPUT FROM PORT AND SHOW HEX DATA
0197   F80C             ;done ; K ECHO KEYBOARD INPUT
0198   F80C             ;done ; M XXXXH YYYYH ZZZZH MOVE MEMORY BLOCK XXXX TO YYYY TO ZZZZ
0199   F80C             ;done ; O OUTPUT TO PORT HEX DATA
0200   F80C             ;done ; P PROGRAM RAM STARTING FROM CURRENT LOCATION
0201   F80C             ;done ; R RUN A PROGRAM FROM CURRENT LOCATION
0202   F80C             ;done ; 'ESCAPE' STOP CURRENT MODE AND WAIT FOR NEW COMMAND
0203   F80C             
0204   F80C             
0205   F80C             ;*******************************************************
0206   F80C             ;*	COMMAND CHECK ROUTINE
0207   F80C             ;*	READ THE KEYBOARD & EXECUTE VALID COMMANDS
0208   F80C             ;*******************************************************
0209   F80C             
0210   F80C             CHEK:
0211   F80C             
0212   F80C             ; edited Oct 15 2008 J Moxham - jump straight to CPM
0213   F80C             
0214   F80C 31 FF FF    	LD	SP,RAMTOP	;RESET ON ESCAPE
0215   F80F             
0216   F80F C3 A3 FA    	JP GOCPM		; ***** jump straight to CPM - delete this if want to use monitor
0217   F812             
0218   F812 CD 5C F9    	CALL	CRLFA		;CR,LF,>
0219   F815 CD 6A F8    	CALL	KIN		;GET KEYBOARD DATA
0220   F818 FE 45       	CP	'E'		;IS IT "E" (y/n)
0221   F81A 28 7E       	JR	Z,EXAM		;IF YES GO EXAMINE ROUTINE
0222   F81C FE 4F       	CP	'O'		;IS IT AN "O" (y/n)
0223   F81E CA 38 F9    	JP	Z,POUT		;PORT OUTPUT
0224   F821 FE 48       	CP	'H'		;IS IT A "H" (y/n)
0225   F823 CA D6 F9    	JP	Z,HXLOAD	;INTEL HEX FORMAT LOAD DATA
0226   F826 FE 49       	CP	'I'		;IS IT AN "I" (y/n)
0227   F828 CA 4A F9    	JP	Z,PIN		;PORT INPUT
0228   F82B FE 44       	CP	'D'		;IS IT A "D" (y/n)
0229   F82D CA 7B F9    	JP	Z,DUMP		;DUMP MEMORY
0230   F830 FE 4B       	CP	'K'
0231   F832 28 31       	JR	Z,KLOP		;LOOP ON KEYBOARD
0232   F834 FE 4D       	CP	'M'		;IS IT A "M" (y/n)
0233   F836 CA 42 FA    	JP	Z,MOVE		;MOVE MEMORY COMMAND
0234   F839 FE 46       	CP	'F'		;IS IT A "F" (y/n)
0235   F83B CA 79 FA    	JP	Z,FILL		;FILL MEMORY COMMAND
0236   F83E FE 43       	CP	'C'		;IS IT A "C" (y/n)
0237   F840 CA A3 FA    	JP	Z,GOCPM		;BOOT CP/M FROM ROM DRIVE COMMAND
0238   F843 FE 41       	CP	'A'		; is it an A
0239   F845 CA 5A F8    	JP 	Z,PRINTHELP	; print all commands out
0240   F848 FE 54       	CP	'T'
0241   F84A CA F8 FB    	JP 	z,FORMATRAM	;FORMAT the ram disk drive B
0242   F84D             ; got here, no match so print unknown command
0243   F84D E5          	PUSH	HL		;protect HL from overwrite
0244   F84E 21 22 FD    	LD	HL,TXT_COMMAND	;POINT AT TEXT
0245   F851 CD 65 F9    	CALL	MSG		;print command label
0246   F854 CD 85 F8    	CALL	COUT            ;print received command
0247   F857 E1          	POP	HL		;protect HL from overwrite
0248   F858 18 B2       	JR	CHEK
0249   F85A             
0250   F85A             
0251   F85A             ; *******************************************************
0252   F85A             ;* Help - print out all commands 
0253   F85A             ;********************************************************
0254   F85A             PRINTHELP:
0255   F85A E5          	PUSH	HL		;protect HL from overwrite
0256   F85B 21 45 FD    	LD	HL,TXT_HELP	;POINT AT TEXT
0257   F85E CD 65 F9    	CALL	MSG		;print command label
0258   F861 E1          	POP	HL		;protect HL from overwrite
0259   F862 C3 0C F8    	JP 	CHEK
0260   F865             
0261   F865             
0262   F865             ;********************************************************
0263   F865             ;*	READ THE KEYBOARD, & ECHO IT BACK TO SCREEN
0264   F865             ;********************************************************
0265   F865             
0266   F865             KLOP:
0267   F865 CD 6A F8    	CALL	KIN
0268   F868 18 FB       	JR	KLOP
0269   F86A             
0270   F86A             ;********************************************************
0271   F86A             ;*	READ THE KEYBOARD, & MAKE UPPER-CASE
0272   F86A             ;********************************************************
0273   F86A             
0274   F86A             KIN:
0275   F86A             
0276   F86A             KIN1:
0277   F86A             
0278   F86A             
0279   F86A             GETCHR:
0280   F86A             
0281   F86A             RX_BUSYLP:
0282   F86A DB 6D       	IN	A,(UART5)		; READ Line Status Register
0283   F86C CB 47       	BIT	0,A			; TEST IF DATA IN RECEIVE BUFFER
0284   F86E CA 6A F8    	JP	Z,RX_BUSYLP		; LOOP UNTIL DATA IS READY
0285   F871 DB 68       	IN	A,(UART0)		; THEN READ THE CHAR FROM THE UART
0286   F873 E6 7F       	AND	7FH		;STRIP HI BIT
0287   F875 FE 1B       	CP	ESC		;IS IT "ESCAPE" (y/n)
0288   F877 28 93       	JR	Z,CHEK		;IF SO GO BACK
0289   F879             
0290   F879             ;NOW PRINT K.B. DATA ON SCREEN
0291   F879             
0292   F879 CD 85 F8    	CALL	COUT
0293   F87C             UPCASE:
0294   F87C FE 61       	CP	'a'		;KEEP NUMBERS, CONTROLS
0295   F87E D8          	RET	C		;AND UPPER CASE
0296   F87F FE 7B       	CP	7BH		;SEE IF NOT LOWER CASE
0297   F881 D0          	RET	NC
0298   F882 E6 5F       	AND	5FH		;MAKE UPPER CASE
0299   F884 C9          	RET
0300   F885             
0301   F885             COUT:
0302   F885             
0303   F885             TX_BUSY:
0304   F885 F5          	PUSH   AF
0305   F886             TX_BUSYLP:
0306   F886 DB 6D       	IN	A,(UART5)		; READ Line Status Register
0307   F888 CB 6F       	BIT	5,A			; TEST IF UART IS READY TO SEND
0308   F88A CA 86 F8    	JP	Z,TX_BUSYLP		; IF NOT REPEAT
0309   F88D F1          	POP	AF
0310   F88E D3 68       	OUT	(UART0),A		; THEN WRITE THE CHAR TO UART
0311   F890             TX_END_CHAR:
0312   F890 C9          	RET			;DONE
0313   F891             
0314   F891             
0315   F891             ;*********************************************************
0316   F891             ;*	PRINT CARRIAGE RETURN & LINE FEED
0317   F891             ;*********************************************************
0318   F891             
0319   F891             CRLF:
0320   F891 E5          	PUSH	HL		; protect HL from overwrite
0321   F892 21 4C FC    	LD	HL,PROMPT
0322   F895 CD 65 F9    	CALL	MSG
0323   F898 E1          	POP	HL		; protect HL from overwrite
0324   F899 C9          	RET
0325   F89A             
0326   F89A             
0327   F89A             ;********************************************************
0328   F89A             ;*	ROUTINE TO DISPLAY MEMORY IN EXAMINE MODE
0329   F89A             ;********************************************************
0330   F89A             
0331   F89A             EXAM:
0332   F89A CD 91 F8    	CALL	CRLF		;SHOW EXAMINE READY
0333   F89D CD CB F8    	CALL	LDHL		;LOAD IN HL REGS.
0334   F8A0             EXAM1:
0335   F8A0 CD 91 F8    	CALL	CRLF		;SHOW READY
0336   F8A3             DHLD:
0337   F8A3 CD F6 F8    	CALL	PHLD		;PRINT HL & DATA
0338   F8A6             ECK:
0339   F8A6 CD 6A F8    	CALL	KIN		;CHECK THE K.B.
0340   F8A9 23          	INC	HL		;READY FOR NEXT LOCATION
0341   F8AA FE 20       	CP	' '		;A SPACE (y/n)
0342   F8AC 28 F2       	JR	Z,EXAM1
0343   F8AE 2B          	DEC	HL		;RESET IF NOT NEXT
0344   F8AF FE 52       	CP	'R'
0345   F8B1 20 01       	JR	NZ,SEEP
0346   F8B3 E9          	JP	(HL)
0347   F8B4             
0348   F8B4             SEEP:
0349   F8B4 FE 50       	CP	'P'		;IS IT A "P" (y/n)
0350   F8B6 20 EE       	JR	NZ,ECK		;IF YES GO PROGRAM
0351   F8B8             
0352   F8B8             
0353   F8B8             ;****************************************************
0354   F8B8             ;*	'PROGRAM' THE MEMORY LOCATION
0355   F8B8             ;*	& INCREMENT TO THE NEXT ONE
0356   F8B8             ;****************************************************
0357   F8B8             
0358   F8B8             PROG:
0359   F8B8 CD 91 F8    	CALL	CRLF		;SHOW READY
0360   F8BB CD 2C F9    	CALL	PHL		;GO PRINT ADDRESS
0361   F8BE CD 24 F9    	CALL	SPACE
0362   F8C1 CD D4 F8    	CALL	HEXIN		;GET K.B. DATA
0363   F8C4 77          	LD	(HL),A		;STORE IT
0364   F8C5 CD F9 F8    	CALL	PDAT		;GET DATA FROM RAM & PRINT IT
0365   F8C8 23          	INC	HL		;POINT NEXT
0366   F8C9 18 ED       	JR	PROG		;AND REPEAT IT
0367   F8CB             
0368   F8CB             
0369   F8CB             ;*****************************************************
0370   F8CB             ;*	GET TWO BYTES OF HEX DATA FROM K.B.
0371   F8CB             ;*	& RETURN WITH THEM IN HL REGS
0372   F8CB             ;*****************************************************
0373   F8CB             
0374   F8CB             LDHL:
0375   F8CB CD D4 F8    	CALL	HEXIN		;GET K.B. AND MAKE HEX
0376   F8CE 67          	LD	H,A		;THATS THE HI BYTE
0377   F8CF CD D4 F8    	CALL	HEXIN		;DO HEX AGAIN
0378   F8D2 6F          	LD	L,A		;THATS THE LOW BYTE
0379   F8D3 C9          	RET			;GO BACK WITH ADDRESS  
0380   F8D4             
0381   F8D4             
0382   F8D4             ;*****************************************************
0383   F8D4             ;*	GET K.B. DATA & MAKE IT 'HEX'
0384   F8D4             ;*****************************************************
0385   F8D4             
0386   F8D4             HEXIN:
0387   F8D4 C5          	PUSH	BC		;SAVE BC REGS.
0388   F8D5 CD E7 F8    	CALL	NIBL		;DO A NIBBLE
0389   F8D8 CB 07       	RLC	A		;MOVE FIRST BYTE UPPER NIBBLE  
0390   F8DA CB 07       	RLC	A
0391   F8DC CB 07       	RLC	A
0392   F8DE CB 07       	RLC	A
0393   F8E0 47          	LD	B,A		;SAVE ROTATED BYTE
0394   F8E1 CD E7 F8    	CALL	NIBL		;DO NEXT NIBBLE
0395   F8E4 80          	ADD	A,B		;COMBINE NIBBLES IN ACC.
0396   F8E5 C1          	POP	BC		;RESTORE BC
0397   F8E6 C9          	RET			;DONE  
0398   F8E7             NIBL:
0399   F8E7 CD 6A F8    	CALL	KIN		;GET K.B. DATA
0400   F8EA FE 40       	CP	40H		;TEST FOR ALPHA
0401   F8EC 30 03       	JR	NC,ALPH
0402   F8EE E6 0F       	AND	0FH		;GET THE BITS
0403   F8F0 C9          	RET
0404   F8F1             ALPH:
0405   F8F1 E6 0F       	AND	0FH		;GET THE BITS
0406   F8F3 C6 09       	ADD	A,09H		;MAKE IT HEX A-F
0407   F8F5 C9          	RET
0408   F8F6             
0409   F8F6             
0410   F8F6             ;**************************************************
0411   F8F6             ;*	PRINT THE HL REGS & THE DATA AT
0412   F8F6             ;*	THE LOCATION POINTED TO BY SAME
0413   F8F6             ;**************************************************
0414   F8F6             
0415   F8F6             PHLD:
0416   F8F6 CD 2C F9    	CALL	PHL		;GO PRINT HL
0417   F8F9             PDAT:
0418   F8F9 CD 24 F9    	CALL	SPACE		;PRINT A SPACE
0419   F8FC 7E          	LD	A,(HL)		;GET THE DATA
0420   F8FD             
0421   F8FD             
0422   F8FD             ;**************************************************
0423   F8FD             ;*	PRINT THE ACCUMULATOR CONTENTS AS
0424   F8FD             ;*	HEX DATA ON THE SCREEN
0425   F8FD             ;**************************************************
0426   F8FD             
0427   F8FD             HXOUT:
0428   F8FD C5          	PUSH	BC		;SAVE BC
0429   F8FE 47          	LD	B,A
0430   F8FF CB 07       	RLC	A		;DO HIGH NIBBLE FIRST  
0431   F901 CB 07       	RLC	A
0432   F903 CB 07       	RLC	A
0433   F905 CB 07       	RLC	A
0434   F907 E6 0F       	AND	0FH		;ONLY THIS NOW
0435   F909 C6 30       	ADD	A,30H		;TRY A NUMBER
0436   F90B FE 3A       	CP	3AH		;TEST IT
0437   F90D 38 02       	JR	C,OUT1		;IF CY SET PRINT 'NUMBER'
0438   F90F C6 07       	ADD	A,07H		;MAKE IT AN ALPHA
0439   F911             
0440   F911             OUT1:
0441   F911 CD 85 F8    	CALL	COUT		;SCREEN IT
0442   F914 78          	LD	A,B		;NEXT NIBBLE
0443   F915 E6 0F       	AND	0FH		;JUST THIS
0444   F917 C6 30       	ADD	A,30H		;TRY A NUMBER
0445   F919 FE 3A       	CP	3AH		;TEST IT
0446   F91B 38 02       	JR	C,OUT2		;PRINT 'NUMBER'
0447   F91D C6 07       	ADD	A,07H		;MAKE IT ALPHA
0448   F91F             
0449   F91F             OUT2:
0450   F91F CD 85 F8    	CALL	COUT		;SCREEN IT
0451   F922 C1          	POP	BC		;RESTORE BC
0452   F923 C9          	RET
0453   F924             
0454   F924             
0455   F924             ;***************************************************
0456   F924             ;*	PRINT A SPACE CHARACTER ON THE SCREEN
0457   F924             ;***************************************************
0458   F924             
0459   F924             SPACE:
0460   F924 F5          	PUSH	AF
0461   F925 3E 20       	LD	A,20H		;LOAD A "SPACE"
0462   F927 CD 85 F8    	CALL	COUT		;SCREEN IT
0463   F92A F1          	POP	AF
0464   F92B C9          	RET			;DONE
0465   F92C             
0466   F92C             
0467   F92C             ;**************************************************
0468   F92C             ;*	PRINT THE HL REGS ON THE SCREEN
0469   F92C             ;**************************************************
0470   F92C             
0471   F92C             PHL:
0472   F92C 7C          	LD	A,H		;GET HI BYTE
0473   F92D CD FD F8    	CALL	HXOUT		;DO HEX OUT ROUTINE
0474   F930 7D          	LD	A,L		;GET LOW BYTE
0475   F931 CD FD F8    	CALL	HXOUT		;HEX IT
0476   F934 CD 24 F9    	CALL	SPACE
0477   F937 C9          	RET			;DONE  
0478   F938             
0479   F938             
0480   F938             ;**************************************************
0481   F938             ;*	WRITE A BYTE TO SPECIFIED PORT
0482   F938             ;**************************************************
0483   F938             
0484   F938             POUT:
0485   F938             POUT1:
0486   F938 CD 91 F8    	CALL	CRLF
0487   F93B CD D4 F8    	CALL	HEXIN		;GET PORT
0488   F93E 4F          	LD	C,A		;SAVE PORT POINTER
0489   F93F CD 24 F9    	CALL	SPACE
0490   F942 CD D4 F8    	CALL	HEXIN		;GET DATA
0491   F945             OUTIT:
0492   F945 ED 79       	OUT	(C),A
0493   F947 C3 0C F8    	JP	CHEK
0494   F94A             
0495   F94A             
0496   F94A             ;**************************************************
0497   F94A             ;*	GET DATA FROM SPECIFIED PORT AND
0498   F94A             ;*	DISPLAY IT ON THE SCREEN
0499   F94A             ;**************************************************
0500   F94A             
0501   F94A             PIN:
0502   F94A CD 91 F8    	CALL	CRLF
0503   F94D CD D4 F8    	CALL	HEXIN		;GET PORT
0504   F950 4F          	LD	C,A		;SAVE PORT POINTER
0505   F951 CD 24 F9    	CALL	SPACE
0506   F954 ED 78       	IN	A,(C)		;GET DATA
0507   F956 CD FD F8    	CALL	HXOUT		;SHOW IT
0508   F959 C3 0C F8    	JP	CHEK		
0509   F95C             
0510   F95C             
0511   F95C             ;******************************************************
0512   F95C             ;*	PRINT CARRIAGE RETURN, LINE FEED & >
0513   F95C             ;******************************************************
0514   F95C             
0515   F95C             CRLFA:
0516   F95C E5          	PUSH	HL		; protect HL from overwrite
0517   F95D 21 4F FC    	LD	HL,PROMPTA
0518   F960 CD 65 F9    	 CALL	MSG
0519   F963 E1          	POP	HL		; protect HL from overwrite
0520   F964 C9          	RET			;DONE
0521   F965             
0522   F965             
0523   F965             ;*******************************************************
0524   F965             ;*	MESSAGE PRINT ROUTINE
0525   F965             ;*******************************************************
0526   F965             
0527   F965             MSG:
0528   F965             
0529   F965             TX_SERLP:
0530   F965 7E          	LD	A,(HL)			; GET CHARACTER TO A
0531   F966 FE FF       	CP	END			; TEST FOR END BYTE
0532   F968 CA 7A F9    	JP	Z,TX_END		; JUMP IF END BYTE IS FOUND
0533   F96B F5          	PUSH   AF
0534   F96C             TX_BUSYLP_MSG:
0535   F96C DB 6D       	IN	A,(UART5)		; READ Line Status Register
0536   F96E CB 6F       	BIT	5,A			; TEST IF UART IS READY TO SEND
0537   F970 CA 6C F9    	JP	Z,TX_BUSYLP_MSG		; IF NOT REPEAT
0538   F973 F1          	POP	AF
0539   F974 D3 68       	OUT	(UART0),A		; THEN WRITE THE CHAR TO UART
0540   F976 23          	INC	HL			; INC POINTER, TO NEXT CHAR
0541   F977 C3 65 F9    	JP	TX_SERLP		; TRANSMIT LOOP
0542   F97A             TX_END:
0543   F97A C9          	RET				;ELSE DONE
0544   F97B             
0545   F97B             ;****************************************************
0546   F97B             ;	DUMP MEMORY ROUTINE
0547   F97B             ;****************************************************
0548   F97B             
0549   F97B             DUMP:
0550   F97B 31 FF FF    	LD	SP,RAMTOP
0551   F97E CD 91 F8    	CALL	CRLF		;SHOW READY
0552   F981 CD CB F8    	CALL	LDHL		;GET START ADDRESS
0553   F984 E5          	PUSH	HL		;SAVE START
0554   F985 CD 24 F9    	CALL	SPACE
0555   F988 CD CB F8    	CALL	LDHL		;GET END ADDRESS
0556   F98B 23          	INC	HL		;ADD ONE MORE FOR LATER COMPARE
0557   F98C EB          	EX	DE,HL		;PUT END ADDRESS IN DE
0558   F98D E1          	POP	HL		;GET BACK START
0559   F98E             
0560   F98E             GDATA:	
0561   F98E CD 91 F8    	CALL	CRLF	
0562   F991             
0563   F991             BLKRD:
0564   F991 CD 2C F9    	CALL	PHL		;PRINT START LOCATION
0565   F994 0E 10       	LD	C,16		;SET FOR 16 LOCS
0566   F996 E5          	PUSH	HL		;SAVE STARTING HL
0567   F997             NXTONE:
0568   F997 D9          	EXX
0569   F998 4B          	LD	C,E
0570   F999 ED 78       	IN	A,(C)
0571   F99B D9          	EXX
0572   F99C E6 7F       	AND	7FH
0573   F99E FE 1B       	CP	ESC
0574   F9A0 CA 0C F8    	JP	Z,CHEK
0575   F9A3 FE 13       	CP	19
0576   F9A5 28 F0       	JR	Z,NXTONE
0577   F9A7 7E          	LD 	A,(HL)		;GET BYTE
0578   F9A8 CD FD F8    	CALL	HXOUT		;PRINT IT
0579   F9AB CD 24 F9    	CALL	SPACE
0580   F9AE             
0581   F9AE             UPDH:	
0582   F9AE 23          	INC	HL		;POINT NEXT
0583   F9AF 0D          	DEC	C		;DEC. LOC COUNT
0584   F9B0 20 E5       	JR	NZ,NXTONE	;IF LINE NOT DONE
0585   F9B2             
0586   F9B2             ;NOW PRINT 'DECODED' DATA TO RIGHT OF DUMP
0587   F9B2             
0588   F9B2             PCRLF:
0589   F9B2 CD 24 F9    	CALL	SPACE		;SPACE IT
0590   F9B5 0E 10       	LD	C,16		;SET FOR 16 CHARS
0591   F9B7 E1          	POP	HL		;GET BACK START
0592   F9B8             
0593   F9B8             PCRLF0:
0594   F9B8 7E          	LD	A,(HL)		;GET BYTE
0595   F9B9 E6 60       	AND	060H		;SEE IF A 'DOT'
0596   F9BB 7E          	LD	A,(HL)		;O.K. TO GET
0597   F9BC 20 02       	JR	NZ,PDOT
0598   F9BE             DOT:
0599   F9BE 3E 2E       	LD	A,2EH		;LOAD A DOT	
0600   F9C0             PDOT:
0601   F9C0 CD 85 F8    	CALL	COUT		;PRINT IT
0602   F9C3 23          	INC	HL
0603   F9C4 7A          	LD	A,D
0604   F9C5 BC          	CP	H
0605   F9C6 20 05       	JR	NZ,UPDH1
0606   F9C8 7B          	LD	A,E
0607   F9C9 BD          	CP	L
0608   F9CA CA 0C F8    	JP	Z,CHEK
0609   F9CD             
0610   F9CD             ;IF BLOCK NOT DUMPED, DO NEXT CHARACTER OR LINE
0611   F9CD             	
0612   F9CD             UPDH1:
0613   F9CD 0D          	DEC	C		;DEC. CHAR COUNT
0614   F9CE 20 E8       	JR	NZ,PCRLF0	;DO NEXT
0615   F9D0             CONTD:
0616   F9D0 CD 91 F8    	CALL	CRLF
0617   F9D3 C3 91 F9    	JP	BLKRD
0618   F9D6             
0619   F9D6             
0620   F9D6             ;****************************************************
0621   F9D6             ;	INTEL HEX FORMAT LOAD ROUTINE
0622   F9D6             ;****************************************************
0623   F9D6             
0624   F9D6             ;-------------------------------------------------------------------------------------
0625   F9D6             ; LOAD INTEL HEX FORMAT FILE FROM THE CONSOLE.
0626   F9D6             ; [INTEL HEX FORMAT IS:
0627   F9D6             ; 1) COLON (FRAME 0)
0628   F9D6             ; 2) RECORD LENGTH FIELD (FRAMES 1 AND 2)
0629   F9D6             ; 3) LOAD ADDRESS FIELD (FRAMES 3,4,5,6)
0630   F9D6             ; 4) RECORD TYPE FIELD (FRAMES 7 AND 8)
0631   F9D6             ; 5) DATA FIELD (FRAMES 9 TO 9+2*(RECORD LENGTH)-1
0632   F9D6             ; 6) CHECKSUM FIELD - SUM OF ALL BYTE VALUES FROM RECORD LENGTH TO AND 
0633   F9D6             ;   INCLUDING CHECKSUM FIELD = 0 ]
0634   F9D6             ;------------------------------------------------------------------------------	
0635   F9D6             ;EXAMPLE OF INTEL HEX FORMAT FILE
0636   F9D6             ;EACH LINE CONTAINS A CARRIAGE RETURN AS THE LAST CHARACTER
0637   F9D6             ;:18F900002048454C4C4F20574F524C4420FF0D0AFF0D0A3EFF0D0A54BF
0638   F9D6             ;:18F918006573742050726F746F7479706520524F4D204D6F6E69746FF1
0639   F9D6             ;:18F9300072205265616479200D0AFF0D0A434F4D4D414E4420524543F2
0640   F9D6             ;:18F948004549564544203AFF0D0A434845434B53554D204552524F52CD
0641   F9D6             ;:16F96000FF0A0D20202D454E442D4F462D46494C452D20200A0DA4
0642   F9D6             ;:00000001FF
0643   F9D6             
0644   F9D6             
0645   F9D6             HXLOAD:
0646   F9D6 CD 91 F8    	CALL	CRLF		; SHOW READY
0647   F9D9             
0648   F9D9             HXLOAD0:
0649   F9D9 CD 6A F8    	CALL	KIN		; GET THE FIRST CHARACTER, EXPECTING A ':'
0650   F9DC             
0651   F9DC             HXLOAD1:
0652   F9DC FE 3A       	CP	$3A		; IS IT COLON ':'? START OF LINE OF INTEL HEX FILE
0653   F9DE 20 47       	JR	NZ,HXLOADERR	; IF NOT, MUST BE ERROR, ABORT ROUTINE
0654   F9E0             
0655   F9E0 1E 00       	LD	E,0		; FIRST TWO CHARACTERS IS THE RECORD LENGTH FIELD
0656   F9E2             
0657   F9E2 CD D4 F8    	CALL	HEXIN		; GET US TWO CHARACTERS INTO BC, CONVERT IT TO A BYTE <A>
0658   F9E5 CD 30 FA    	CALL	HXCHKSUM	; UPDATE HEX CHECK SUM
0659   F9E8             
0660   F9E8 57          	LD	D,A		; LOAD RECORD LENGTH COUNT INTO D
0661   F9E9             
0662   F9E9 CD D4 F8    	CALL	HEXIN		; GET NEXT TWO CHARACTERS, MEMORY LOAD ADDRESS <H>
0663   F9EC CD 30 FA    	CALL	HXCHKSUM	; UPDATE HEX CHECK SUM
0664   F9EF             
0665   F9EF 67          	LD	H,A		; PUT VALUE IN H REGISTER.
0666   F9F0             
0667   F9F0 CD D4 F8    	CALL	HEXIN		; GET NEXT TWO CHARACTERS, MEMORY LOAD ADDRESS <L>
0668   F9F3 CD 30 FA    	CALL	HXCHKSUM	; UPDATE HEX CHECK SUM
0669   F9F6             
0670   F9F6 6F          	LD	L,A		; PUT VALUE IN L REGISTER.
0671   F9F7             
0672   F9F7 CD D4 F8    	CALL	HEXIN		; GET NEXT TWO CHARACTERS, RECORD FIELD TYPE
0673   F9FA CD 30 FA    	CALL	HXCHKSUM	; UPDATE HEX CHECK SUM
0674   F9FD             
0675   F9FD FE 01       	CP	$01		; RECORD FIELD TYPE 00 IS DATA, 01 IS END OF FILE
0676   F9FF 20 0D       	JR	NZ,HXLOAD2	; MUST BE THE END OF THAT FILE
0677   FA01             
0678   FA01 CD D4 F8    	CALL	HEXIN		; GET NEXT TWO CHARACTERS, ASSEMBLE INTO BYTE
0679   FA04 CD 30 FA    	CALL	HXCHKSUM	; UPDATE HEX CHECK SUM
0680   FA07             
0681   FA07 7B          	LD	A,E		; RECALL THE CHECKSUM BYTE
0682   FA08 A7          	AND	A		; IS IT ZERO?
0683   FA09 CA 3C FA            JP      Z,HXLOADEXIT	; MUST BE O.K., GO BACK FOR SOME MORE, ELSE
0684   FA0C 18 19       	JR	HXLOADERR	; CHECKSUMS DON'T ADD UP, ERROR OUT
0685   FA0E             		
0686   FA0E             HXLOAD2:
0687   FA0E 7A          	LD	A,D		; RETRIEVE LINE CHARACTER COUNTER	
0688   FA0F A7          	AND	A		; ARE WE DONE WITH THIS LINE?
0689   FA10 28 0B       	JR	Z,HXLOAD3	; GET TWO MORE ASCII CHARACTERS, BUILD A BYTE AND CHECKSUM
0690   FA12 CD D4 F8    	CALL	HEXIN		; GET NEXT TWO CHARS, CONVERT TO BYTE IN A, CHECKSUM IT
0691   FA15 CD 30 FA    	CALL	HXCHKSUM	; UPDATE HEX CHECK SUM
0692   FA18 77          	LD	(HL),A		; CHECKSUM OK, MOVE CONVERTED BYTE IN A TO MEMORY LOCATION
0693   FA19 23          	INC	HL		; INCREMENT POINTER TO NEXT MEMORY LOCATION	
0694   FA1A 15          	DEC	D		; DECREMENT LINE CHARACTER COUNTER
0695   FA1B 18 F1       	JR	HXLOAD2		; AND KEEP LOADING INTO MEMORY UNTIL LINE IS COMPLETE
0696   FA1D             		
0697   FA1D             HXLOAD3:
0698   FA1D CD D4 F8    	CALL	HEXIN		; GET TWO CHARS, BUILD BYTE AND CHECKSUM
0699   FA20 CD 30 FA    	CALL	HXCHKSUM	; UPDATE HEX CHECK SUM
0700   FA23 7B          	LD	A,E		; CHECK THE CHECKSUM VALUE
0701   FA24 A7          	AND	A		; IS IT ZERO?
0702   FA25 28 0F       	JR	Z,HXLOADAGAIN	; IF THE CHECKSUM IS STILL OK, CONTINUE ON, ELSE
0703   FA27             
0704   FA27             
0705   FA27             HXLOADERR:
0706   FA27 21 34 FD    	LD	HL,TXT_CKSUMERR	; GET "CHECKSUM ERROR" MESSAGE
0707   FA2A CD 65 F9    	CALL	MSG		; PRINT MESSAGE FROM (HL) AND TERMINATE THE LOAD
0708   FA2D C3 3C FA    	JP	HXLOADEXIT	; RETURN TO PROMPT
0709   FA30             
0710   FA30             HXCHKSUM:
0711   FA30 4F          	LD	C,A		; BUILD THE CHECKSUM
0712   FA31 7B          	LD	A,E
0713   FA32 91          	SUB	C		; THE CHECKSUM SHOULD ALWAYS EQUAL ZERO WHEN CHECKED
0714   FA33 5F          	LD	E,A		; SAVE THE CHECKSUM BACK WHERE IT CAME FROM
0715   FA34 79          	LD	A,C		; RETRIEVE THE BYTE AND GO BACK
0716   FA35 C9          	RET			; BACK TO CALLER
0717   FA36             
0718   FA36             HXLOADAGAIN:
0719   FA36 CD 6A F8    	CALL	KIN		; CATCH THE TRAILING CARRIAGE RETURN
0720   FA39 C3 D9 F9    	JP	HXLOAD0		; LOAD ANOTHER LINE OF DATA
0721   FA3C             
0722   FA3C             HXLOADEXIT:
0723   FA3C CD 6A F8    	CALL	KIN		; CATCH ANY STRAY TRAILING CHARACTERS
0724   FA3F C3 0C F8    	JP	CHEK		; RETURN TO PROMPT
0725   FA42             
0726   FA42             
0727   FA42             ;****************************************************
0728   FA42             ;	MOVE MEMORY ROUTINE
0729   FA42             ;****************************************************
0730   FA42             
0731   FA42             	;
0732   FA42             	; MOVE COMMAND
0733   FA42             	; MOVE MEMORY- MXXXX,YYYY,ZZZZ
0734   FA42             	; MOVE MEMORY STARTING FROM XXXX TO YYYY TO LOCATION
0735   FA42             	;	STARTING AT ZZZZ
0736   FA42             
0737   FA42             MOVE:
0738   FA42 0E 03       	LD	C,03
0739   FA44             
0740   FA44             
0741   FA44             ; start GETNM replacement
0742   FA44             
0743   FA44             				; get source starting memory location
0744   FA44 CD 91 F8    	CALL	CRLF		;SHOW EXAMINE READY
0745   FA47 CD CB F8    	CALL	LDHL		;LOAD IN HL REGS.
0746   FA4A E5          	PUSH	HL		; push memory address on stack
0747   FA4B CD 24 F9    	CALL	SPACE		; print space separator
0748   FA4E             			; get source ending memory location
0749   FA4E CD CB F8    	CALL	LDHL		;LOAD IN HL REGS.
0750   FA51 E5          	PUSH	HL		; push memory address on stack
0751   FA52 CD 24 F9    	CALL	SPACE		; print space separator
0752   FA55             				; get target starting memory location
0753   FA55 CD CB F8    	CALL	LDHL		;LOAD IN HL REGS.
0754   FA58 E5          	PUSH	HL		; push memory address on stack
0755   FA59             
0756   FA59             ; end GETNM replacement
0757   FA59 D1          	POP	DE	; DEST
0758   FA5A C1          	POP	BC	; SOURCE END
0759   FA5B E1          	POP	HL	; SOURCE
0760   FA5C E5          	PUSH    HL
0761   FA5D 7D          	LD	A,L
0762   FA5E 2F          	CPL
0763   FA5F 6F          	LD	L,A
0764   FA60 7C          	LD	A,H
0765   FA61 2F          	CPL
0766   FA62 67          	LD	H,A
0767   FA63 23          	INC	HL
0768   FA64 09          	ADD	HL,BC
0769   FA65 4D          	LD	C,L
0770   FA66 44          	LD	B,H
0771   FA67 E1          	POP     HL        
0772   FA68 CD 6E FA    	CALL    MOVE_LOOP
0773   FA6B C3 0C F8    	JP	CHEK	; EXIT MOVE COMMAND ROUTINE
0774   FA6E                     ;
0775   FA6E             MOVE_LOOP:
0776   FA6E 7E          	LD	A,(HL)	; FETCH
0777   FA6F 12          	LD	(DE),A	; DEPOSIT
0778   FA70 23          	INC     HL	; BUMP  SOURCE
0779   FA71 13          	INC     DE	; BUMP DEST
0780   FA72 0B          	DEC     BC	; DEC COUNT
0781   FA73 79          	LD	A,C
0782   FA74 B0          	OR	B       
0783   FA75 C2 6E FA    	JP	NZ,MOVE_LOOP	; TIL COUNT=0
0784   FA78 C9          	RET
0785   FA79                            
0786   FA79             ;****************************************************
0787   FA79             ;	FILL MEMORY ROUTINE
0788   FA79             ;****************************************************
0789   FA79             
0790   FA79             
0791   FA79             	;	FILL COMMAND
0792   FA79             	;	FILL RAM WITH PATTERN- FXXXX,YYYY,DD
0793   FA79             	;
0794   FA79             
0795   FA79             
0796   FA79             FILL:
0797   FA79 0E 03       	LD	C,03
0798   FA7B             
0799   FA7B             ; start GETNM replacement
0800   FA7B             
0801   FA7B             				; get fill starting memory location
0802   FA7B CD 91 F8    	CALL	CRLF		;SHOW EXAMINE READY
0803   FA7E CD CB F8    	CALL	LDHL		;LOAD IN HL REGS.
0804   FA81 E5          	PUSH	HL		; push memory address on stack
0805   FA82             
0806   FA82 CD 24 F9    	CALL	SPACE		; print space separator
0807   FA85             
0808   FA85             				; get fill ending memory location
0809   FA85 CD CB F8    	CALL	LDHL		;LOAD IN HL REGS.
0810   FA88 E5          	PUSH	HL		; push memory address on stack
0811   FA89             
0812   FA89 CD 24 F9    	CALL	SPACE		; print space separator
0813   FA8C             
0814   FA8C             				; get target starting memory location
0815   FA8C CD D4 F8    	CALL	HEXIN		;GET K.B. AND MAKE HEX
0816   FA8F 4F          	LD	C,A		; put fill value in F so it is saved for later
0817   FA90 C5          	PUSH	BC		; push fill value byte on stack
0818   FA91             
0819   FA91             ; end GETNM replacement
0820   FA91             
0821   FA91 C1          	POP	BC	; BYTE
0822   FA92 D1          	POP	DE	; END
0823   FA93 E1          	POP	HL	; START
0824   FA94 71          	LD	(HL),C
0825   FA95             FILL_LOOP:
0826   FA95 71          	LD	(HL),C
0827   FA96 23          	INC     HL
0828   FA97 7B          	LD	A,E
0829   FA98 95          	SUB     L
0830   FA99 47          	LD	B,A
0831   FA9A 7A          	LD	A,D
0832   FA9B 94          	SUB     H
0833   FA9C B0          	OR	B
0834   FA9D C2 95 FA    	JP	NZ,FILL_LOOP
0835   FAA0 C3 0C F8    	JP	CHEK
0836   FAA3             
0837   FAA3             ;****************************************************
0838   FAA3             ;	BOOT CP/M FROM ROM DRIVE ROUTINE
0839   FAA3             ;****************************************************
0840   FAA3             
0841   FAA3             	;
0842   FAA3             	;	BOOT CP/M FROM ROM DRIVE COMMAND
0843   FAA3             	;	C
0844   FAA3             	;
0845   FAA3             
0846   FAA3             
0847   FAA3             GOCPM:
0848   FAA3             
0849   FAA3 21 6B FF    	LD	HL,TXT_CPM		;point at text to say 'LOADING cpm
0850   FAA6 CD 65 F9    	CALL	MSG
0851   FAA9 C3 00 EA    	JP	$EA00		; CP/M COLD BOOT ENTRY POINT
0852   FAAC             ;	JP	CHEK
0853   FAAC             
0854   FAAC             
0855   FAAC             
0856   FAAC             
0857   FAAC             ;*******************************************************
0858   FAAC             ;*	FLOPPY DISK BOOT FOLLOWS
0859   FAAC             ;*******************************************************
0860   FAAC             ;*	BOOTA BOOTS FROM DRIVE A, 8"
0861   FAAC             ;*******************************************************
0862   FAAC             ;*	BOOTB IS USED TO BOOT FROM DRIVE B
0863   FAAC             ;*******************************************************
0864   FAAC             
0865   FAAC             ;BOOTB:
0866   FAAC             ;	MVI	A,7DH
0867   FAAC             ;	JMP	BOOTE
0868   FAAC             ;BOOTA:
0869   FAAC             ;	MVI	A,7EH
0870   FAAC             ;BOOTE:
0871   FAAC             ;	OUT	DCMD		;WRITE TO DRIVE CONTROL PORT
0872   FAAC             
0873   FAAC             ;RELOCATE BOOTSTRAP TO MAIN RAM
0874   FAAC             ;AND JUMP TO IT
0875   FAAC             
0876   FAAC             ;	LXI	H,BOOTS
0877   FAAC             ;	LXI	D,BSLOC
0878   FAAC             ;	LXI	B,BSLEN
0879   FAAC             ;	LDIR
0880   FAAC             ;	JMP	BSLOC
0881   FAAC             	
0882   FAAC             ;BOOTS:
0883   FAAC             ;SHUT OFF SBC-200 RAM/ROM
0884   FAAC             	
0885   FAAC             ;	MVI	A,2
0886   FAAC             ;	OUT	7FH
0887   FAAC             
0888   FAAC             ;RETRY:
0889   FAAC             ;..HOME:
0890   FAAC             ;	MVI	A,0BH		;RESTORE THE DISC DRIVE
0891   FAAC             ;	OUT	WCMD		;SEND TO CONTROLLER
0892   FAAC             
0893   FAAC             ;	MVI	B,200		;DELAY TILL VALID STATUS
0894   FAAC             ;..WAIT:	DJNZ	..WAIT
0895   FAAC             
0896   FAAC             ;..NB:	IN	WSTAT		;GET STATUS
0897   FAAC             ;	BIT	0,A		;BUSY (y/n)
0898   FAAC             ;	JRNZ	..NB		;YES,KEEP WAITING
0899   FAAC             
0900   FAAC             ; NOW READ BOOT SECTOR
0901   FAAC             
0902   FAAC             ;	MVI	A,1		;START WITH SECTOR 1
0903   FAAC             ;	OUT	WSECT		;SET SECTOR REG
0904   FAAC             ;SECTOR:
0905   FAAC             ;	LXI	H,BOOT		;WHERE SECTOR STARTS
0906   FAAC             ;	MVI	A,88H		;ISSUE READ SECTOR COMMAND 
0907   FAAC             ;	OUT	WCMD
0908   FAAC             ;	LXI	B,0067H		;SET UP BC FOR PIO READ NEXT
0909   FAAC             ;	INIR			;DO PIO SECTOR READ
0910   FAAC             ;	INIR
0911   FAAC             
0912   FAAC             ;	MVI	B,200		;DELAY TILL VALID STATUS
0913   FAAC             ;..WAIT:	DJNZ	..WAIT
0914   FAAC             
0915   FAAC             ;..NB:	IN	WSTAT		;GET STATUS
0916   FAAC             ;	BIT	0,A		;BUSY (y/n)
0917   FAAC             ;	JRNZ	..NB		;YES,KEEP WAITING
0918   FAAC             ;	ANI	9DH		;WAS READ SUCCESSFUL(y/n)
0919   FAAC             ;	JZ	BOOT		;GET SYSTEM
0920   FAAC             ;	JMPR	RETRY
0921   FAAC             
0922   FAAC             ;	BSLEN	==	.-BOOTS
0923   FAAC             
0924   FAAC             
0925   FAAC             
0926   FAAC             ; BOOT FROM WITHIN ROM
0927   FAAC             ; CPM MUST FIT BELOW ONBOARD RAM/ROM
0928   FAAC             
0929   FAAC             ;BOOTR2:
0930   FAAC             ;	MVI	A,7DH
0931   FAAC             ;	JMP	BOOTRE
0932   FAAC             ;BOOTR1:
0933   FAAC             ;	MVI	A,7EH
0934   FAAC             ;BOOTRE:
0935   FAAC             ;	OUT  	DCMD		;WRITE TO DRIVE CONTROL PORT
0936   FAAC             ;	JMP	RETRY
0937   FAAC             
0938   FAAC             
0939   FAAC             ;NEND:	.LOC	.
0940   FAAC             
0941   FAAC             
0942   FAAC             ;	.RADIX	10
0943   FAAC             
0944   FAAC             
0945   FAAC             ;	.IF1,[
0946   FAAC             ;	.DEFINE LEFMEM[XX]=[
0947   FAAC             
0948   FAAC             
0949   FAAC             ;	.PRNTX	/XX BYTES OF ROM LEFT/
0950   FAAC             
0951   FAAC             ;	]
0952   FAAC             
0953   FAAC             ;	LEFMEM	\(BEGIN+1024)-NEND
0954   FAAC             
0955   FAAC             ;	]
0956   FAAC             
0957   FAAC             
0958   FAAC             
0959   FAAC             ;	.END
0960   FAAC             
0961   FAAC             
0962   FAAC             ;******************************************************************
0963   FAAC             ;*	INIT_UART
0964   FAAC             ;*	Function	: Init serial port  8250, 16C450, OR 16C550
0965   FAAC             ;*			9600 Baud, 8 bit, 1 stopbit, 0 parity
0966   FAAC             ;*	Output		: none
0967   FAAC             ;*	call		: PAUSE
0968   FAAC             ;*	tested		: 2 Feb 2007
0969   FAAC             ;******************************************************************
0970   FAAC             
0971   FAAC             INIT_UART:
0972   FAAC 3E AA       	LD	A,$AA
0973   FAAE D3 6F       	OUT	(UART7),A
0974   FAB0 DB 6F       	IN	A,(UART7)
0975   FAB2 FE AA       	CP	$AA	; TEST IF YOU COULD STORE AA
0976   FAB4 C2 CA FA    	JP	NZ,INITUART_FAIL	; IF NOT, THE UART CAN'T BE FOUND
0977   FAB7 3E 55       	LD	A,$55
0978   FAB9 D3 6F       	OUT	(UART7),A		; 
0979   FABB DB 6F       	IN	A,(UART7)
0980   FABD FE 55       	CP	$55			; 
0981   FABF C2 CA FA    	JP	NZ,INITUART_FAIL
0982   FAC2 3E 01       	LD	A,$01
0983   FAC4 32 3B FC    	LD	(SER_ON),A
0984   FAC7 C3 D0 FA    	JP	UART_OK
0985   FACA             
0986   FACA             INITUART_FAIL:				; Handle if initialize UART fails
0987   FACA 3E 01       	LD	A,1
0988   FACC 32 3C FC    	LD	(UART_FAIL),A
0989   FACF 76          	HALT
0990   FAD0             
0991   FAD0             
0992   FAD0             UART_OK:
0993   FAD0 3E 00       	LD	A,0
0994   FAD2 32 3C FC    	LD	(UART_FAIL),A		; UART OK FOUND
0995   FAD5 3A 3D FC    	LD	A,(SER_BAUD)
0996   FAD8 FE 01       	CP	1
0997   FADA CA 00 FB    	JP	Z,UART1200
0998   FADD FE 02       	CP	2
0999   FADF CA 13 FB    	JP	Z,UART2400
1000   FAE2 FE 03       	CP	3
1001   FAE4 CA 26 FB    	JP	Z,UART4800
1002   FAE7 FE 04       	CP	4
1003   FAE9 CA 39 FB    	JP	Z,UART9600
1004   FAEC FE 05       	CP	5
1005   FAEE CA 4C FB    	JP	Z,UART19K2
1006   FAF1 FE 06       	CP	6
1007   FAF3 CA 5F FB    	JP	Z,UART38K4
1008   FAF6 FE 07       	CP	7
1009   FAF8 CA 72 FB    	JP	Z,UART57K6
1010   FAFB FE 08       	CP	8
1011   FAFD CA 85 FB    	JP	Z,UART115K2
1012   FB00             					; IF NOTHING IS DEFINED 1200 WILL BE USED..
1013   FB00             
1014   FB00             
1015   FB00             UART1200:
1016   FB00 3E 80       	LD	A,80H
1017   FB02 D3 6B       	OUT	(UART3),A		; SET DLAB FLAG
1018   FB04 3E 60       	LD	A,96			;  = 1,843,200 / ( 16 x 1200 )
1019   FB06 D3 68       	OUT	(UART0),A		;
1020   FB08 3E 00       	LD	A,00H
1021   FB0A D3 69       	OUT	(UART1),A		;
1022   FB0C 3E 03       	LD	A,03H
1023   FB0E D3 6B       	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
1024   FB10             
1025   FB10             ;	LD	A,03H
1026   FB10             ;	OUT	(UART4),A		; Force DTR and RTS
1027   FB10             
1028   FB10 C3 95 FB    	JP	INITRET			; 0 parity, reset DLAP FLAG
1029   FB13             UART2400:
1030   FB13 3E 80       	LD	A,80H
1031   FB15 D3 6B       	OUT	(UART3),A		; SET DLAB FLAG
1032   FB17 3E 30       	LD	A,48			; = 1,843,200 / ( 16 x 2400 )
1033   FB19 D3 68       	OUT	(UART0),A		;
1034   FB1B 3E 00       	LD	A,00H
1035   FB1D D3 69       	OUT	(UART1),A		;
1036   FB1F 3E 03       	LD	A,03H
1037   FB21 D3 6B       	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
1038   FB23 C3 95 FB    	JP	INITRET			; 0 parity, reset DLAP FLAG
1039   FB26             UART4800:
1040   FB26 3E 80       	LD	A,80H
1041   FB28 D3 6B       	OUT	(UART3),A		; SET DLAB FLAG
1042   FB2A 3E 18       	LD	A,24			; = 1,843,200 / ( 16 x 4800 )
1043   FB2C D3 68       	OUT	(UART0),A		;
1044   FB2E 3E 00       	LD	A,00H
1045   FB30 D3 69       	OUT	(UART1),A		;
1046   FB32 3E 03       	LD	A,03H
1047   FB34 D3 6B       	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
1048   FB36 C3 95 FB    	JP	INITRET			; 0 parity, reset DLAP FLAG
1049   FB39 3E 80       UART9600:	LD	A,80H
1050   FB3B D3 6B       	OUT	(UART3),A		; SET DLAB FLAG
1051   FB3D 3E 0C       	LD	A,12			; = 1,843,200 / ( 16 x 9600 )
1052   FB3F D3 68       	OUT	(UART0),A		; Set BAUD rate til 9600
1053   FB41 3E 00       	LD	A,00H
1054   FB43 D3 69       	OUT	(UART1),A		; Set BAUD rate til 9600
1055   FB45 3E 03       	LD	A,03H
1056   FB47 D3 6B       	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
1057   FB49 C3 95 FB    	JP	INITRET			; 0 parity, reset DLAP FLAG
1058   FB4C 3E 80       UART19K2:	LD	A,80H
1059   FB4E D3 6B       	OUT	(UART3),A		; SET DLAB FLAG
1060   FB50 3E 06       	LD	A,06			; = 1,843,200 / ( 16 x 19,200 )
1061   FB52 D3 68       	OUT	(UART0),A		;
1062   FB54 3E 00       	LD	A,0
1063   FB56 D3 69       	OUT	(UART1),A		;
1064   FB58 3E 03       	LD	A,3
1065   FB5A D3 6B       	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
1066   FB5C C3 95 FB    	JP	INITRET			; 0 parity, reset DLAP FLAG
1067   FB5F 3E 80       UART38K4:	LD	A,80H
1068   FB61 D3 6B       	OUT	(UART3),A		; SET DLAB FLAG
1069   FB63 3E 03       	LD	A,03
1070   FB65 D3 68       	OUT	(UART0),A		; = 1,843,200 / ( 16 x 38,400 )
1071   FB67 3E 00       	LD	A,00H
1072   FB69 D3 69       	OUT	(UART1),A		;
1073   FB6B 3E 03       	LD	A,03H
1074   FB6D D3 6B       	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
1075   FB6F C3 95 FB    	JP	INITRET			; 0 parity, reset DLAP FLAG
1076   FB72 3E 80       UART57K6:	LD	A,80H
1077   FB74 D3 6B       	OUT	(UART3),A		; SET DLAB FLAG
1078   FB76 3E 02       	LD	A,02
1079   FB78 D3 68       	OUT	(UART0),A		; = 1,843,200 / ( 16 x 57,600 )
1080   FB7A 3E 00       	LD	A,00H
1081   FB7C D3 69       	OUT	(UART1),A		;
1082   FB7E 3E 03       	LD	A,03H
1083   FB80 D3 6B       	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
1084   FB82 C3 95 FB    	JP	INITRET			; 0 parity, reset DLAP FLAG
1085   FB85 3E 80       UART115K2:	LD	A,80H
1086   FB87 D3 6B       	OUT	(UART3),A		; SET DLAB FLAG
1087   FB89 3E 01       	LD	A,01
1088   FB8B D3 68       	OUT	(UART0),A		; = 1,843,200 / ( 16 x 115,200 )
1089   FB8D 3E 00       	LD	A,00H
1090   FB8F D3 69       	OUT	(UART1),A		;
1091   FB91 3E 03       	LD	A,03H
1092   FB93 D3 6B       	OUT	(UART3),A		; Set 8 bit data, 1 stopbit
1093   FB95             					; 0 parity, reset DLAP FLAG
1094   FB95             INITRET:
1095   FB95 C9          	RET
1096   FB96             
1097   FB96             
1098   FB96             ;******************************************************************
1099   FB96             ;*	INIT_PIO
1100   FB96             ;*	Function	: Init parallel port >82C55<
1101   FB96             ;******************************************************************
1102   FB96             
1103   FB96             INIT_PIO:
1104   FB96 3E 99       	LD	A,10011001B		; A= IN, B= OUT C= IN
1105   FB98 D3 63       	OUT	(PIO1CONT),A
1106   FB9A C9          	RET
1107   FB9B             
1108   FB9B             
1109   FB9B             ;******************************************************************
1110   FB9B             ;*	SUB-ROUTINE	: PAUSE
1111   FB9B             ;*	Function	: Pause in 100uS. times value in BC
1112   FB9B             ;*	Input		: BC reg
1113   FB9B             ;*	Output		: none
1114   FB9B             ;*	call		: NONE
1115   FB9B             ;*	Info		: KEA. 
1116   FB9B             ;*	tested		: 2 Feb 2007
1117   FB9B             ;******************************************************************
1118   FB9B             
1119   FB9B             PAUSE:
1120   FB9B F5          	PUSH	AF
1121   FB9C 04          	INC	B
1122   FB9D 0C          	INC	C			; ADJUST THE LOOP
1123   FB9E 3E 13       PAUSELOOP1:	LD	A,13H		; ADJUST THE TIME 13h IS FOR 4 MHZ
1124   FBA0 3D          PAUSELOOP2:	DEC	A		; DEC COUNTER. 4 T-states = 1 uS.
1125   FBA1 C2 A0 FB    	JP	NZ,PAUSELOOP2		; JUMP TO PAUSELOOP2 IF A <> 0.
1126   FBA4 0D          	DEC	C			; DEC COUNTER
1127   FBA5 C2 9E FB    	JP	NZ,PAUSELOOP1		; JUMP TO PAUSELOOP1 IF C <> 0.
1128   FBA8             
1129   FBA8 10 F4       	DJNZ	PAUSELOOP1		; JUMP TO PAUSELOOP1 IF B <> 0.
1130   FBAA F1          PAUSE_END:	POP	AF
1131   FBAB C9          	RET
1132   FBAC             
1133   FBAC             
1134   FBAC             
1135   FBAC             
1136   FBAC             
1137   FBAC             ;******************************************************************
1138   FBAC             ;*	FILL_MEM
1139   FBAC             ;*	Function	: fill memory with a value
1140   FBAC             ;*      Input		: HL = start address block
1141   FBAC             ;*			: BC = length of block
1142   FBAC             ;			: A = value to fill with
1143   FBAC             ;*	Uses		: DE, BC
1144   FBAC             ;*	Output		:
1145   FBAC             ;*	calls		: 
1146   FBAC             ;*	tested		: 13 Feb 2007
1147   FBAC             ;******************************************************************
1148   FBAC             
1149   FBAC             
1150   FBAC             FILL_MEM:
1151   FBAC             
1152   FBAC             ; This code snippet will show one method to fill a block
1153   FBAC             ; of memory with a single data byte using Z80 assembly
1154   FBAC             ; language.
1155   FBAC             
1156   FBAC             ;;--------------------------------------------------
1157   FBAC             ; 	fills with value in A
1158   FBAC             					;; HL = start address of block
1159   FBAC             					;; DE = HL + 1
1160   FBAC 5D          	ld	e,l
1161   FBAD 54          	ld	d,h
1162   FBAE 13          	inc	de
1163   FBAF             					;; initialise first byte of block
1164   FBAF             					;; with data byte (&00)
1165   FBAF             					;; with data byte in A
1166   FBAF 77          	ld	(hl),A
1167   FBB0             	
1168   FBB0             					;; BC = length of block in bytes
1169   FBB0             					;; HL+BC-1 = end address of block
1170   FBB0             					;; fill memory
1171   FBB0 ED B0       	ldir
1172   FBB2 C9          	RET				;; return to caller
1173   FBB3             
1174   FBB3             ;;--------------------------------------------------
1175   FBB3             
1176   FBB3             
1177   FBB3             
1178   FBB3             ;; For each iteration of the LDIR command:
1179   FBB3             ;;
1180   FBB3             ;; 1. This command will copy the byte from the memory 
1181   FBB3             ;; address pointed to by HL to the memory address pointed to by DE.
1182   FBB3             ;; i.e. (DE) = (HL).
1183   FBB3             ;; 2. Then HL and DE will be incremented. BC will be decremented.
1184   FBB3             ;;
1185   FBB3             ;;
1186   FBB3             ;; For the first byte:
1187   FBB3             ;; 
1188   FBB3             ;; HL = start
1189   FBB3             ;; DE = start+1
1190   FBB3             ;; BC = length
1191   FBB3             ;; (HL)=0
1192   FBB3             ;; 
1193   FBB3             ;; For the second byte:
1194   FBB3             ;; 
1195   FBB3             ;; HL = start + 1 (initialised to 0 by the previous iteration)
1196   FBB3             ;; DE = start + 2
1197   FBB3             ;; BC = length - 1
1198   FBB3             ;;
1199   FBB3             ;; For the third byte:
1200   FBB3             ;;
1201   FBB3             ;; HL = start + 2 (initialised to 0 by the previous iteration)
1202   FBB3             ;; DE = start + 3
1203   FBB3             ;; BC = length - 2
1204   FBB3             ;;
1205   FBB3             ;; etc....
1206   FBB3             
1207   FBB3             
1208   FBB3             ;******************************************************************
1209   FBB3             ;*	INITIALIZE
1210   FBB3             ;*	Function	: Master Initialize Function
1211   FBB3             ;******************************************************************
1212   FBB3             
1213   FBB3             
1214   FBB3             INITIALIZE:
1215   FBB3             
1216   FBB3             ; initialize UART related functions and variables
1217   FBB3             
1218   FBB3 3E 00       	LD	A,0
1219   FBB5 32 3B FC    	LD	(SER_ON),A	; Initialize "Serial On" flag
1220   FBB8             				; assume it is off until UART
1221   FBB8             				; is autodetected
1222   FBB8 3E 01       	LD	A,1
1223   FBBA 32 3C FC    	LD	(UART_FAIL),A	; Initialize "UART FAIL" flag
1224   FBBD             				; assume it has failed until UART
1225   FBBD             				; is autodetected as working
1226   FBBD             				; INIT AND TEST OF UART
1227   FBBD             				; ONLY CALL THIS IF YOU
1228   FBBD             				; HAVE THE UART MOUNTED..
1229   FBBD 3E 01       	LD	A,$01		; specify baud rate 1200 bps (1200,8,None,1)
1230   FBBF 3E 04       	LD	A,$04		; specify baud rate 9600 bps (9600,8,None,1)
1231   FBC1 3E 02       	LD	A,$02		; specify baud rate 2400 bps 2400,8,none,1
1232   FBC3 3E 03       	LD	A,$03		; specify baud rate 4800,8,none, 1
1233   FBC5 32 3D FC    	LD	(SER_BAUD),A	; 
1234   FBC8 CD AC FA    	CALL	INIT_UART	; WITH NO FLOW CONTROL on terminal!!
1235   FBCB             
1236   FBCB             ; turn on interrupts
1237   FBCB FB          	EI			; Start INT COUNTER
1238   FBCC             
1239   FBCC             ; initialize PIO and do LED RESET "Wake Up" routine
1240   FBCC CD 96 FB    	CALL	INIT_PIO	; initialize the PIO 
1241   FBCF 3E 00       	LD	A,0
1242   FBD1 D3 61       	OUT	(PIO1B),A	; Turn ALL BITS OFF on PIO
1243   FBD3 01 64 00    	LD	BC,100		; 10ms pause
1244   FBD6 CD 9B FB    	CALL	PAUSE
1245   FBD9 3E FF       	LD	A,255
1246   FBDB D3 61       	OUT	(PIO1B),A	; ALL BITS ON FOR 1 SEC..
1247   FBDD 01 64 00    	LD	BC,100		; 10ms pause
1248   FBE0 CD 9B FB    	CALL	PAUSE
1249   FBE3 3E 00       	LD	A,0
1250   FBE5 D3 61       	OUT	(PIO1B),A	; ALL BITS OFF
1251   FBE7 3E 00       	LD	A,%00000000
1252   FBE9 D3 78       	OUT	(MPCL_RAM),A		; reset RAM memory pager configuration latch to default
1253   FBEB 3E 00       	LD	A,%00000000
1254   FBED D3 7C       	OUT	(MPCL_ROM),A		; reset ROM memory pager configuration latch to default
1255   FBEF 3E 80       	LD	A,%10000000
1256   FBF1 D3 7C       	OUT	(MPCL_ROM),A		; ensure ROM is switched out
1257   FBF3 3E 00       	LD	A,%00000000		; start RAM page counter in A at zero
1258   FBF5 D3 78       	OUT	(MPCL_RAM),A		
1259   FBF7 C9          	RET
1260   FBF8             
1261   FBF8             
1262   FBF8             FORMATRAM:
1263   FBF8 21 5B FF    	LD	HL,TXT_FORMAT		;point at text to say ' formatting...
1264   FBFB CD 65 F9    	CALL	MSG			;print command label
1265   FBFE 3E 00       	LD	A,%00000000
1266   FC00 D3 78       	OUT	(MPCL_RAM),A		; reset RAM memory pager configuration latch to default
1267   FC02 3E 00       	LD	A,%00000000
1268   FC04 D3 7C       	OUT	(MPCL_ROM),A		; reset ROM memory pager configuration latch to default
1269   FC06 3E 80       	LD	A,%10000000
1270   FC08 D3 7C       	OUT	(MPCL_ROM),A		; ensure ROM is switched out
1271   FC0A 3E 00       	LD	A,%00000000		; start RAM page counter in A at zero
1272   FC0C             FORM_MEM_LOOP:
1273   FC0C             					; objective is to initialize all SRAM pages
1274   FC0C             					; fill selected SRAM page with its page number
1275   FC0C             					; page numbers are $0-$F
1276   FC0C             					; page $F is reserved so do not overwrite it
1277   FC0C             					; or you will lose CPU context
1278   FC0C D3 78       	OUT	(MPCL_RAM),A		; switch out ROM and in SRAM page 0
1279   FC0E             					; indicate to operator what is happening by
1280   FC0E             					; flashing SRAM page number in the LEDs with
1281   FC0E             					; the MSB of LEDs lit
1282   FC0E             ;	OUT	(PIO1B),A		; output value to PIO, port B LEDs during initialize
1283   FC0E 21 00 00    	LD	HL,$0000		; specify beginning of lower 32K page in HL
1284   FC11 01 00 80    	LD	BC,$8000		; specify length of lower 32K page in BC
1285   FC14             					; specify fill value data in A
1286   FC14 CD AC FB    	CALL	FILL_MEM		; call memory fill subroutine
1287   FC17 3C          	INC	A			; select next memory page and change fill value
1288   FC18 FE 0F       	CP	$0F			; have you filled $0E pages yet?
1289   FC1A C2 0C FC    	JP	NZ,FORM_MEM_LOOP	; no, go initialize the next page
1290   FC1D             					; yes, go on to start monitor
1291   FC1D 3E 00       	LD	A,$00			
1292   FC1F             ;	OUT	(PIO1B),A		; output value to PIO, turn off port B LEDs
1293   FC1F 3E 01       	LD	A,%00000001		; switch in first 32K lower page (first track)
1294   FC21 D3 78       	OUT	(MPCL_RAM),A		;
1295   FC23             ;                   Formatting the ram is simple as clearing the directory area 
1296   FC23             ;                   to a value of E5h (the first 8k of track 1 or the ramdisk).
1297   FC23 21 00 00    	LD	HL,$0000		; starting memory address of track 1, sector 0 in HL
1298   FC26 01 FF 1F    	LD	BC,$1FFF		; 8K of directory sectors reserved (length in BC)
1299   FC29 3E E5       	LD	A,$E5			; initializing value in A 
1300   FC2B CD AC FB    	CALL	FILL_MEM		; write the data block to TRACK 1, sectors $00-$40
1301   FC2E             ; RESET MPCL latch to default CP/M with 64K setting
1302   FC2E 3E 00       	LD	A,%00000000
1303   FC30 D3 78       	OUT	(MPCL_RAM),A		; reset memory pager configuration latch to default
1304   FC32             					; default configuration is full 64K RAM and 32K ROM
1305   FC32             					; switched out
1306   FC32 3E 80       	LD	A,%10000000
1307   FC34 D3 7C       	OUT	(MPCL_ROM),A		; reset memory pager configuration latch to default
1308   FC36             					; default configuration is full 64K RAM and 32K ROM
1309   FC36             					; switched out
1310   FC36 C3 0C F8    	JP	CHEK			; Jump back to beginning
1311   FC39             
1312   FC39             
1313   FC39             
1314   FC39             
1315   FC39             
1316   FC39             ;********************* RAM VARIABLES ************************************
1317   FC39             
1318   FC39             INT_COUNTER:	.DS	1	; Interrupt-counter
1319   FC3A             COUNTER		.DS	1	; Cycle counter main loop
1320   FC3B             SER_ON:		.DS	1	; serial on/off
1321   FC3C             UART_FAIL:	.DS	1	; UART has failed detection flag
1322   FC3D             SER_BAUD:	.DS	1	; specify desired UART com rate in bps
1323   FC3E             
1324   FC3E             
1325   FC3E             ;********************* TEXT STRINGS *************************************
1326   FC3E             
1327   FC3E             TXT_HELLO:
1328   FC3E 20 48 45 4C 	.BYTE " HELLO WORLD ",END
1328   FC42 4C 4F 20 57 
1328   FC46 4F 52 4C 44 
1328   FC4A 20 FF 
1329   FC4C             
1330   FC4C             PROMPT:
1331   FC4C 0D 0A FF    	.BYTE	CR,LF,END
1332   FC4F             
1333   FC4F             PROMPTA:
1334   FC4F 0D 0A 3E FF 	.BYTE	CR,LF,'>',END
1335   FC53             
1336   FC53             TXT_READY:
1337   FC53 0D 0A       	.BYTE CR,LF
1338   FC55 4E 38 56 45 	.BYTE "N8VEM Single Board Computer "
1338   FC59 4D 20 53 69 
1338   FC5D 6E 67 6C 65 
1338   FC61 20 42 6F 61 
1338   FC65 72 64 20 43 
1338   FC69 6F 6D 70 75 
1338   FC6D 74 65 72 20 
1339   FC71 33 32 4B 2D 	.BYTE "32K-1M EPROM & Permanent RAM",CR,LF
1339   FC75 31 4D 20 45 
1339   FC79 50 52 4F 4D 
1339   FC7D 20 26 20 50 
1339   FC81 65 72 6D 61 
1339   FC85 6E 65 6E 74 
1339   FC89 20 52 41 4D 
1339   FC8D 0D 0A 
1340   FC8F 43 50 2F 4D 	.BYTE "CP/M drives are A and B",CR,LF
1340   FC93 20 64 72 69 
1340   FC97 76 65 73 20 
1340   FC9B 61 72 65 20 
1340   FC9F 41 20 61 6E 
1340   FCA3 64 20 42 0D 
1340   FCA7 0A 
1341   FCA8 42 3E 46 4F 	.BYTE "B>FORMAT formats drive A ",CR,LF
1341   FCAC 52 4D 41 54 
1341   FCB0 20 66 6F 72 
1341   FCB4 6D 61 74 73 
1341   FCB8 20 64 72 69 
1341   FCBC 76 65 20 41 
1341   FCC0 20 0D 0A 
1342   FCC3 42 3E 58 4D 	.BYTE "B>XMODEM R MYFILE.COM "
1342   FCC7 4F 44 45 4D 
1342   FCCB 20 52 20 4D 
1342   FCCF 59 46 49 4C 
1342   FCD3 45 2E 43 4F 
1342   FCD7 4D 20 
1343   FCD9 74 6F 20 64 	.BYTE "to download files to A",CR,LF
1343   FCDD 6F 77 6E 6C 
1343   FCE1 6F 61 64 20 
1343   FCE5 66 69 6C 65 
1343   FCE9 73 20 74 6F 
1343   FCED 20 41 0D 0A 
1344   FCF1 41 64 64 20 	.BYTE "Add SUPERSUB.COM and "
1344   FCF5 53 55 50 45 
1344   FCF9 52 53 55 42 
1344   FCFD 2E 43 4F 4D 
1344   FD01 20 61 6E 64 
1344   FD05 20 
1345   FD06 41 55 54 4F 	.BYTE "AUTOEXEC.SUB for auto run"
1345   FD0A 45 58 45 43 
1345   FD0E 2E 53 55 42 
1345   FD12 20 66 6F 72 
1345   FD16 20 61 75 74 
1345   FD1A 6F 20 72 75 
1345   FD1E 6E 
1346   FD1F 0D 0A FF    	.BYTE CR,LF,END
1347   FD22             
1348   FD22             TXT_COMMAND:
1349   FD22 0D 0A       	.BYTE CR,LF
1350   FD24 55 6E 6B 6E 	.BYTE "Unknown command"
1350   FD28 6F 77 6E 20 
1350   FD2C 63 6F 6D 6D 
1350   FD30 61 6E 64 
1351   FD33 FF          	.BYTE END
1352   FD34             
1353   FD34             TXT_CKSUMERR:
1354   FD34 0D 0A       	.BYTE CR,LF
1355   FD36 43 68 65 63 	.BYTE "Checksum error"
1355   FD3A 6B 73 75 6D 
1355   FD3E 20 65 72 72 
1355   FD42 6F 72 
1356   FD44 FF          	.BYTE END
1357   FD45             
1358   FD45             TXT_HELP:
1359   FD45 0D 0A       	.BYTE CR,LF
1360   FD47 44 20 58 58 	.BYTE "D XXXXH YYYYH Dump memory"
1360   FD4B 58 58 48 20 
1360   FD4F 59 59 59 59 
1360   FD53 48 20 44 75 
1360   FD57 6D 70 20 6D 
1360   FD5B 65 6D 6F 72 
1360   FD5F 79 
1361   FD60 20 66 72 6F 	.BYTE " from XXXX to YYYY",CR,LF
1361   FD64 6D 20 58 58 
1361   FD68 58 58 20 74 
1361   FD6C 6F 20 59 59 
1361   FD70 59 59 0D 0A 
1362   FD74 45 20 58 58 	.BYTE "E XXXXH Examine memory "
1362   FD78 58 58 48 20 
1362   FD7C 45 78 61 6D 
1362   FD80 69 6E 65 20 
1362   FD84 6D 65 6D 6F 
1362   FD88 72 79 20 
1363   FD8B 6C 6F 63 61 	.BYTE "location XXXX",CR,LF
1363   FD8F 74 69 6F 6E 
1363   FD93 20 58 58 58 
1363   FD97 58 0D 0A 
1364   FD9A 46 20 58 58 	.BYTE "F XXXXH YYYYH ZZH Fill memory"
1364   FD9E 58 58 48 20 
1364   FDA2 59 59 59 59 
1364   FDA6 48 20 5A 5A 
1364   FDAA 48 20 46 69 
1364   FDAE 6C 6C 20 6D 
1364   FDB2 65 6D 6F 72 
1364   FDB6 79 
1365   FDB7 20 66 72 6F 	.BYTE " from XXXX to YYYY with ZZ",CR,LF
1365   FDBB 6D 20 58 58 
1365   FDBF 58 58 20 74 
1365   FDC3 6F 20 59 59 
1365   FDC7 59 59 20 77 
1365   FDCB 69 74 68 20 
1365   FDCF 5A 5A 0D 0A 
1366   FDD3 48 20 4C 6F 	.BYTE "H Load intel hex format data",CR,LF
1366   FDD7 61 64 20 69 
1366   FDDB 6E 74 65 6C 
1366   FDDF 20 68 65 78 
1366   FDE3 20 66 6F 72 
1366   FDE7 6D 61 74 20 
1366   FDEB 64 61 74 61 
1366   FDEF 0D 0A 
1367   FDF1 49 20 49 6E 	.BYTE "I Input from port and "
1367   FDF5 70 75 74 20 
1367   FDF9 66 72 6F 6D 
1367   FDFD 20 70 6F 72 
1367   FE01 74 20 61 6E 
1367   FE05 64 20 
1368   FE07 73 68 6F 77 	.BYTE "show hex data",CR,LF
1368   FE0B 20 68 65 78 
1368   FE0F 20 64 61 74 
1368   FE13 61 0D 0A 
1369   FE16 4B 20 65 63 	.BYTE "K echo keyboard input",CR,LF
1369   FE1A 68 6F 20 6B 
1369   FE1E 65 79 62 6F 
1369   FE22 61 72 64 20 
1369   FE26 69 6E 70 75 
1369   FE2A 74 0D 0A 
1370   FE2D 4D 20 58 58 	.BYTE "M XXXXH YYYYH ZZZZH move memory"
1370   FE31 58 58 48 20 
1370   FE35 59 59 59 59 
1370   FE39 48 20 5A 5A 
1370   FE3D 5A 5A 48 20 
1370   FE41 6D 6F 76 65 
1370   FE45 20 6D 65 6D 
1370   FE49 6F 72 79 
1371   FE4C 20 62 6C 6F 	.BYTE " block XXXX to YYYY to ZZZZ",CR,LF
1371   FE50 63 6B 20 58 
1371   FE54 58 58 58 20 
1371   FE58 74 6F 20 59 
1371   FE5C 59 59 59 20 
1371   FE60 74 6F 20 5A 
1371   FE64 5A 5A 5A 0D 
1371   FE68 0A 
1372   FE69 4F 20 4F 75 	.BYTE "O Output to port hex data",CR,LF
1372   FE6D 74 70 75 74 
1372   FE71 20 74 6F 20 
1372   FE75 70 6F 72 74 
1372   FE79 20 68 65 78 
1372   FE7D 20 64 61 74 
1372   FE81 61 0D 0A 
1373   FE84 50 20 50 72 	.BYTE "P Program ram starting from"
1373   FE88 6F 67 72 61 
1373   FE8C 6D 20 72 61 
1373   FE90 6D 20 73 74 
1373   FE94 61 72 74 69 
1373   FE98 6E 67 20 66 
1373   FE9C 72 6F 6D 
1374   FE9F 20 63 75 72 	.BYTE " current location",CR,LF
1374   FEA3 72 65 6E 74 
1374   FEA7 20 6C 6F 63 
1374   FEAB 61 74 69 6F 
1374   FEAF 6E 0D 0A 
1375   FEB2 52 20 52 75 	.BYTE "R Run a program from "
1375   FEB6 6E 20 61 20 
1375   FEBA 70 72 6F 67 
1375   FEBE 72 61 6D 20 
1375   FEC2 66 72 6F 6D 
1375   FEC6 20 
1376   FEC7 63 75 72 72 	.BYTE "current location",CR,LF
1376   FECB 65 6E 74 20 
1376   FECF 6C 6F 63 61 
1376   FED3 74 69 6F 6E 
1376   FED7 0D 0A 
1377   FED9 54 20 46 6F 	.BYTE "T Format RAM disk B "
1377   FEDD 72 6D 61 74 
1377   FEE1 20 52 41 4D 
1377   FEE5 20 64 69 73 
1377   FEE9 6B 20 42 20 
1378   FEED 20 28 66 6F 	.BYTE " (format before first use)",CR,LF
1378   FEF1 72 6D 61 74 
1378   FEF5 20 62 65 66 
1378   FEF9 6F 72 65 20 
1378   FEFD 66 69 72 73 
1378   FF01 74 20 75 73 
1378   FF05 65 29 0D 0A 
1379   FF09 27 45 53 43 	.BYTE "'ESCAPE' Stop current mode"
1379   FF0D 41 50 45 27 
1379   FF11 20 53 74 6F 
1379   FF15 70 20 63 75 
1379   FF19 72 72 65 6E 
1379   FF1D 74 20 6D 6F 
1379   FF21 64 65 
1380   FF23 20 61 6E 64 	.BYTE " and wait for new command",CR,LF
1380   FF27 20 77 61 69 
1380   FF2B 74 20 66 6F 
1380   FF2F 72 20 6E 65 
1380   FF33 77 20 63 6F 
1380   FF37 6D 6D 61 6E 
1380   FF3B 64 0D 0A 
1381   FF3E 43 20 42 6F 	.BYTE "C Boot CP/M from ROM drive",CR,LF
1381   FF42 6F 74 20 43 
1381   FF46 50 2F 4D 20 
1381   FF4A 66 72 6F 6D 
1381   FF4E 20 52 4F 4D 
1381   FF52 20 64 72 69 
1381   FF56 76 65 0D 0A 
1382   FF5A FF          	.BYTE END
1383   FF5B             
1384   FF5B             TXT_FORMAT:
1385   FF5B 0D 0A       	.BYTE CR,LF
1386   FF5D 46 6F 72 6D 	.BYTE "Formatting..."
1386   FF61 61 74 74 69 
1386   FF65 6E 67 2E 2E 
1386   FF69 2E 
1387   FF6A FF          	.BYTE END
1388   FF6B             TXT_CPM:
1389   FF6B 0D 0A       	.BYTE CR,LF
1390   FF6D 4C 6F 61 64 	.BYTE "Loading CPM..."
1390   FF71 69 6E 67 20 
1390   FF75 43 50 4D 2E 
1390   FF79 2E 2E 
1391   FF7B FF          	.BYTE END
1392   FF7C             
1393   FF7C             ;********************* END OF PROGRAM ***********************************
1394   FF7C             
1395   FF7C             ;	.include ctxt001.asm		; YOU CAN INCLUDE OTHER ASM FILES AND USE-
1396   FF7C             					; THE SUB ROUTINES FROM THEM.
1397   FF7C 0A 0D 20 20 .text "\n\r  -END-OF-FILE-  \n\r"
1397   FF80 2D 45 4E 44 
1397   FF84 2D 4F 46 2D 
1397   FF88 46 49 4C 45 
1397   FF8C 2D 20 20 0A 
1397   FF90 0D 
1398   FF91             
1399   FFFF             .ORG	$FFFF
1400   FFFF FF          .BYTE	$FF
1401   10000             .END
tasm: Number of errors = 0
